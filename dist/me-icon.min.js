import { aA as BaseTransition, aB as BaseTransitionPropsValidators, aC as Comment, aD as DeprecationTypes, aE as EffectScope, aF as ErrorCodes, aG as ErrorTypeStrings, G as Fragment, aH as KeepAlive, aI as ReactiveEffect, aJ as Static, an as Suspense, T as Teleport, aK as Text, aL as TrackOpTypes, aM as Transition, aN as TransitionGroup, aO as TriggerOpTypes, aP as VueElement, aQ as assertNumber, aR as callWithAsyncErrorHandling, aS as callWithErrorHandling, aT as camelize, aU as capitalize, aV as cloneVNode, aW as compatUtils, e as computed, b as createApp, c as createBlock, p as createCommentVNode, F as createElementBlock, a as createBaseVNode, aX as createHydrationRenderer, aY as createPropsRestProxy, aZ as createRenderer, a_ as createSSRApp, ag as createSlots, a$ as createStaticVNode, B as createTextVNode, h as createVNode, b0 as customRef, b1 as defineAsyncComponent, d as defineComponent, ar as defineCustomElement, b2 as defineEmits, b3 as defineExpose, b4 as defineModel, b5 as defineOptions, b6 as defineProps, b7 as defineSSRCustomElement, b8 as defineSlots, b9 as devtools, ba as effect, bb as effectScope, bc as getCurrentInstance, bd as getCurrentScope, be as getCurrentWatcher, bf as getTransitionRawChildren, J as guardReactiveProps, bg as h, bh as handleError, bi as hasInjectionContext, bj as hydrate, bk as hydrateOnIdle, bl as hydrateOnInteraction, bm as hydrateOnMediaQuery, bn as hydrateOnVisible, bo as initCustomFormatter, bp as initDirectivesForSSR, ao as inject, bq as isMemoSame, br as isProxy, bs as isReactive, bt as isReadonly, aj as isRef, bu as isRuntimeOnly, bv as isShallow, bw as isVNode, a5 as markRaw, bx as mergeDefaults, by as mergeModels, v as mergeProps, n as nextTick, W as normalizeClass, I as normalizeProps, m as normalizeStyle, bz as onActivated, bA as onBeforeMount, aq as onBeforeUnmount, bB as onBeforeUpdate, bC as onDeactivated, bD as onErrorCaptured, f as onMounted, bE as onRenderTracked, bF as onRenderTriggered, bG as onScopeDispose, bH as onServerPrefetch, g as onUnmounted, bI as onUpdated, bJ as onWatcherCleanup, o as openBlock, bK as popScopeId, a7 as provide, bL as proxyRefs, bM as pushScopeId, bN as queuePostFlushCb, a4 as reactive, bO as readonly, l as ref, bP as registerRuntimeCompiler, bQ as render, Y as renderList, r as renderSlot, ap as resolveComponent, bR as resolveDirective, X as resolveDynamicComponent, bS as resolveFilter, bT as resolveTransitionHooks, bU as setBlockTracking, bV as setDevtoolsHook, bW as setTransitionHooks, a3 as shallowReactive, bX as shallowReadonly, am as shallowRef, bY as ssrContextKey, bZ as ssrUtils, b_ as stop, C as toDisplayString, b$ as toHandlerKey, aa as toHandlers, c0 as toRaw, a0 as toRef, t as toRefs, ak as toValue$1, c1 as transformVNodeArgs, c2 as triggerRef, u as unref, c3 as useAttrs, c4 as useCssModule, c5 as useCssVars, c6 as useHost, a6 as useId$1, au as useModel, c7 as useSSRContext, c8 as useShadowRoot, N as useSlots, al as useTemplateRef, c9 as useTransitionState, ca as vModelCheckbox, cb as vModelDynamic, cc as vModelRadio, cd as vModelSelect, ce as vModelText, cf as vShow, cg as version, ch as warn, q as watch, D as watchEffect, ci as watchPostEffect, cj as watchSyncEffect, ck as withAsyncContext, w as withCtx, cl as withDefaults, cm as withDirectives, x as withKeys, cn as withMemo, y as withModifiers, co as withScopeId, P as Primitive, cp as isNullish, cq as isEqual, k as useVModel$1, i as createContext, j as useForwardExpose, cr as defaultWindow, H as isClient, cs as renderSlotFragments, K as unrefElement$1, ct as useEventListener, cu as createGlobalState, E as onKeyStroke, cv as createSharedComposable, cw as tryOnBeforeUnmount, a9 as defu, cx as isIOS, cy as useMounted, cz as Slot, cA as computedEager, cB as refAutoReset, Q as useForwardPropsEmits, $ as useForwardProps, cC as reactiveOmit, at as useEmitAsProps, cD as createEventHook, cE as syncRef, cF as isClient$1, cG as isDef, cH as makeDestructurable, cI as camelize$1, R as reactivePick, S as tv, U as useAppConfig, V as _sfc_main$19, ab as get } from "./main.js";
/**
* vue v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const compile = () => {
};
const vue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getCurrentWatcher,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  hydrateOnIdle,
  hydrateOnInteraction,
  hydrateOnMediaQuery,
  hydrateOnVisible,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  onWatcherCleanup,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue: toValue$1,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useHost,
  useId: useId$1,
  useModel,
  useSSRContext,
  useShadowRoot,
  useSlots,
  useTemplateRef,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const hide = hide$1;
const arrow$1 = arrow$2;
const limitShift = limitShift$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue(source) {
  return typeof source === "function" ? source() : unref(source);
}
function arrow(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement(toValue(options.element));
      if (element == null) {
        return {};
      }
      return arrow$1({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _toValue;
    return (_toValue = toValue(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed(() => toValue(options.middleware));
  const placementOption = computed(() => {
    var _toValue2;
    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _toValue3;
    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed(() => {
    var _toValue4;
    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed(() => unwrapElement(reference.value));
  const floatingElement = computed(() => unwrapElement(floating.value));
  const x = ref(0);
  const y = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "VisuallyHidden",
  props: {
    feature: { default: "focusable" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
        "data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
        tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: "1px",
          height: "1px",
          padding: 0,
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          clipPath: "inset(50%)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]);
    };
  }
});
function isValueEqualOrExist(base, current) {
  if (isNullish(base))
    return false;
  if (Array.isArray(base)) {
    return base.some((val) => isEqual(val, current));
  } else {
    return isEqual(base, current);
  }
}
function validateProps({ type, defaultValue, modelValue }) {
  const value = modelValue || defaultValue;
  const canTypeBeInferred = modelValue !== void 0 || defaultValue !== void 0;
  if (canTypeBeInferred)
    return Array.isArray(value) ? "multiple" : "single";
  else
    return type ?? "single";
}
function getDefaultType({ type, defaultValue, modelValue }) {
  if (type)
    return type;
  return validateProps({ type, defaultValue, modelValue });
}
function getDefaultValue({ type, defaultValue }) {
  if (defaultValue !== void 0)
    return defaultValue;
  return type === "single" ? void 0 : [];
}
function useSingleOrMultipleValue(props, emits) {
  const type = computed(() => getDefaultType(props));
  const modelValue = useVModel$1(props, "modelValue", emits, {
    defaultValue: getDefaultValue(props),
    passive: props.modelValue === void 0,
    deep: true
  });
  function changeModelValue(value) {
    if (type.value === "single") {
      modelValue.value = isEqual(value, modelValue.value) ? void 0 : value;
    } else {
      const modelValueArray = Array.isArray(modelValue.value) ? [...modelValue.value || []] : [modelValue.value].filter(Boolean);
      if (isValueEqualOrExist(modelValueArray, value)) {
        const index = modelValueArray.findIndex((i) => isEqual(i, value));
        modelValueArray.splice(index, 1);
      } else {
        modelValueArray.push(value);
      }
      modelValue.value = modelValueArray;
    }
  }
  const isSingle = computed(() => type.value === "single");
  return {
    modelValue,
    changeModelValue,
    isSingle
  };
}
const [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    locale: { default: "en" },
    scrollBody: { type: [Boolean, Object], default: true },
    nonce: { default: void 0 },
    useId: { type: Function, default: void 0 }
  },
  setup(__props) {
    const props = __props;
    const { dir, locale, scrollBody, nonce } = toRefs(props);
    provideConfigProviderContext({
      dir,
      locale,
      scrollBody,
      nonce,
      useId: props.useId
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
function useDirection(dir) {
  const context2 = injectConfigProviderContext({
    dir: ref("ltr")
  });
  return computed(() => dir?.value || context2.dir?.value || "ltr");
}
const [injectAccordionRootContext, provideAccordionRootContext] = createContext("AccordionRoot");
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "AccordionRoot",
  props: {
    collapsible: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dir: {},
    orientation: { default: "vertical" },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { dir, disabled, unmountOnHide } = toRefs(props);
    const direction = useDirection(dir);
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props, emits);
    const { forwardRef, currentElement: parentElement } = useForwardExpose();
    provideAccordionRootContext({
      disabled,
      direction,
      orientation: props.orientation,
      parentElement,
      isSingle,
      collapsible: props.collapsible,
      modelValue,
      changeModelValue,
      unmountOnHide
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
const [injectCollapsibleRootContext, provideCollapsibleRootContext] = createContext("CollapsibleRoot");
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const open = useVModel$1(props, "open", emit, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const { disabled, unmountOnHide } = toRefs(props);
    provideCollapsibleRootContext({
      contentId: "",
      disabled,
      open,
      unmountOnHide,
      onOpenToggle: () => {
        if (disabled.value)
          return;
        open.value = !open.value;
      }
    });
    __expose({ open });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: _ctx.as,
        "as-child": props.asChild,
        "data-state": unref(open) ? "open" : "closed",
        "data-disabled": unref(disabled) ? "" : void 0
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-state", "data-disabled"]);
    };
  }
});
const ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options = {}) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName))
    return null;
  const {
    arrowKeyOptions = "both",
    attributeName = "[data-reka-collection-item]",
    itemsArray = [],
    loop = true,
    dir = "ltr",
    preventScroll = true,
    focus: focus2 = false
  } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical)) {
    return null;
  }
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item?.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, options, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index = elements.indexOf(currentElement);
  const newIndex = options.goForward ? index + 1 : index - 1;
  if (!options.loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(
      elements,
      candidate,
      options,
      iterations
    );
  }
  return candidate;
}
const [injectAccordionItemContext, provideAccordionItemContext] = createContext("AccordionItem");
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const open = computed(
      () => rootContext.isSingle.value ? props.value === rootContext.modelValue.value : Array.isArray(rootContext.modelValue.value) && rootContext.modelValue.value.includes(props.value)
    );
    const disabled = computed(() => {
      return rootContext.disabled.value || props.disabled;
    });
    const dataDisabled = computed(() => disabled.value ? "" : void 0);
    const dataState = computed(
      () => open.value ? "open" : "closed"
      /* Closed */
    );
    __expose({ open, dataDisabled });
    const { currentRef, currentElement } = useForwardExpose();
    provideAccordionItemContext({
      open,
      dataState,
      disabled,
      dataDisabled,
      triggerId: "",
      currentRef,
      currentElement,
      value: computed(() => props.value)
    });
    function handleArrowKey(e) {
      const target = e.target;
      const allCollectionItems = Array.from(rootContext.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []);
      const collectionItemIndex = allCollectionItems.findIndex((item) => item === target);
      if (collectionItemIndex === -1)
        return null;
      useArrowNavigation(
        e,
        target,
        rootContext.parentElement.value,
        {
          arrowKeyOptions: rootContext.orientation,
          dir: rootContext.direction.value,
          focus: true
        }
      );
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$15), {
        "data-orientation": unref(rootContext).orientation,
        "data-disabled": dataDisabled.value,
        "data-state": dataState.value,
        disabled: disabled.value,
        open: open.value,
        as: props.as,
        "as-child": props.asChild,
        "unmount-on-hide": unref(rootContext).unmountOnHide.value,
        onKeydown: withKeys(handleArrowKey, ["up", "down", "left", "right", "home", "end"])
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: open.value })
        ]),
        _: 3
      }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as", "as-child", "unmount-on-hide"]);
    };
  }
});
let count$1 = 0;
function useId(deterministicId, prefix = "reka") {
  const configProviderContext = injectConfigProviderContext({ useId: void 0 });
  if (Object.hasOwn(vue, "useId")) {
    return `${prefix}-${useId$1?.()}`;
  } else if (configProviderContext.useId) {
    return `${prefix}-${configProviderContext.useId()}`;
  }
  return `${prefix}-${++count$1}`;
}
function useStateMachine(initialState, machine) {
  const state = ref(initialState);
  function reducer(event) {
    const nextState = machine[state.value][event];
    return nextState ?? state.value;
  }
  const dispatch = (event) => {
    state.value = reducer(event);
  };
  return {
    state,
    dispatch
  };
}
function usePresence(present, node) {
  const stylesRef = ref({});
  const prevAnimationNameRef = ref("none");
  const prevPresentRef = ref(present);
  const initialState = present.value ? "mounted" : "unmounted";
  let timeoutId;
  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow;
  const { state, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  const dispatchCustomEvent = (name) => {
    if (isClient) {
      const customEvent = new CustomEvent(name, { bubbles: false, cancelable: false });
      node.value?.dispatchEvent(customEvent);
    }
  };
  watch(
    present,
    async (currentPresent, prevPresent) => {
      const hasPresentChanged = prevPresent !== currentPresent;
      await nextTick();
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.value;
        const currentAnimationName = getAnimationName(node.value);
        if (currentPresent) {
          dispatch("MOUNT");
          dispatchCustomEvent("enter");
          if (currentAnimationName === "none")
            dispatchCustomEvent("after-enter");
        } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
          dispatch("UNMOUNT");
          dispatchCustomEvent("leave");
          dispatchCustomEvent("after-leave");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (prevPresent && isAnimating) {
            dispatch("ANIMATION_OUT");
            dispatchCustomEvent("leave");
          } else {
            dispatch("UNMOUNT");
            dispatchCustomEvent("after-leave");
          }
        }
      }
    },
    { immediate: true }
  );
  const handleAnimationEnd = (event) => {
    const currentAnimationName = getAnimationName(node.value);
    const isCurrentAnimation = currentAnimationName.includes(
      event.animationName
    );
    const directionName = state.value === "mounted" ? "enter" : "leave";
    if (event.target === node.value && isCurrentAnimation) {
      dispatchCustomEvent(`after-${directionName}`);
      dispatch("ANIMATION_END");
      if (!prevPresentRef.value) {
        const currentFillMode = node.value.style.animationFillMode;
        node.value.style.animationFillMode = "forwards";
        timeoutId = ownerWindow?.setTimeout(() => {
          if (node.value?.style.animationFillMode === "forwards") {
            node.value.style.animationFillMode = currentFillMode;
          }
        });
      }
    }
    if (event.target === node.value && currentAnimationName === "none")
      dispatch("ANIMATION_END");
  };
  const handleAnimationStart = (event) => {
    if (event.target === node.value) {
      prevAnimationNameRef.value = getAnimationName(node.value);
    }
  };
  const watcher = watch(
    node,
    (newNode, oldNode) => {
      if (newNode) {
        stylesRef.value = getComputedStyle(newNode);
        newNode.addEventListener("animationstart", handleAnimationStart);
        newNode.addEventListener("animationcancel", handleAnimationEnd);
        newNode.addEventListener("animationend", handleAnimationEnd);
      } else {
        dispatch("ANIMATION_END");
        if (timeoutId !== void 0)
          ownerWindow?.clearTimeout(timeoutId);
        oldNode?.removeEventListener("animationstart", handleAnimationStart);
        oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
        oldNode?.removeEventListener("animationend", handleAnimationEnd);
      }
    },
    { immediate: true }
  );
  const stateWatcher = watch(state, () => {
    const currentAnimationName = getAnimationName(node.value);
    prevAnimationNameRef.value = state.value === "mounted" ? currentAnimationName : "none";
  });
  onUnmounted(() => {
    watcher();
    stateWatcher();
  });
  const isPresent = computed(
    () => ["mounted", "unmountSuspended"].includes(state.value)
  );
  return {
    isPresent
  };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}
const Presence = defineComponent({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(props, { slots, expose }) {
    const { present, forceMount } = toRefs(props);
    const node = ref();
    const { isPresent } = usePresence(present, node);
    expose({ present: isPresent });
    let children = slots.default({ present: isPresent.value });
    children = renderSlotFragments(children || []);
    const instance = getCurrentInstance();
    if (children && children?.length > 1) {
      const componentName = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((line) => `  - ${line}`).join("\n")
        ].join("\n")
      );
    }
    return () => {
      if (forceMount.value || present.value || isPresent.value) {
        return h(slots.default({ present: isPresent.value })[0], {
          ref: (v) => {
            const el = unrefElement$1(v);
            if (typeof el?.hasAttribute === "undefined")
              return el;
            if (el?.hasAttribute("data-reka-popper-content-wrapper"))
              node.value = el.firstElementChild;
            else
              node.value = el;
            return el;
          }
        });
      } else {
        return null;
      }
    };
  }
});
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["contentFound"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectCollapsibleRootContext();
    rootContext.contentId ||= useId(void 0, "reka-collapsible-content");
    const presentRef = ref();
    const { forwardRef, currentElement } = useForwardExpose();
    const width = ref(0);
    const height = ref(0);
    const isOpen = computed(() => rootContext.open.value);
    const isMountAnimationPrevented = ref(isOpen.value);
    const currentStyle = ref();
    watch(
      () => [isOpen.value, presentRef.value?.present],
      async () => {
        await nextTick();
        const node = currentElement.value;
        if (!node)
          return;
        currentStyle.value = currentStyle.value || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        };
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        height.value = rect.height;
        width.value = rect.width;
        if (!isMountAnimationPrevented.value) {
          node.style.transitionDuration = currentStyle.value.transitionDuration;
          node.style.animationName = currentStyle.value.animationName;
        }
      },
      {
        immediate: true
      }
    );
    const skipAnimation = computed(() => isMountAnimationPrevented.value && rootContext.open.value);
    onMounted(() => {
      requestAnimationFrame(() => {
        isMountAnimationPrevented.value = false;
      });
    });
    useEventListener(currentElement, "beforematch", (ev) => {
      requestAnimationFrame(() => {
        rootContext.onOpenToggle();
        emits("contentFound");
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        ref_key: "presentRef",
        ref: presentRef,
        present: _ctx.forceMount || unref(rootContext).open.value,
        "force-mount": true
      }, {
        default: withCtx(({ present }) => [
          createVNode(unref(Primitive), mergeProps(_ctx.$attrs, {
            id: unref(rootContext).contentId,
            ref: unref(forwardRef),
            "as-child": props.asChild,
            as: _ctx.as,
            hidden: !present ? unref(rootContext).unmountOnHide.value ? "" : "until-found" : void 0,
            "data-state": skipAnimation.value ? void 0 : unref(rootContext).open.value ? "open" : "closed",
            "data-disabled": unref(rootContext).disabled?.value ? "" : void 0,
            style: {
              [`--reka-collapsible-content-height`]: `${height.value}px`,
              [`--reka-collapsible-content-width`]: `${width.value}px`
            }
          }), {
            default: withCtx(() => [
              (unref(rootContext).unmountOnHide.value ? present : true) ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1040, ["id", "as-child", "as", "hidden", "data-state", "data-disabled", "style"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$13), {
        role: "region",
        "as-child": props.asChild,
        as: _ctx.as,
        "force-mount": props.forceMount,
        "aria-labelledby": unref(itemContext).triggerId,
        "data-state": unref(itemContext).dataState.value,
        "data-disabled": unref(itemContext).dataDisabled.value,
        "data-orientation": unref(rootContext).orientation,
        style: { "--reka-accordion-content-width": "var(--reka-collapsible-content-width)", "--reka-accordion-content-height": "var(--reka-collapsible-content-height)" },
        onContentFound: _cache[0] || (_cache[0] = ($event) => unref(rootContext).changeModelValue(unref(itemContext).value.value))
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "force-mount", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]);
    };
  }
});
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: props.as,
        "as-child": props.asChild,
        "data-orientation": unref(rootContext).orientation,
        "data-state": unref(itemContext).dataState.value,
        "data-disabled": unref(itemContext).dataDisabled.value
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]);
    };
  }
});
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectCollapsibleRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props.asChild,
        "aria-controls": unref(rootContext).contentId,
        "aria-expanded": unref(rootContext).open.value,
        "data-state": unref(rootContext).open.value ? "open" : "closed",
        "data-disabled": unref(rootContext).disabled?.value ? "" : void 0,
        disabled: unref(rootContext).disabled?.value,
        onClick: unref(rootContext).onOpenToggle
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    itemContext.triggerId ||= useId(void 0, "reka-accordion-trigger");
    function changeItem() {
      const triggerDisabled = rootContext.isSingle.value && itemContext.open.value && !rootContext.collapsible;
      if (itemContext.disabled.value || triggerDisabled)
        return;
      rootContext.changeModelValue(itemContext.value.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$10), {
        id: unref(itemContext).triggerId,
        ref: unref(itemContext).currentRef,
        "data-reka-collection-item": "",
        as: props.as,
        "as-child": props.asChild,
        "aria-disabled": unref(itemContext).disabled.value || void 0,
        "aria-expanded": unref(itemContext).open.value || false,
        "data-disabled": unref(itemContext).dataDisabled.value,
        "data-orientation": unref(rootContext).orientation,
        "data-state": unref(itemContext).dataState.value,
        disabled: unref(itemContext).disabled.value,
        onClick: changeItem
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]);
    };
  }
});
function getActiveElement() {
  let activeElement = document.activeElement;
  if (activeElement == null) {
    return null;
  }
  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}
const ITEM_SELECT = "menu.itemSelect";
const SELECTION_KEYS = ["Enter", " "];
const FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
const LAST_KEYS = ["ArrowUp", "PageDown", "End"];
const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$2(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function isPointInPolygon$1(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}
const useFocusStackState = createGlobalState(() => {
  const stack = ref([]);
  return stack;
});
function createFocusScopesStack() {
  const stack = useFocusStackState();
  return {
    add(focusScope) {
      const activeFocusScope = stack.value[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope?.pause();
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value.unshift(focusScope);
    },
    remove(focusScope) {
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1)
    updatedArray.splice(index, 1);
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
function focusFirst$1(candidates, { select = false } = {}) {
  const previouslyFocusedElement = getActiveElement();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = getActiveElement();
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) {
      element.select();
    }
  }
}
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: false },
    trapped: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { currentRef, currentElement } = useForwardExpose();
    const lastFocusedElementRef = ref(null);
    const focusScopesStack = createFocusScopesStack();
    const focusScope = reactive({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    });
    watchEffect((cleanupFn) => {
      if (!isClient)
        return;
      const container = currentElement.value;
      if (!props.trapped)
        return;
      function handleFocusIn(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target))
          lastFocusedElementRef.value = target;
        else focus(lastFocusedElementRef.value, { select: true });
      }
      function handleFocusOut(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget))
          focus(lastFocusedElementRef.value, { select: true });
      }
      function handleMutations(mutations) {
        const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value);
        if (!isLastFocusedElementExist)
          focus(container);
      }
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      cleanupFn(() => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      });
    });
    watchEffect(async (cleanupFn) => {
      const container = currentElement.value;
      await nextTick();
      if (!container)
        return;
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = getActiveElement();
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$1(removeLinks(getTabbableCandidates(container)), {
            select: true
          });
          if (getActiveElement() === previouslyFocusedElement)
            focus(container);
        }
      }
      cleanupFn(() => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
        const unmountEventHandler = (ev) => {
          emits("unmountAutoFocus", ev);
        };
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
        container.dispatchEvent(unmountEvent);
        setTimeout(() => {
          if (!unmountEvent.defaultPrevented)
            focus(previouslyFocusedElement ?? document.body, { select: true });
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
          focusScopesStack.remove(focusScope);
        }, 0);
      });
    });
    function handleKeyDown(event) {
      if (!props.loop && !props.trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = getActiveElement();
      if (isTabKey && focusedElement) {
        const container = event.currentTarget;
        const [first, last] = getTabbableEdges(container);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (props.loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (props.loop)
              focus(last, { select: true });
          }
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref_key: "currentRef",
        ref: currentRef,
        tabindex: "-1",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        onKeydown: handleKeyDown
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}
const POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(layerElement, targetElement) {
  const targetLayer = targetElement.closest(
    "[data-dismissable-layer]"
  );
  const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector(
    "[data-dismissable-layer]"
  );
  const nodeList = Array.from(
    layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))) {
    return true;
  } else {
    return false;
  }
}
function usePointerDownOutside(onPointerDownOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isPointerInsideDOMTree = ref(false);
  const handleClickRef = ref(() => {
  });
  watchEffect((cleanupFn) => {
    if (!isClient || !toValue$1(enabled))
      return;
    const handlePointerDown = async (event) => {
      const target = event.target;
      if (!element?.value || !target)
        return;
      if (isLayerExist(element.value, target)) {
        isPointerInsideDOMTree.value = false;
        return;
      }
      if (event.target && !isPointerInsideDOMTree.value) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            onPointerDownOutside,
            eventDetail
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.value);
          handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.value, {
            once: true
          });
        } else {
          handleAndDispatchPointerDownOutsideEvent();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.value);
      }
      isPointerInsideDOMTree.value = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    cleanupFn(() => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.value);
    });
  });
  return {
    onPointerDownCapture: () => {
      if (!toValue$1(enabled))
        return;
      isPointerInsideDOMTree.value = true;
    }
  };
}
function useFocusOutside(onFocusOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isFocusInsideDOMTree = ref(false);
  watchEffect((cleanupFn) => {
    if (!isClient || !toValue$1(enabled))
      return;
    const handleFocus = async (event) => {
      if (!element?.value)
        return;
      await nextTick();
      await nextTick();
      const target = event.target;
      if (!element.value || !target || isLayerExist(element.value, target))
        return;
      if (event.target && !isFocusInsideDOMTree.value) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(
          FOCUS_OUTSIDE,
          onFocusOutside,
          eventDetail
        );
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
  });
  return {
    onFocusCapture: () => {
      if (!toValue$1(enabled))
        return;
      isFocusInsideDOMTree.value = true;
    },
    onBlurCapture: () => {
      if (!toValue$1(enabled))
        return;
      isFocusInsideDOMTree.value = false;
    }
  };
}
const context = reactive({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef, currentElement: layerElement } = useForwardExpose();
    const ownerDocument = computed(
      () => layerElement.value?.ownerDocument ?? globalThis.document
    );
    const layers = computed(() => context.layersRoot);
    const index = computed(() => {
      return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
    });
    const isBodyPointerEventsDisabled = computed(() => {
      return context.layersWithOutsidePointerEventsDisabled.size > 0;
    });
    const isPointerEventsEnabled = computed(() => {
      const localLayers = Array.from(layers.value);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
    });
    const pointerDownOutside = usePointerDownOutside(async (event) => {
      const isPointerDownOnBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (!isPointerEventsEnabled.value || isPointerDownOnBranch)
        return;
      emits("pointerDownOutside", event);
      emits("interactOutside", event);
      await nextTick();
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    const focusOutside = useFocusOutside((event) => {
      const isFocusInBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (isFocusInBranch)
        return;
      emits("focusOutside", event);
      emits("interactOutside", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    onKeyStroke("Escape", (event) => {
      const isHighestLayer = index.value === layers.value.size - 1;
      if (!isHighestLayer)
        return;
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    });
    let originalBodyPointerEvents;
    watchEffect((cleanupFn) => {
      if (!layerElement.value)
        return;
      if (props.disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
          ownerDocument.value.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
      }
      layers.value.add(layerElement.value);
      cleanupFn(() => {
        if (props.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
        }
      });
    });
    watchEffect((cleanupFn) => {
      cleanupFn(() => {
        if (!layerElement.value)
          return;
        layers.value.delete(layerElement.value);
        context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-dismissable-layer": "",
        style: normalizeStyle({
          pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: unref(focusOutside).onFocusCapture,
        onBlurCapture: unref(focusOutside).onBlurCapture,
        onPointerdownCapture: unref(pointerDownOutside).onPointerDownCapture
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]);
    };
  }
});
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
function useHideOthers(target) {
  let undo;
  watch(() => unrefElement$1(target), (el) => {
    if (el)
      undo = hideOthers(el);
    else if (undo)
      undo();
  });
  onUnmounted(() => {
    if (undo)
      undo();
  });
}
const useBodyLockStackCount = createSharedComposable(() => {
  const map = ref(/* @__PURE__ */ new Map());
  const initialOverflow = ref();
  const locked = computed(() => {
    for (const value of map.value.values()) {
      if (value)
        return true;
    }
    return false;
  });
  const context2 = injectConfigProviderContext({
    scrollBody: ref(true)
  });
  let stopTouchMoveListener = null;
  const resetBodyStyle = () => {
    document.body.style.paddingRight = "";
    document.body.style.marginRight = "";
    document.body.style.pointerEvents = "";
    document.documentElement.style.removeProperty("--scrollbar-width");
    document.body.style.overflow = initialOverflow.value ?? "";
    isIOS && stopTouchMoveListener?.();
    initialOverflow.value = void 0;
  };
  watch(locked, (val, oldVal) => {
    if (!isClient)
      return;
    if (!val) {
      if (oldVal)
        resetBodyStyle();
      return;
    }
    if (initialOverflow.value === void 0)
      initialOverflow.value = document.body.style.overflow;
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const defaultConfig = { padding: verticalScrollbarWidth, margin: 0 };
    const config = context2.scrollBody?.value ? typeof context2.scrollBody.value === "object" ? defu({
      padding: context2.scrollBody.value.padding === true ? verticalScrollbarWidth : context2.scrollBody.value.padding,
      margin: context2.scrollBody.value.margin === true ? verticalScrollbarWidth : context2.scrollBody.value.margin
    }, defaultConfig) : defaultConfig : { padding: 0, margin: 0 };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = typeof config.padding === "number" ? `${config.padding}px` : String(config.padding);
      document.body.style.marginRight = typeof config.margin === "number" ? `${config.margin}px` : String(config.margin);
      document.documentElement.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        document,
        "touchmove",
        (e) => preventDefault(e),
        { passive: false }
      );
    }
    nextTick(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  }, { immediate: true, flush: "sync" });
  return map;
});
function useBodyScrollLock(initialState) {
  const id = Math.random().toString(36).substring(2, 7);
  const map = useBodyLockStackCount();
  map.value.set(id, initialState ?? false);
  const locked = computed({
    get: () => map.value.get(id) ?? false,
    set: (value) => map.value.set(id, value)
  });
  tryOnBeforeUnmount(() => {
    map.value.delete(id);
  });
  return locked;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!(parent instanceof Element) || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (_target instanceof Element && checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault && e.cancelable)
    e.preventDefault();
  return false;
}
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const isMounted = useMounted();
    return (_ctx, _cache) => {
      return unref(isMounted) || _ctx.forceMount ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: _ctx.to,
        disabled: _ctx.disabled,
        defer: _ctx.defer
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, ["to", "disabled", "defer"])) : createCommentVNode("", true);
    };
  }
});
function usePrimitiveElement() {
  const primitiveElement = ref();
  const currentElement = computed(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement$1(primitiveElement));
  return {
    primitiveElement,
    currentElement
  };
}
const ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options = {}) {
  const { key = "", isProvider = false } = options;
  const injectionKey = `${key}CollectionProvider`;
  let context2;
  if (isProvider) {
    const itemMap = ref(/* @__PURE__ */ new Map());
    const collectionRef = ref();
    context2 = {
      collectionRef,
      itemMap
    };
    provide(injectionKey, context2);
  } else {
    context2 = inject(injectionKey);
  }
  const getItems = (includeDisabledItem = false) => {
    const collectionNode = context2.collectionRef.value;
    if (!collectionNode)
      return [];
    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
    const items = Array.from(context2.itemMap.value.values());
    const orderedItems = items.sort(
      (a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref)
    );
    if (includeDisabledItem)
      return orderedItems;
    else
      return orderedItems.filter((i) => i.ref.dataset.disabled !== "");
  };
  const CollectionSlot = defineComponent({
    name: "CollectionSlot",
    setup(_, { slots }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watch(currentElement, () => {
        context2.collectionRef.value = currentElement.value;
      });
      return () => h(Slot, { ref: primitiveElement }, slots);
    }
  });
  const CollectionItem = defineComponent({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        // It accepts any value
        validator: () => true
      }
    },
    setup(props, { slots, attrs }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watchEffect((cleanupFn) => {
        if (currentElement.value) {
          const key2 = markRaw(currentElement.value);
          context2.itemMap.value.set(key2, { ref: currentElement.value, value: props.value });
          cleanupFn(() => context2.itemMap.value.delete(key2));
        }
      });
      return () => h(Slot, { ...attrs, [ITEM_DATA_ATTR]: "", ref: primitiveElement }, slots);
    }
  });
  const reactiveItems = computed(() => Array.from(context2.itemMap.value.values()));
  const itemMapSize = computed(() => context2.itemMap.value.size);
  return { getItems, reactiveItems, itemMapSize, CollectionSlot, CollectionItem };
}
const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
const [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup");
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: false },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { loop, orientation, dir: propDir } = toRefs(props);
    const dir = useDirection(propDir);
    const currentTabStopId = useVModel$1(props, "currentTabStopId", emits, {
      defaultValue: props.defaultCurrentTabStopId,
      passive: props.currentTabStopId === void 0
    });
    const isTabbingBackOut = ref(false);
    const isClickFocus = ref(false);
    const focusableItemsCount = ref(0);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    function handleFocus(event) {
      const isKeyboardFocus = !isClickFocus.value;
      if (event.currentTarget && event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        emits("entryFocus", entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
          const activeItem = items.find((item) => item.getAttribute("data-active") === "");
          const currentItem = items.find(
            (item) => item.id === currentTabStopId.value
          );
          const candidateItems = [activeItem, currentItem, ...items].filter(
            Boolean
          );
          focusFirst(candidateItems, props.preventScrollOnEntryFocus);
        }
      }
      isClickFocus.value = false;
    }
    function handleMouseUp() {
      setTimeout(() => {
        isClickFocus.value = false;
      }, 1);
    }
    __expose({
      getItems
    });
    provideRovingFocusGroupContext({
      loop,
      dir,
      orientation,
      currentTabStopId,
      onItemFocus: (tabStopId) => {
        currentTabStopId.value = tabStopId;
      },
      onItemShiftTab: () => {
        isTabbingBackOut.value = true;
      },
      onFocusableItemAdd: () => {
        focusableItemsCount.value++;
      },
      onFocusableItemRemove: () => {
        focusableItemsCount.value--;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(CollectionSlot), null, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            tabindex: isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0,
            "data-orientation": unref(orientation),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref(dir),
            style: { "outline": "none" },
            onMousedown: _cache[0] || (_cache[0] = ($event) => isClickFocus.value = true),
            onMouseup: handleMouseUp,
            onFocus: handleFocus,
            onBlur: _cache[1] || (_cache[1] = ($event) => isTabbingBackOut.value = false)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
        ]),
        _: 3
      });
    };
  }
});
const [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperRoot",
  setup(__props) {
    const anchor = ref();
    providePopperRootContext({
      anchor,
      onAnchorChange: (element) => anchor.value = element
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "PopperAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectPopperRootContext();
    watchPostEffect(() => {
      rootContext.onAnchorChange(props.reference ?? currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
const _hoisted_1$1 = {
  key: 0,
  d: "M0 0L6 6L12 0"
};
const _hoisted_2 = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
        width: _ctx.width,
        height: _ctx.height,
        viewBox: _ctx.asChild ? void 0 : "0 0 12 6",
        preserveAspectRatio: _ctx.asChild ? void 0 : "none"
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            !_ctx.rounded ? (openBlock(), createElementBlock("path", _hoisted_1$1)) : (openBlock(), createElementBlock("path", _hoisted_2))
          ])
        ]),
        _: 3
      }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]);
    };
  }
});
function isNotNull(value) {
  return value !== null;
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function useSize(element) {
  const size2 = ref();
  const width = computed(() => size2.value?.width ?? 0);
  const height = computed(() => size2.value?.height ?? 0);
  onMounted(() => {
    const el = unrefElement$1(element);
    if (el) {
      size2.value = { width: el.offsetWidth, height: el.offsetHeight };
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width2;
        let height2;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry.borderBoxSize;
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width2 = borderSize.inlineSize;
          height2 = borderSize.blockSize;
        } else {
          width2 = el.offsetWidth;
          height2 = el.offsetHeight;
        }
        size2.value = { width: width2, height: height2 };
      });
      resizeObserver.observe(el, { box: "border-box" });
      return () => resizeObserver.unobserve(el);
    } else {
      size2.value = void 0;
    }
  });
  return {
    width,
    height
  };
}
const PopperContentPropsDefaultValue = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: true,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: false,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: false
};
const [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperContent",
  props: /* @__PURE__ */ mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopperRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const floatingRef = ref();
    const arrow$12 = ref();
    const { width: arrowWidth, height: arrowHeight } = useSize(arrow$12);
    const desiredPlacement = computed(
      () => props.side + (props.align !== "center" ? `-${props.align}` : "")
    );
    const collisionPadding = computed(() => {
      return typeof props.collisionPadding === "number" ? props.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...props.collisionPadding };
    });
    const boundary = computed(() => {
      return Array.isArray(props.collisionBoundary) ? props.collisionBoundary : [props.collisionBoundary];
    });
    const detectOverflowOptions = computed(() => {
      return {
        padding: collisionPadding.value,
        boundary: boundary.value.filter(isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: boundary.value.length > 0
      };
    });
    const computedMiddleware = computedEager(() => {
      return [
        offset({
          mainAxis: props.sideOffset + arrowHeight.value,
          alignmentAxis: props.alignOffset
        }),
        props.prioritizePosition && props.avoidCollisions && flip({
          ...detectOverflowOptions.value
        }),
        props.avoidCollisions && shift({
          mainAxis: true,
          crossAxis: !!props.prioritizePosition,
          limiter: props.sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions.value
        }),
        !props.prioritizePosition && props.avoidCollisions && flip({
          ...detectOverflowOptions.value
        }),
        size({
          ...detectOverflowOptions.value,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty(
              "--reka-popper-available-width",
              `${availableWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-available-height",
              `${availableHeight}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-width",
              `${anchorWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-height",
              `${anchorHeight}px`
            );
          }
        }),
        arrow$12.value && arrow({ element: arrow$12.value, padding: props.arrowPadding }),
        transformOrigin({
          arrowWidth: arrowWidth.value,
          arrowHeight: arrowHeight.value
        }),
        props.hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions.value })
      ];
    });
    const reference = computed(() => props.reference ?? rootContext.anchor.value);
    const { floatingStyles, placement, isPositioned, middlewareData } = useFloating(
      reference,
      floatingRef,
      {
        strategy: props.positionStrategy,
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            layoutShift: !props.disableUpdateOnLayoutShift,
            animationFrame: props.updatePositionStrategy === "always"
          });
          return cleanup;
        },
        middleware: computedMiddleware
      }
    );
    const placedSide = computed(
      () => getSideAndAlignFromPlacement(placement.value)[0]
    );
    const placedAlign = computed(
      () => getSideAndAlignFromPlacement(placement.value)[1]
    );
    watchPostEffect(() => {
      if (isPositioned.value)
        emits("placed");
    });
    const cannotCenterArrow = computed(
      () => middlewareData.value.arrow?.centerOffset !== 0
    );
    const contentZIndex = ref("");
    watchEffect(() => {
      if (contentElement.value)
        contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    const arrowX = computed(() => middlewareData.value.arrow?.x ?? 0);
    const arrowY = computed(() => middlewareData.value.arrow?.y ?? 0);
    providePopperContentContext({
      placedSide,
      onArrowChange: (element) => arrow$12.value = element,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "floatingRef",
        ref: floatingRef,
        "data-reka-popper-content-wrapper": "",
        style: normalizeStyle({
          ...unref(floatingStyles),
          transform: unref(isPositioned) ? unref(floatingStyles).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex.value,
          ["--reka-popper-transform-origin"]: [
            unref(middlewareData).transformOrigin?.x,
            unref(middlewareData).transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...unref(middlewareData).hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        createVNode(unref(Primitive), mergeProps({ ref: unref(forwardRef) }, _ctx.$attrs, {
          "as-child": props.asChild,
          as: _ctx.as,
          "data-side": placedSide.value,
          "data-align": placedAlign.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: !unref(isPositioned) ? "none" : void 0
          }
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
});
const OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const contentContext = injectPopperContentContext();
    const baseSide = computed(() => OPPOSITE_SIDE[contentContext.placedSide.value]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref: (el) => {
          unref(contentContext).onArrowChange(el);
          return void 0;
        },
        style: normalizeStyle({
          position: "absolute",
          left: unref(contentContext).arrowX?.value ? `${unref(contentContext).arrowX?.value}px` : void 0,
          top: unref(contentContext).arrowY?.value ? `${unref(contentContext).arrowY?.value}px` : void 0,
          [baseSide.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref(contentContext).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref(contentContext).placedSide.value],
          visibility: unref(contentContext).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        createVNode(_sfc_main$U, mergeProps(_ctx.$attrs, {
          ref: unref(forwardRef),
          style: {
            display: "block"
          },
          as: _ctx.as,
          "as-child": _ctx.asChild,
          rounded: _ctx.rounded,
          width: _ctx.width,
          height: _ctx.height
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "rounded", "width", "height"])
      ], 4);
    };
  }
});
function useTypeahead(callback) {
  const search = refAutoReset("", 1e3);
  const handleTypeaheadSearch = (key, items) => {
    search.value = search.value + key;
    {
      const currentItem = getActiveElement();
      const itemsWithTextValue = items.map((item) => ({
        ...item,
        textValue: item.value?.textValue ?? item.ref.textContent?.trim() ?? ""
      }));
      const currentMatch = itemsWithTextValue.find((item) => item.ref === currentItem);
      const values = itemsWithTextValue.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search.value, currentMatch?.textValue);
      const newItem = itemsWithTextValue.find((item) => item.textValue === nextMatch);
      if (newItem)
        newItem.ref.focus();
      return newItem?.ref;
    }
  };
  const resetTypeahead = () => {
    search.value = "";
  };
  return {
    search,
    handleTypeaheadSearch,
    resetTypeahead
  };
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$S), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
function useIsUsingKeyboardImpl() {
  const isUsingKeyboard = ref(false);
  onMounted(() => {
    useEventListener("keydown", () => {
      isUsingKeyboard.value = true;
    }, { capture: true, passive: true });
    useEventListener(["pointerdown", "pointermove"], () => {
      isUsingKeyboard.value = false;
    }, { capture: true, passive: true });
  });
  return isUsingKeyboard;
}
const useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl);
const [injectMenuContext, provideMenuContext] = createContext(["MenuRoot", "MenuSub"], "MenuContext");
const [injectMenuRootContext, provideMenuRootContext] = createContext("MenuRoot");
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: false },
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { modal, dir: propDir } = toRefs(props);
    const dir = useDirection(propDir);
    const open = useVModel$1(props, "open", emits);
    const content = ref();
    const isUsingKeyboardRef = useIsUsingKeyboard();
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuRootContext({
      onClose: () => {
        open.value = false;
      },
      isUsingKeyboardRef,
      dir,
      modal
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$W), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});
let count = 0;
function useFocusGuards() {
  watchEffect((cleanupFn) => {
    if (!isClient)
      return;
    const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      edgeGuards[0] ?? createFocusGuard()
    );
    document.body.insertAdjacentElement(
      "beforeend",
      edgeGuards[1] ?? createFocusGuard()
    );
    count++;
    cleanupFn(() => {
      if (count === 1) {
        document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    });
  });
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-reka-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
const [injectMenuContentContext, provideMenuContentContext] = createContext("MenuContent");
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const { trapFocus, disableOutsidePointerEvents, loop } = toRefs(props);
    useFocusGuards();
    useBodyScrollLock(disableOutsidePointerEvents.value);
    const searchRef = ref("");
    const timerRef = ref(0);
    const pointerGraceTimerRef = ref(0);
    const pointerGraceIntentRef = ref(null);
    const pointerDirRef = ref("right");
    const lastPointerXRef = ref(0);
    const currentItemId = ref(null);
    const rovingFocusGroupRef = ref();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const { handleTypeaheadSearch } = useTypeahead();
    watch(contentElement, (el) => {
      menuContext.onContentChange(el);
    });
    onUnmounted(() => {
      window.clearTimeout(timerRef.value);
    });
    function isPointerMovingToSubmenu(event) {
      const isMovingTowards = pointerDirRef.value === pointerGraceIntentRef.value?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.value?.area);
    }
    async function handleMountAutoFocus(event) {
      emits("openAutoFocus", event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      contentElement.value?.focus({
        preventScroll: true
      });
    }
    function handleKeyDown(event) {
      if (event.defaultPrevented)
        return;
      const target = event.target;
      const isKeyDownInside = target.closest("[data-reka-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      const el = useArrowNavigation(
        event,
        getActiveElement(),
        contentElement.value,
        {
          loop: loop.value,
          arrowKeyOptions: "vertical",
          dir: rootContext?.dir.value,
          focus: true,
          attributeName: "[data-reka-collection-item]:not([data-disabled])"
        }
      );
      if (el)
        return el?.focus();
      if (event.code === "Space")
        return;
      const collectionItems = rovingFocusGroupRef.value?.getItems() ?? [];
      if (isKeyDownInside) {
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && isCharacterKey)
          handleTypeaheadSearch(event.key, collectionItems);
      }
      if (event.target !== contentElement.value)
        return;
      if (!FIRST_LAST_KEYS.includes(event.key))
        return;
      event.preventDefault();
      const candidateNodes = [...collectionItems.map((item) => item.ref)];
      if (LAST_KEYS.includes(event.key))
        candidateNodes.reverse();
      focusFirst$2(candidateNodes);
    }
    function handleBlur(event) {
      if (!event?.currentTarget?.contains?.(event.target)) {
        window.clearTimeout(timerRef.value);
        searchRef.value = "";
      }
    }
    function handlePointerMove(event) {
      if (!isMouseEvent(event))
        return;
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.value !== event.clientX;
      if (event?.currentTarget?.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.value ? "right" : "left";
        pointerDirRef.value = newDir;
        lastPointerXRef.value = event.clientX;
      }
    }
    provideMenuContentContext({
      onItemEnter: (event) => {
        if (isPointerMovingToSubmenu(event))
          return true;
        else
          return false;
      },
      onItemLeave: (event) => {
        if (isPointerMovingToSubmenu(event))
          return;
        contentElement.value?.focus();
        currentItemId.value = null;
      },
      onTriggerLeave: (event) => {
        if (isPointerMovingToSubmenu(event))
          return true;
        else
          return false;
      },
      searchRef,
      pointerGraceTimerRef,
      onPointerGraceIntentChange: (intent) => {
        pointerGraceIntentRef.value = intent;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$_), {
        "as-child": "",
        trapped: unref(trapFocus),
        onMountAutoFocus: handleMountAutoFocus,
        onUnmountAutoFocus: _cache[7] || (_cache[7] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$Z), {
            "as-child": "",
            "disable-outside-pointer-events": unref(disableOutsidePointerEvents),
            onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache[3] || (_cache[3] = ($event) => emits("pointerDownOutside", $event)),
            onFocusOutside: _cache[4] || (_cache[4] = ($event) => emits("focusOutside", $event)),
            onInteractOutside: _cache[5] || (_cache[5] = ($event) => emits("interactOutside", $event)),
            onDismiss: _cache[6] || (_cache[6] = ($event) => emits("dismiss"))
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$X), {
                ref_key: "rovingFocusGroupRef",
                ref: rovingFocusGroupRef,
                "current-tab-stop-id": currentItemId.value,
                "onUpdate:currentTabStopId": _cache[0] || (_cache[0] = ($event) => currentItemId.value = $event),
                "as-child": "",
                orientation: "vertical",
                dir: unref(rootContext).dir.value,
                loop: unref(loop),
                onEntryFocus: _cache[1] || (_cache[1] = (event) => {
                  emits("entryFocus", event);
                  if (!unref(rootContext).isUsingKeyboardRef.value) event.preventDefault();
                })
              }, {
                default: withCtx(() => [
                  createVNode(unref(_sfc_main$T), {
                    ref: unref(forwardRef),
                    role: "menu",
                    as: _ctx.as,
                    "as-child": _ctx.asChild,
                    "aria-orientation": "vertical",
                    "data-reka-menu-content": "",
                    "data-state": unref(getOpenState)(unref(menuContext).open.value),
                    dir: unref(rootContext).dir.value,
                    side: _ctx.side,
                    "side-offset": _ctx.sideOffset,
                    align: _ctx.align,
                    "align-offset": _ctx.alignOffset,
                    "avoid-collisions": _ctx.avoidCollisions,
                    "collision-boundary": _ctx.collisionBoundary,
                    "collision-padding": _ctx.collisionPadding,
                    "arrow-padding": _ctx.arrowPadding,
                    "prioritize-position": _ctx.prioritizePosition,
                    "position-strategy": _ctx.positionStrategy,
                    "update-position-strategy": _ctx.updatePositionStrategy,
                    sticky: _ctx.sticky,
                    "hide-when-detached": _ctx.hideWhenDetached,
                    reference: _ctx.reference,
                    onKeydown: handleKeyDown,
                    onBlur: handleBlur,
                    onPointermove: handlePointerMove
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "position-strategy", "update-position-strategy", "sticky", "hide-when-detached", "reference"])
                ]),
                _: 3
              }, 8, ["current-tab-stop-id", "dir", "loop"])
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const contentContext = injectMenuContentContext();
    const { forwardRef } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isFocused = ref(false);
    async function handlePointerMove(event) {
      if (event.defaultPrevented)
        return;
      if (!isMouseEvent(event))
        return;
      if (props.disabled) {
        contentContext.onItemLeave(event);
      } else {
        const defaultPrevented = contentContext.onItemEnter(event);
        if (!defaultPrevented) {
          const item = event.currentTarget;
          item?.focus({ preventScroll: true });
        }
      }
    }
    async function handlePointerLeave(event) {
      await nextTick();
      if (event.defaultPrevented)
        return;
      if (!isMouseEvent(event))
        return;
      contentContext.onItemLeave(event);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(CollectionItem), {
        value: { textValue: _ctx.textValue }
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), mergeProps({
            ref: unref(forwardRef),
            role: "menuitem",
            tabindex: "-1"
          }, _ctx.$attrs, {
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-disabled": _ctx.disabled || void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            "data-highlighted": isFocused.value ? "" : void 0,
            onPointermove: handlePointerMove,
            onPointerleave: handlePointerLeave,
            onFocus: _cache[0] || (_cache[0] = async (event) => {
              await nextTick();
              if (event.defaultPrevented || _ctx.disabled) return;
              isFocused.value = true;
            }),
            onBlur: _cache[1] || (_cache[1] = async (event) => {
              await nextTick();
              if (event.defaultPrevented) return;
              isFocused.value = false;
            })
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectMenuRootContext();
    const contentContext = injectMenuContentContext();
    const isPointerDownRef = ref(false);
    async function handleSelect() {
      const menuItem = currentElement.value;
      if (!props.disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, {
          bubbles: true,
          cancelable: true
        });
        emits("select", itemSelectEvent);
        await nextTick();
        if (itemSelectEvent.defaultPrevented)
          isPointerDownRef.value = false;
        else rootContext.onClose();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$O, mergeProps(props, {
        ref: unref(forwardRef),
        onClick: handleSelect,
        onPointerdown: _cache[0] || (_cache[0] = () => {
          isPointerDownRef.value = true;
        }),
        onPointerup: _cache[1] || (_cache[1] = async (event) => {
          await nextTick();
          if (event.defaultPrevented) return;
          if (!isPointerDownRef.value) event.currentTarget?.click();
        }),
        onKeydown: _cache[2] || (_cache[2] = async (event) => {
          const isTypingAhead = unref(contentContext).searchRef.value !== "";
          if (_ctx.disabled || isTypingAhead && event.key === " ") return;
          if (unref(SELECTION_KEYS).includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const [injectMenuItemIndicatorContext, provideMenuItemIndicatorContext] = createContext(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
);
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const indicatorContext = injectMenuItemIndicatorContext({
      modelValue: ref(false)
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(isIndeterminate)(unref(indicatorContext).modelValue.value) || unref(indicatorContext).modelValue.value === true
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "data-state": unref(getCheckedState)(unref(indicatorContext).modelValue.value)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child", "data-state"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String], default: false },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const modelValue = useVModel$1(props, "modelValue", emits);
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$N, mergeProps({ role: "menuitemcheckbox" }, props, {
        "aria-checked": unref(isIndeterminate)(unref(modelValue)) ? "mixed" : unref(modelValue),
        "data-state": unref(getCheckedState)(unref(modelValue)),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          if (unref(isIndeterminate)(unref(modelValue))) {
            modelValue.value = true;
          } else {
            modelValue.value = !unref(modelValue);
          }
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })
        ]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const menuContext = injectMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$P, mergeProps(unref(forwarded), {
        ref: unref(forwardRef),
        "trap-focus": unref(menuContext).open.value,
        "disable-outside-pointer-events": unref(menuContext).open.value,
        "disable-outside-scroll": true,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref(menuContext).onOpenChange(false)),
        onFocusOutside: _cache[1] || (_cache[1] = withModifiers(($event) => emits("focusOutside", $event), ["prevent"]))
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus", "disable-outside-pointer-events"]);
    };
  }
});
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const menuContext = injectMenuContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$P, mergeProps(unref(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        "disable-outside-scroll": false,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref(menuContext).onOpenChange(false))
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(menuContext).open.value
      }, {
        default: withCtx(() => [
          unref(rootContext).modal.value ? (openBlock(), createBlock(_sfc_main$K, normalizeProps(mergeProps({ key: 0 }, { ..._ctx.$attrs, ...unref(forwarded) })), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock(), createBlock(_sfc_main$J, normalizeProps(mergeProps({ key: 1 }, { ..._ctx.$attrs, ...unref(forwarded) })), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps({ role: "group" }, props), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Y), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const [injectMenuRadioGroupContext, provideMenuRadioGroupContext] = createContext("MenuRadioGroup");
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const modelValue = useVModel$1(props, "modelValue", emits);
    provideMenuRadioGroupContext({
      modelValue,
      onValueChange: (payload) => {
        modelValue.value = payload;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$H, normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { value } = toRefs(props);
    const radioGroupContext = injectMenuRadioGroupContext();
    const modelValue = computed(
      () => radioGroupContext.modelValue.value === value?.value
    );
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$N, mergeProps({ role: "menuitemradio" }, props, {
        "aria-checked": modelValue.value,
        "data-state": unref(getCheckedState)(modelValue.value),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          unref(radioGroupContext).onValueChange(unref(value));
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
        role: "separator",
        "aria-orientation": "horizontal"
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const [injectMenuSubContext, provideMenuSubContext] = createContext("MenuSub");
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const open = useVModel$1(props, "open", emits, {
      defaultValue: false,
      passive: props.open === void 0
    });
    const parentMenuContext = injectMenuContext();
    const trigger = ref();
    const content = ref();
    watchEffect((cleanupFn) => {
      if (parentMenuContext?.open.value === false)
        open.value = false;
      cleanupFn(() => open.value = false);
    });
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuSubContext({
      triggerId: "",
      contentId: "",
      trigger,
      onTriggerChange: (element) => {
        trigger.value = element;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$W), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean, default: true },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const menuSubContext = injectMenuSubContext();
    const { forwardRef, currentElement: subContentElement } = useForwardExpose();
    menuSubContext.contentId ||= useId(void 0, "reka-menu-sub-content");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(menuContext).open.value
      }, {
        default: withCtx(() => [
          createVNode(_sfc_main$P, mergeProps(unref(forwarded), {
            id: unref(menuSubContext).contentId,
            ref: unref(forwardRef),
            "aria-labelledby": unref(menuSubContext).triggerId,
            align: "start",
            side: unref(rootContext).dir.value === "rtl" ? "left" : "right",
            "disable-outside-pointer-events": false,
            "disable-outside-scroll": false,
            "trap-focus": false,
            onOpenAutoFocus: _cache[0] || (_cache[0] = withModifiers((event) => {
              if (unref(rootContext).isUsingKeyboardRef.value) unref(subContentElement)?.focus();
            }, ["prevent"])),
            onCloseAutoFocus: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["prevent"])),
            onFocusOutside: _cache[2] || (_cache[2] = (event) => {
              if (event.defaultPrevented) return;
              if (event.target !== unref(menuSubContext).trigger.value)
                unref(menuContext).onOpenChange(false);
            }),
            onEscapeKeyDown: _cache[3] || (_cache[3] = (event) => {
              unref(rootContext).onClose();
              event.preventDefault();
            }),
            onKeydown: _cache[4] || (_cache[4] = (event) => {
              const isKeyDownInside = event.currentTarget?.contains(event.target);
              const isCloseKey = unref(SUB_CLOSE_KEYS)[unref(rootContext).dir.value].includes(event.key);
              if (isKeyDownInside && isCloseKey) {
                unref(menuContext).onOpenChange(false);
                unref(menuSubContext).trigger.value?.focus();
                event.preventDefault();
              }
            })
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "aria-labelledby", "side"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "MenuAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$V), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const subContext = injectMenuSubContext();
    const contentContext = injectMenuContentContext();
    const openTimerRef = ref(null);
    subContext.triggerId ||= useId(void 0, "reka-menu-sub-trigger");
    function clearOpenTimer() {
      if (openTimerRef.value)
        window.clearTimeout(openTimerRef.value);
      openTimerRef.value = null;
    }
    onUnmounted(() => {
      clearOpenTimer();
    });
    function handlePointerMove(event) {
      if (!isMouseEvent(event))
        return;
      const defaultPrevented = contentContext.onItemEnter(event);
      if (defaultPrevented)
        return;
      if (!props.disabled && !menuContext.open.value && !openTimerRef.value) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.value = window.setTimeout(() => {
          menuContext.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    }
    async function handlePointerLeave(event) {
      if (!isMouseEvent(event))
        return;
      clearOpenTimer();
      const contentRect = menuContext.content.value?.getBoundingClientRect();
      if (contentRect?.width) {
        const side = menuContext.content.value?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: event.clientX + bleed, y: event.clientY },
            { x: contentNearEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.bottom },
            { x: contentNearEdge, y: contentRect.bottom }
          ],
          side
        });
        window.clearTimeout(contentContext.pointerGraceTimerRef.value);
        contentContext.pointerGraceTimerRef.value = window.setTimeout(
          () => contentContext.onPointerGraceIntentChange(null),
          300
        );
      } else {
        const defaultPrevented = contentContext.onTriggerLeave(event);
        if (defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    }
    async function handleKeyDown(event) {
      const isTypingAhead = contentContext.searchRef.value !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if (SUB_OPEN_KEYS[rootContext.dir.value].includes(event.key)) {
        menuContext.onOpenChange(true);
        await nextTick();
        menuContext.content.value?.focus();
        event.preventDefault();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$z, { "as-child": "" }, {
        default: withCtx(() => [
          createVNode(_sfc_main$O, mergeProps(props, {
            id: unref(subContext).triggerId,
            ref: (vnode) => {
              unref(subContext)?.onTriggerChange(vnode?.$el);
              return void 0;
            },
            "aria-haspopup": "menu",
            "aria-expanded": unref(menuContext).open.value,
            "aria-controls": unref(subContext).contentId,
            "data-state": unref(getOpenState)(unref(menuContext).open.value),
            onClick: _cache[0] || (_cache[0] = async (event) => {
              if (props.disabled || event.defaultPrevented) return;
              event.currentTarget.focus();
              if (!unref(menuContext).open.value) unref(menuContext).onOpenChange(true);
            }),
            onPointermove: handlePointerMove,
            onPointerleave: handlePointerLeave,
            onKeydown: handleKeyDown
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
        ]),
        _: 3
      });
    };
  }
});
const [injectPopoverRootContext, providePopoverRootContext] = createContext("PopoverRoot");
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { modal } = toRefs(props);
    const open = useVModel$1(props, "open", emit, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const triggerElement = ref();
    const hasCustomAnchor = ref(false);
    providePopoverRootContext({
      contentId: "",
      triggerId: "",
      modal,
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerElement,
      hasCustomAnchor
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$W), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "PopoverAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    onBeforeMount(() => {
      rootContext.hasCustomAnchor.value = true;
    });
    onUnmounted(() => {
      rootContext.hasCustomAnchor.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$V), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "PopoverArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$S), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props.asChild,
        onClick: _cache[0] || (_cache[0] = ($event) => unref(rootContext).onOpenChange(false))
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child"]);
    };
  }
});
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Y), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardProps(reactiveOmit(props, "trapFocus", "disableOutsidePointerEvents"));
    const { forwardRef } = useForwardExpose();
    const rootContext = injectPopoverRootContext();
    useFocusGuards();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$_), {
        "as-child": "",
        loop: "",
        trapped: _ctx.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$Z), {
            "as-child": "",
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            onPointerDownOutside: _cache[0] || (_cache[0] = ($event) => emits("pointerDownOutside", $event)),
            onInteractOutside: _cache[1] || (_cache[1] = ($event) => emits("interactOutside", $event)),
            onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
            onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
            onDismiss: _cache[4] || (_cache[4] = ($event) => unref(rootContext).onOpenChange(false))
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$T), mergeProps(unref(forwarded), {
                id: unref(rootContext).contentId,
                ref: unref(forwardRef),
                "data-state": unref(rootContext).open.value ? "open" : "closed",
                "aria-labelledby": unref(rootContext).triggerId,
                style: {
                  "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                  "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                  "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                  "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                  "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
                },
                role: "dialog"
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "aria-labelledby"])
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const isRightClickOutsideRef = ref(false);
    useBodyScrollLock(true);
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$s, mergeProps(unref(forwarded), {
        ref: unref(forwardRef),
        "trap-focus": unref(rootContext).open.value,
        "disable-outside-pointer-events": "",
        onCloseAutoFocus: _cache[0] || (_cache[0] = withModifiers(
          (event) => {
            emits("closeAutoFocus", event);
            if (!isRightClickOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
          },
          ["prevent"]
        )),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          emits("pointerDownOutside", event);
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.value = isRightClick;
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentNonModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const hasInteractedOutsideRef = ref(false);
    const hasPointerDownOutsideRef = ref(false);
    const forwarded = useForwardPropsEmits(props, emits);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$s, mergeProps(unref(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("closeAutoFocus", event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = async (event) => {
          emits("interactOutside", event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.value = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = unref(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) {
            event.preventDefault();
          }
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef } = useForwardExpose();
    rootContext.contentId ||= useId(void 0, "reka-popover-content");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(rootContext).open.value
      }, {
        default: withCtx(() => [
          unref(rootContext).modal.value ? (openBlock(), createBlock(_sfc_main$r, mergeProps({ key: 0 }, unref(forwarded), { ref: unref(forwardRef) }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock(), createBlock(_sfc_main$q, mergeProps({ key: 1 }, unref(forwarded), { ref: unref(forwardRef) }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectPopoverRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    rootContext.triggerId ||= useId(void 0, "reka-popover-trigger");
    onMounted(() => {
      rootContext.triggerElement.value = triggerElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(rootContext).hasCustomAnchor.value ? unref(Primitive) : unref(_sfc_main$V)), { "as-child": "" }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            id: unref(rootContext).triggerId,
            ref: unref(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "aria-haspopup": "dialog",
            "aria-expanded": unref(rootContext).open.value,
            "aria-controls": unref(rootContext).contentId,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            as: _ctx.as,
            "as-child": props.asChild,
            onClick: unref(rootContext).onOpenToggle
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$R), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$L), normalizeProps(guardReactiveProps({ ...props, ...unref(emitsAsProps) })), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const [injectDropdownMenuRootContext, provideDropdownMenuRootContext] = createContext("DropdownMenuRoot");
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel$1(props, "open", emit, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const triggerElement = ref();
    const { modal, dir: propDir } = toRefs(props);
    const dir = useDirection(propDir);
    provideDropdownMenuRootContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerId: "",
      triggerElement,
      contentId: "",
      modal,
      dir
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Q), {
        open: unref(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef(open) ? open.value = $event : null),
        dir: unref(dir),
        modal: unref(modal)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      }, 8, ["open", "dir", "modal"]);
    };
  }
});
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    useForwardExpose();
    const rootContext = injectDropdownMenuRootContext();
    const hasInteractedOutsideRef = ref(false);
    function handleCloseAutoFocus(event) {
      if (event.defaultPrevented)
        return;
      if (!hasInteractedOutsideRef.value) {
        setTimeout(() => {
          rootContext.triggerElement.value?.focus();
        }, 0);
      }
      hasInteractedOutsideRef.value = false;
      event.preventDefault();
    }
    rootContext.contentId ||= useId(void 0, "reka-dropdown-menu-content");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$I), mergeProps(unref(forwarded), {
        id: unref(rootContext).contentId,
        "aria-labelledby": unref(rootContext)?.triggerId,
        style: {
          "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: handleCloseAutoFocus,
        onInteractOutside: _cache[0] || (_cache[0] = (event) => {
          if (event.defaultPrevented) return;
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!unref(rootContext).modal.value || isRightClick) hasInteractedOutsideRef.value = true;
          if (unref(rootContext).triggerElement.value?.contains(event.target)) event.preventDefault();
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
});
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$H), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$N), normalizeProps(guardReactiveProps({ ...props, ...unref(emitsAsProps) })), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$M), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$G), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$F), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$E), normalizeProps(guardReactiveProps({ ...props, ...unref(emitsAsProps) })), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$D), normalizeProps(guardReactiveProps(unref(forwarded))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$C), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const open = useVModel$1(props, "open", emit, {
      passive: props.open === void 0,
      defaultValue: props.defaultOpen ?? false
    });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$B), {
        open: unref(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef(open) ? open.value = $event : null)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
});
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$A), mergeProps(unref(forwarded), { style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$y), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectDropdownMenuRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    onMounted(() => {
      rootContext.triggerElement = triggerElement;
    });
    rootContext.triggerId ||= useId(void 0, "reka-dropdown-menu-trigger");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$z), { "as-child": "" }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            id: unref(rootContext).triggerId,
            ref: unref(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "as-child": props.asChild,
            as: _ctx.as,
            "aria-haspopup": "menu",
            "aria-expanded": unref(rootContext).open.value,
            "aria-controls": unref(rootContext).open.value ? unref(rootContext).contentId : void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            disabled: _ctx.disabled,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            onClick: _cache[0] || (_cache[0] = async (event) => {
              if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
                unref(rootContext)?.onOpenToggle();
                await nextTick();
                if (unref(rootContext).open.value) event.preventDefault();
              }
            }),
            onKeydown: _cache[1] || (_cache[1] = withKeys(
              (event) => {
                if (_ctx.disabled) return;
                if (["Enter", " "].includes(event.key)) unref(rootContext).onOpenToggle();
                if (event.key === "ArrowDown") unref(rootContext).onOpenChange(true);
                if (["Enter", " ", "ArrowDown"].includes(event.key))
                  event.preventDefault();
              },
              ["enter", "space", "arrow-down"]
            ))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$S), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
const [injectHoverCardRootContext, provideHoverCardRootContext] = createContext("HoverCardRoot");
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { openDelay, closeDelay } = toRefs(props);
    useForwardExpose();
    const open = useVModel$1(props, "open", emit, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const openTimerRef = ref(0);
    const closeTimerRef = ref(0);
    const hasSelectionRef = ref(false);
    const isPointerDownOnContentRef = ref(false);
    const isPointerInTransitRef = ref(false);
    const triggerElement = ref();
    function handleOpen() {
      clearTimeout(closeTimerRef.value);
      openTimerRef.value = window.setTimeout(() => open.value = true, openDelay.value);
    }
    function handleClose() {
      clearTimeout(openTimerRef.value);
      if (!hasSelectionRef.value && !isPointerDownOnContentRef.value)
        closeTimerRef.value = window.setTimeout(() => open.value = false, closeDelay.value);
    }
    function handleDismiss() {
      open.value = false;
    }
    provideHoverCardRootContext({
      open,
      onOpenChange(value) {
        open.value = value;
      },
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      isPointerInTransitRef,
      triggerElement
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$W), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      });
    };
  }
});
function useGraceArea(triggerElement, containerElement) {
  const isPointerInTransit = refAutoReset(false, 300);
  const pointerGraceArea = ref(null);
  const pointerExit = createEventHook();
  function handleRemoveGraceArea() {
    pointerGraceArea.value = null;
    isPointerInTransit.value = false;
  }
  function handleCreateGraceArea(event, hoverTarget) {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    pointerGraceArea.value = graceArea;
    isPointerInTransit.value = true;
  }
  watchEffect((cleanupFn) => {
    if (triggerElement.value && containerElement.value) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, containerElement.value);
      const handleContentLeave = (event) => handleCreateGraceArea(event, triggerElement.value);
      triggerElement.value.addEventListener("pointerleave", handleTriggerLeave);
      containerElement.value.addEventListener("pointerleave", handleContentLeave);
      cleanupFn(() => {
        triggerElement.value?.removeEventListener("pointerleave", handleTriggerLeave);
        containerElement.value?.removeEventListener("pointerleave", handleContentLeave);
      });
    }
  });
  watchEffect((cleanupFn) => {
    if (pointerGraceArea.value) {
      const handleTrackPointerGrace = (event) => {
        if (!pointerGraceArea.value || !(event.target instanceof HTMLElement))
          return;
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = triggerElement.value?.contains(target) || containerElement.value?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value);
        const isAnotherGraceAreaTrigger = !!target.closest("[data-grace-area-trigger]");
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {
          handleRemoveGraceArea();
          pointerExit.trigger();
        }
      };
      triggerElement.value?.ownerDocument.addEventListener("pointermove", handleTrackPointerGrace);
      cleanupFn(() => triggerElement.value?.ownerDocument.removeEventListener("pointermove", handleTrackPointerGrace));
    }
  });
  return {
    isPointerInTransit,
    onPointerExit: pointerExit.on
  };
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardProps(props);
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(rootContext.triggerElement, contentElement);
    syncRef(rootContext.isPointerInTransitRef, isPointerInTransit, { direction: "rtl" });
    onPointerExit(() => {
      rootContext.onClose();
    });
    const containSelection = ref(false);
    let originalBodyUserSelect;
    watchEffect((cleanupFn) => {
      if (containSelection.value) {
        const body = document.body;
        originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
        body.style.userSelect = "none";
        body.style.webkitUserSelect = "none";
        cleanupFn(() => {
          body.style.userSelect = originalBodyUserSelect;
          body.style.webkitUserSelect = originalBodyUserSelect;
        });
      }
    });
    function handlePointerUp() {
      containSelection.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
      nextTick(() => {
        const hasSelection = document.getSelection()?.toString() !== "";
        if (hasSelection)
          rootContext.hasSelectionRef.value = true;
      });
    }
    onMounted(() => {
      if (contentElement.value) {
        document.addEventListener("pointerup", handlePointerUp);
        const tabbables = getTabbableNodes(contentElement.value);
        tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
      }
    });
    onUnmounted(() => {
      document.removeEventListener("pointerup", handlePointerUp);
      rootContext.hasSelectionRef.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Z), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
        onFocusOutside: _cache[3] || (_cache[3] = withModifiers(($event) => emits("focusOutside", $event), ["prevent"])),
        onDismiss: unref(rootContext).onDismiss
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$T), mergeProps({ ...unref(forwarded), ..._ctx.$attrs }, {
            ref: unref(forwardRef),
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            style: {
              "userSelect": containSelection.value ? "text" : void 0,
              // Safari requires prefix
              "WebkitUserSelect": containSelection.value ? "text" : void 0,
              // re-namespace exposed content custom properties
              "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
              "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
              "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
              "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
              "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
            },
            onPointerdown: _cache[0] || (_cache[0] = (event) => {
              if (event.currentTarget.contains(event.target)) {
                containSelection.value = true;
              }
              unref(rootContext).hasSelectionRef.value = false;
              unref(rootContext).isPointerDownOnContentRef.value = true;
            })
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["onDismiss"]);
    };
  }
});
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(rootContext).open.value
      }, {
        default: withCtx(() => [
          createVNode(_sfc_main$5, mergeProps(unref(forwarded), {
            ref: unref(forwardRef),
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref(excludeTouch)(unref(rootContext).onOpen)($event))
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Y), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(__props) {
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    rootContext.triggerElement = currentElement;
    function handleLeave() {
      setTimeout(() => {
        if (!rootContext.isPointerInTransitRef.value && !rootContext.open.value) {
          rootContext.onClose();
        }
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$V), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            ref: unref(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            "data-grace-area-trigger": "",
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref(excludeTouch)(unref(rootContext).onOpen)($event)),
            onPointerleave: _cache[1] || (_cache[1] = ($event) => unref(excludeTouch)(handleLeave)($event)),
            onFocus: _cache[2] || (_cache[2] = ($event) => unref(rootContext).onOpen()),
            onBlur: _cache[3] || (_cache[3] = ($event) => unref(rootContext).onClose())
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "data-state"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
// @__NO_SIDE_EFFECTS__
function createReusableTemplate(options = {}) {
  const {
    inheritAttrs = true
  } = options;
  const render2 = shallowRef();
  const define = /* @__PURE__ */ defineComponent({
    setup(_, { slots }) {
      return () => {
        render2.value = slots.default;
      };
    }
  });
  const reuse = /* @__PURE__ */ defineComponent({
    inheritAttrs,
    props: options.props,
    setup(props, { attrs, slots }) {
      return () => {
        var _a;
        if (!render2.value && false)
          ;
        const vnode = (_a = render2.value) == null ? void 0 : _a.call(render2, {
          ...options.props == null ? keysToCamelKebabCase(attrs) : props,
          $slots: slots
        });
        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return makeDestructurable(
    { define, reuse },
    [define, reuse]
  );
}
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj)
    newObj[camelize$1(key)] = obj[key];
  return newObj;
}
const defaultDocument = isClient$1 ? window.document : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue$1(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
// @__NO_SIDE_EFFECTS__
function useVModel(props, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
const portalTargetInjectionKey = Symbol("nuxt-ui.portal-target");
function usePortal(portal) {
  const portalTarget = inject(portalTargetInjectionKey, void 0);
  const to = computed(() => {
    if (typeof portal.value === "boolean" || portal.value === void 0) {
      return portalTarget?.value ?? "body";
    }
    return portal.value;
  });
  const disabled = computed(() => typeof portal.value === "boolean" ? !portal.value : false);
  provide(portalTargetInjectionKey, computed(() => to.value));
  return computed(() => ({
    to: to.value,
    disabled: disabled.value
  }));
}
const DropdownMenu = {
  Root: _sfc_main$l,
  Trigger: _sfc_main$8,
  Portal: _sfc_main$f,
  Content: _sfc_main$k,
  Arrow: _sfc_main$n,
  Item: _sfc_main$i,
  Group: _sfc_main$j,
  Separator: _sfc_main$c,
  CheckboxItem: _sfc_main$m,
  ItemIndicator: _sfc_main$h,
  Label: _sfc_main$g,
  RadioGroup: _sfc_main$e,
  RadioItem: _sfc_main$d,
  Sub: _sfc_main$b,
  SubContent: _sfc_main$a,
  SubTrigger: _sfc_main$9
};
const HoverCard = {
  Root: _sfc_main$6,
  Trigger: _sfc_main$2,
  Portal: _sfc_main$3,
  Content: _sfc_main$4,
  Arrow: _sfc_main$7
};
const Popover = {
  Root: _sfc_main$x,
  Trigger: _sfc_main$o,
  Portal: _sfc_main$t,
  Content: _sfc_main$p,
  Arrow: _sfc_main$v,
  Close: _sfc_main$u,
  Anchor: _sfc_main$w
};
const theme = {
  "slots": {
    "root": "w-full",
    "item": "border-b border-default last:border-b-0",
    "header": "flex",
    "trigger": "group flex-1 flex items-center gap-1.5 font-medium text-sm py-3.5 focus-visible:outline-primary min-w-0",
    "content": "data-[state=open]:animate-[accordion-down_200ms_ease-out] data-[state=closed]:animate-[accordion-up_200ms_ease-out] overflow-hidden focus:outline-none",
    "body": "text-sm pb-3.5",
    "leadingIcon": "shrink-0 size-5",
    "trailingIcon": "shrink-0 size-5 ms-auto group-data-[state=open]:rotate-180 transition-transform duration-200",
    "label": "text-start break-words"
  },
  "variants": {
    "disabled": {
      "true": {
        "trigger": "cursor-not-allowed opacity-75"
      }
    }
  }
};
const _sfc_main$1 = {
  __name: "Accordion",
  props: {
    as: { type: null, required: false },
    items: { type: Array, required: false },
    trailingIcon: { type: String, required: false },
    labelKey: { type: String, required: false, default: "label" },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    collapsible: { type: Boolean, required: false, default: true },
    defaultValue: { type: null, required: false },
    modelValue: { type: null, required: false },
    type: { type: String, required: false, default: "single" },
    disabled: { type: Boolean, required: false },
    unmountOnHide: { type: Boolean, required: false, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const appConfig = useAppConfig();
    const rootProps = useForwardPropsEmits(reactivePick(props, "as", "collapsible", "defaultValue", "disabled", "modelValue", "type", "unmountOnHide"), emits);
    const ui = computed(() => tv({ extend: tv(theme), ...appConfig.ui?.accordion || {} })({
      disabled: props.disabled
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$16), mergeProps(unref(rootProps), {
        class: ui.value.root({ class: [props.ui?.root, props.class] })
      }), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(props.items, (item, index) => {
            return openBlock(), createBlock(unref(_sfc_main$14), {
              key: index,
              value: item.value || String(index),
              disabled: item.disabled,
              class: normalizeClass(ui.value.item({ class: [props.ui?.item, item.ui?.item, item.class] }))
            }, {
              default: withCtx(({ open }) => [
                createVNode(unref(_sfc_main$11), {
                  as: "div",
                  class: normalizeClass(ui.value.header({ class: [props.ui?.header, item.ui?.header] }))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$$), {
                      class: normalizeClass(ui.value.trigger({ class: [props.ui?.trigger, item.ui?.trigger], disabled: item.disabled }))
                    }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "leading", {
                          item,
                          index,
                          open
                        }, () => [
                          item.icon ? (openBlock(), createBlock(_sfc_main$19, {
                            key: 0,
                            name: item.icon,
                            class: normalizeClass(ui.value.leadingIcon({ class: [props.ui?.leadingIcon, item?.ui?.leadingIcon] }))
                          }, null, 8, ["name", "class"])) : createCommentVNode("", true)
                        ]),
                        unref(get)(item, props.labelKey) || !!slots.default ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(ui.value.label({ class: [props.ui?.label, item.ui?.label] }))
                        }, [
                          renderSlot(_ctx.$slots, "default", {
                            item,
                            index,
                            open
                          }, () => [
                            createTextVNode(toDisplayString(unref(get)(item, props.labelKey)), 1)
                          ])
                        ], 2)) : createCommentVNode("", true),
                        renderSlot(_ctx.$slots, "trailing", {
                          item,
                          index,
                          open
                        }, () => [
                          createVNode(_sfc_main$19, {
                            name: item.trailingIcon || __props.trailingIcon || unref(appConfig).ui.icons.chevronDown,
                            class: normalizeClass(ui.value.trailingIcon({ class: [props.ui?.trailingIcon, item.ui?.trailingIcon] }))
                          }, null, 8, ["name", "class"])
                        ])
                      ]),
                      _: 2
                    }, 1032, ["class"])
                  ]),
                  _: 2
                }, 1032, ["class"]),
                item.content || !!slots.content || item.slot && !!slots[item.slot] || !!slots.body || item.slot && !!slots[`${item.slot}-body`] ? (openBlock(), createBlock(unref(_sfc_main$12), {
                  key: 0,
                  class: normalizeClass(ui.value.content({ class: [props.ui?.content, item.ui?.content] }))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, item.slot || "content", {
                      item,
                      index,
                      open
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(ui.value.body({ class: [props.ui?.body, item.ui?.body] }))
                      }, [
                        renderSlot(_ctx.$slots, item.slot ? `${item.slot}-body` : "body", {
                          item,
                          index,
                          open
                        }, () => [
                          createTextVNode(toDisplayString(item.content), 1)
                        ])
                      ], 2)
                    ])
                  ]),
                  _: 2
                }, 1032, ["class"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["value", "disabled", "class"]);
          }), 128))
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
};
const _hoisted_1 = ["aria-label"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "MeIcon",
  props: {
    color: { default: "", type: String },
    hoverColor: { default: "", type: String },
    hoverIcon: { default: "", type: String },
    icon: { default: "", type: String },
    name: { default: "", type: String },
    type: { default: "regular", type: String },
    variant: { default: "", type: String },
    size: { default: "", type: [Number, String] },
    customSize: { default: void 0, type: Number },
    ariaLabel: { default: void 0, type: String }
  },
  setup(__props) {
    const iconTypes = {
      regular: "me-icon",
      solid: "me-icon-s",
      light: "me-icon-l",
      thin: "me-icon-t"
    };
    const variants = ["primary", "success", "danger", "warning"];
    const props = __props;
    const isHover = ref(false);
    const iconStyle = computed(() => {
      const styles = {};
      if (isHover.value && props.hoverColor) {
        styles.color = props.hoverColor;
      } else if (props.color) {
        styles.color = props.color;
      }
      if (props.customSize) {
        const sizeInPx = `${props.customSize}px`;
        styles.width = sizeInPx;
        styles.height = sizeInPx;
        styles.fontSize = sizeInPx;
      } else if (props.size) {
        styles.fontSize = typeof props.size === "number" ? `${props.size}px` : props.size;
      }
      return styles;
    });
    const variantClass = computed(() => {
      return props.variant && variants.includes(props.variant) ? `icon-${props.variant}` : "";
    });
    const variantClasses = computed(() => {
      if (!props.variant) return "";
      const variantMap = {
        primary: "text-blue-600",
        success: "text-green-600",
        warning: "text-yellow-600",
        danger: "text-red-600"
      };
      return variantMap[props.variant] || "";
    });
    const hoverClasses = computed(() => {
      if (!isHover.value) return "";
      if (props.hoverIcon) {
        return "transition-all duration-200";
      }
      if (props.hoverColor) {
        return "transition-colors duration-200";
      }
      return "";
    });
    const currentIcon = computed(() => {
      if (isHover.value && props.hoverIcon) {
        return props.hoverIcon;
      }
      if (props.icon) {
        return props.icon;
      }
      if (props.name) {
        return [iconTypes[props.type], `icon-${props.name}`];
      }
      return [];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", {
        class: normalizeClass([
          currentIcon.value,
          variantClass.value,
          "inline-flex items-center justify-center",
          variantClasses.value,
          hoverClasses.value
        ]),
        style: normalizeStyle(iconStyle.value),
        "aria-label": _ctx.ariaLabel,
        role: "img",
        "data-cy": "icon-element",
        onMouseenter: _cache[0] || (_cache[0] = ($event) => isHover.value = true),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => isHover.value = false)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_1);
    };
  }
});
const meIconStyles = `/*!
 * ME Font Library - version 3.5.8
 * 2025 Mercado Eletrônico
 */

.me-icon,.me-icon-b,.me-icon-l,.me-icon-s,.me-icon-t{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto}.icon-address-book:before{content:"\\f101"}.icon-address-card:before{content:"\\f102"}.icon-adjust:before{content:"\\f103"}.icon-alarm-clock:before{content:"\\f104"}.icon-alarm-exclamation:before{content:"\\f105"}.icon-alarm-plus:before{content:"\\f106"}.icon-align-center:before{content:"\\f107"}.icon-align-justify:before{content:"\\f108"}.icon-align-left:before{content:"\\f109"}.icon-align-right:before{content:"\\f10a"}.icon-align-slash:before{content:"\\f10b"}.icon-analytics:before{content:"\\f10c"}.icon-angle-double-down:before{content:"\\f10d"}.icon-angle-double-left:before{content:"\\f10e"}.icon-angle-double-right:before{content:"\\f10f"}.icon-angle-double-up:before{content:"\\f110"}.icon-angle-down:before{content:"\\f111"}.icon-angle-left:before{content:"\\f112"}.icon-angle-right:before{content:"\\f113"}.icon-angle-up:before{content:"\\f114"}.icon-angles-down:before{content:"\\f115"}.icon-angles-left:before{content:"\\f116"}.icon-angles-right:before{content:"\\f117"}.icon-angles-up:before{content:"\\f118"}.icon-apps:before{content:"\\f119"}.icon-archive:before{content:"\\f11a"}.icon-arrow-alt-circle-down:before{content:"\\f11b"}.icon-arrow-alt-circle-left:before{content:"\\f11c"}.icon-arrow-alt-circle-right:before{content:"\\f11d"}.icon-arrow-alt-circle-up:before{content:"\\f11e"}.icon-arrow-alt-down:before{content:"\\f11f"}.icon-arrow-alt-from-bottom:before{content:"\\f120"}.icon-arrow-alt-from-left:before{content:"\\f121"}.icon-arrow-alt-from-right:before{content:"\\f122"}.icon-arrow-alt-from-top:before{content:"\\f123"}.icon-arrow-alt-left:before{content:"\\f124"}.icon-arrow-alt-right:before{content:"\\f125"}.icon-arrow-alt-square-down:before{content:"\\f126"}.icon-arrow-alt-square-left:before{content:"\\f127"}.icon-arrow-alt-square-right:before{content:"\\f128"}.icon-arrow-alt-square-up:before{content:"\\f129"}.icon-arrow-alt-to-bottom:before{content:"\\f12a"}.icon-arrow-alt-to-left:before{content:"\\f12b"}.icon-arrow-alt-to-right:before{content:"\\f12c"}.icon-arrow-alt-to-top:before{content:"\\f12d"}.icon-arrow-alt-up:before{content:"\\f12e"}.icon-arrow-circle-down:before{content:"\\f12f"}.icon-arrow-circle-left:before{content:"\\f130"}.icon-arrow-circle-right:before{content:"\\f131"}.icon-arrow-circle-up:before{content:"\\f132"}.icon-arrow-down-1-9:before{content:"\\f133"}.icon-arrow-down-9-1:before{content:"\\f134"}.icon-arrow-down-a-z:before{content:"\\f135"}.icon-arrow-down-arrow-up:before{content:"\\f136"}.icon-arrow-down-big-small:before{content:"\\f137"}.icon-arrow-down-from-dotted-line:before{content:"\\f138"}.icon-arrow-down-from-line:before{content:"\\f139"}.icon-arrow-down-left-and-arrow-up-right-to-center:before{content:"\\f13a"}.icon-arrow-down-left:before{content:"\\f13b"}.icon-arrow-down-long:before{content:"\\f13c"}.icon-arrow-down-right:before{content:"\\f13d"}.icon-arrow-down-short-wide:before{content:"\\f13e"}.icon-arrow-down-small-big:before{content:"\\f13f"}.icon-arrow-down-square-triangle:before{content:"\\f140"}.icon-arrow-down-to-arc:before{content:"\\f141"}.icon-arrow-down-to-bracket:before{content:"\\f142"}.icon-arrow-down-to-dotted-line:before{content:"\\f143"}.icon-arrow-down-to-line:before{content:"\\f144"}.icon-arrow-down-to-square:before{content:"\\f145"}.icon-arrow-down-triangle-square:before{content:"\\f146"}.icon-arrow-down-up-across-line:before{content:"\\f147"}.icon-arrow-down-up-lock:before{content:"\\f148"}.icon-arrow-down-wide-short:before{content:"\\f149"}.icon-arrow-down-z-a:before{content:"\\f14a"}.icon-arrow-down:before{content:"\\f14b"}.icon-arrow-from-bottom:before{content:"\\f14c"}.icon-arrow-from-left:before{content:"\\f14d"}.icon-arrow-from-right:before{content:"\\f14e"}.icon-arrow-from-top:before{content:"\\f14f"}.icon-arrow-left-from-line:before{content:"\\f150"}.icon-arrow-left-long-to-line:before{content:"\\f151"}.icon-arrow-left-long:before{content:"\\f152"}.icon-arrow-left-to-line:before{content:"\\f153"}.icon-arrow-left:before{content:"\\f154"}.icon-arrow-pointer:before{content:"\\f155"}.icon-arrow-right-arrow-left:before{content:"\\f156"}.icon-arrow-right-from-arc:before{content:"\\f157"}.icon-arrow-right-from-bracket:before{content:"\\f158"}.icon-arrow-right-from-line:before{content:"\\f159"}.icon-arrow-right-long-to-line:before{content:"\\f15a"}.icon-arrow-right-long:before{content:"\\f15b"}.icon-arrow-right-to-arc:before{content:"\\f15c"}.icon-arrow-right-to-bracket:before{content:"\\f15d"}.icon-arrow-right-to-line:before{content:"\\f15e"}.icon-arrow-right:before{content:"\\f15f"}.icon-arrow-rotate-left:before{content:"\\f160"}.icon-arrow-rotate-right:before{content:"\\f161"}.icon-arrow-square-down:before{content:"\\f162"}.icon-arrow-square-left:before{content:"\\f163"}.icon-arrow-square-right:before{content:"\\f164"}.icon-arrow-square-up:before{content:"\\f165"}.icon-arrow-to-bottom:before{content:"\\f166"}.icon-arrow-to-left:before{content:"\\f167"}.icon-arrow-to-right:before{content:"\\f168"}.icon-arrow-to-top:before{content:"\\f169"}.icon-arrow-trend-down:before{content:"\\f16a"}.icon-arrow-trend-up:before{content:"\\f16b"}.icon-arrow-turn-down-left:before{content:"\\f16c"}.icon-arrow-turn-down-right:before{content:"\\f16d"}.icon-arrow-turn-down:before{content:"\\f16e"}.icon-arrow-turn-up:before{content:"\\f16f"}.icon-arrow-up-1-9:before{content:"\\f170"}.icon-arrow-up-9-1:before{content:"\\f171"}.icon-arrow-up-a-z:before{content:"\\f172"}.icon-arrow-up-arrow-down:before{content:"\\f173"}.icon-arrow-up-big-small:before{content:"\\f174"}.icon-arrow-up-from-arc:before{content:"\\f175"}.icon-arrow-up-from-bracket:before{content:"\\f176"}.icon-arrow-up-from-dotted-line:before{content:"\\f177"}.icon-arrow-up-from-ground-water:before{content:"\\f178"}.icon-arrow-up-from-line:before{content:"\\f179"}.icon-arrow-up-from-square:before{content:"\\f17a"}.icon-arrow-up-from-water-pump:before{content:"\\f17b"}.icon-arrow-up-left-from-circle:before{content:"\\f17c"}.icon-arrow-up-left:before{content:"\\f17d"}.icon-arrow-up-long:before{content:"\\f17e"}.icon-arrow-up-right-and-arrow-down-left-from-center:before{content:"\\f17f"}.icon-arrow-up-right-dots:before{content:"\\f180"}.icon-arrow-up-right-from-square:before{content:"\\f181"}.icon-arrow-up-right:before{content:"\\f182"}.icon-arrow-up-short-wide:before{content:"\\f183"}.icon-arrow-up-small-big:before{content:"\\f184"}.icon-arrow-up-square-triangle:before{content:"\\f185"}.icon-arrow-up-to-dotted-line:before{content:"\\f186"}.icon-arrow-up-to-line:before{content:"\\f187"}.icon-arrow-up-triangle-square:before{content:"\\f188"}.icon-arrow-up-wide-short:before{content:"\\f189"}.icon-arrow-up-z-a:before{content:"\\f18a"}.icon-arrow-up:before{content:"\\f18b"}.icon-arrows-alt-h:before{content:"\\f18c"}.icon-arrows-alt-v:before{content:"\\f18d"}.icon-arrows-alt:before{content:"\\f18e"}.icon-arrows-cross:before{content:"\\f18f"}.icon-arrows-down-to-line:before{content:"\\f190"}.icon-arrows-down-to-people:before{content:"\\f191"}.icon-arrows-from-dotted-line:before{content:"\\f192"}.icon-arrows-from-line:before{content:"\\f193"}.icon-arrows-h:before{content:"\\f194"}.icon-arrows-left-right-to-line:before{content:"\\f195"}.icon-arrows-left-right:before{content:"\\f196"}.icon-arrows-maximize:before{content:"\\f197"}.icon-arrows-minimize:before{content:"\\f198"}.icon-arrows-repeat-1:before{content:"\\f199"}.icon-arrows-repeat:before{content:"\\f19a"}.icon-arrows-retweet:before{content:"\\f19b"}.icon-arrows-rotate:before{content:"\\f19c"}.icon-arrows-spin:before{content:"\\f19d"}.icon-arrows-split-up-and-left:before{content:"\\f19e"}.icon-arrows-to-circle:before{content:"\\f19f"}.icon-arrows-to-dot:before{content:"\\f1a0"}.icon-arrows-to-dotted-line:before{content:"\\f1a1"}.icon-arrows-to-line:before{content:"\\f1a2"}.icon-arrows-turn-right:before{content:"\\f1a3"}.icon-arrows-turn-to-dots:before{content:"\\f1a4"}.icon-arrows-up-down-left-right:before{content:"\\f1a5"}.icon-arrows-up-down:before{content:"\\f1a6"}.icon-arrows-up-to-line:before{content:"\\f1a7"}.icon-arrows-v:before{content:"\\f1a8"}.icon-arrows:before{content:"\\f1a9"}.icon-asterisk:before{content:"\\f1aa"}.icon-at:before{content:"\\f1ab"}.icon-atlas:before{content:"\\f1ac"}.icon-award-simple:before{content:"\\f1ad"}.icon-award:before{content:"\\f1ae"}.icon-backpack:before{content:"\\f1af"}.icon-backspace:before{content:"\\f1b0"}.icon-backward-fast:before{content:"\\f1b1"}.icon-backward-step:before{content:"\\f1b2"}.icon-backward:before{content:"\\f1b3"}.icon-badge-check:before{content:"\\f1b4"}.icon-badge-dollar:before{content:"\\f1b5"}.icon-badge-percent:before{content:"\\f1b6"}.icon-badge:before{content:"\\f1b7"}.icon-bag-shopping:before{content:"\\f1b8"}.icon-bags-shopping:before{content:"\\f1b9"}.icon-ballot-check:before{content:"\\f1ba"}.icon-ballot:before{content:"\\f1bb"}.icon-ban:before{content:"\\f1bc"}.icon-bars-filter:before{content:"\\f1bd"}.icon-bars-progress:before{content:"\\f1be"}.icon-bars-sort:before{content:"\\f1bf"}.icon-bars-staggered:before{content:"\\f1c0"}.icon-bars:before{content:"\\f1c1"}.icon-basket-shopping-simple:before{content:"\\f1c2"}.icon-basket-shopping:before{content:"\\f1c3"}.icon-battery-bolt:before{content:"\\f1c4"}.icon-battery-empty:before{content:"\\f1c5"}.icon-battery-exclamation:before{content:"\\f1c6"}.icon-battery-full:before{content:"\\f1c7"}.icon-battery-half:before{content:"\\f1c8"}.icon-battery-low:before{content:"\\f1c9"}.icon-battery-quarter:before{content:"\\f1ca"}.icon-battery-slash:before{content:"\\f1cb"}.icon-battery-three-quarters:before{content:"\\f1cc"}.icon-bell-exclamation:before{content:"\\f1cd"}.icon-bell-on:before{content:"\\f1ce"}.icon-bell-plus:before{content:"\\f1cf"}.icon-bell-slash:before{content:"\\f1d0"}.icon-bell:before{content:"\\f1d1"}.icon-bells:before{content:"\\f1d2"}.icon-bezier-curve:before{content:"\\f1d3"}.icon-binary-circle-check:before{content:"\\f1d4"}.icon-binary-lock:before{content:"\\f1d5"}.icon-binary-slash:before{content:"\\f1d6"}.icon-binary:before{content:"\\f1d7"}.icon-board:before{content:"\\f1d8"}.icon-bold:before{content:"\\f1d9"}.icon-book-alt:before{content:"\\f1da"}.icon-book-arrow-right:before{content:"\\f1db"}.icon-book-arrow-up:before{content:"\\f1dc"}.icon-book-atlas:before{content:"\\f1dd"}.icon-book-blank:before{content:"\\f1de"}.icon-book-bookmark:before{content:"\\f1df"}.icon-book-circle-arrow-right:before{content:"\\f1e0"}.icon-book-circle-arrow-up:before{content:"\\f1e1"}.icon-book-copy:before{content:"\\f1e2"}.icon-book-font:before{content:"\\f1e3"}.icon-book-open-cover:before{content:"\\f1e4"}.icon-book-open-reader:before{content:"\\f1e5"}.icon-book-open:before{content:"\\f1e6"}.icon-book-reader:before{content:"\\f1e7"}.icon-book-section:before{content:"\\f1e8"}.icon-book-user:before{content:"\\f1e9"}.icon-book:before{content:"\\f1ea"}.icon-bookmark-slash:before{content:"\\f1eb"}.icon-bookmark:before{content:"\\f1ec"}.icon-books:before{content:"\\f1ed"}.icon-border-all:before{content:"\\f1ee"}.icon-border-bottom-right:before{content:"\\f1ef"}.icon-border-bottom:before{content:"\\f1f0"}.icon-border-center-h:before{content:"\\f1f1"}.icon-border-center-v:before{content:"\\f1f2"}.icon-border-inner:before{content:"\\f1f3"}.icon-border-left:before{content:"\\f1f4"}.icon-border-none:before{content:"\\f1f5"}.icon-border-outer:before{content:"\\f1f6"}.icon-border-right:before{content:"\\f1f7"}.icon-border-style-alt:before{content:"\\f1f8"}.icon-border-style:before{content:"\\f1f9"}.icon-border-top-left:before{content:"\\f1fa"}.icon-border-top:before{content:"\\f1fb"}.icon-box-alt:before{content:"\\f1fc"}.icon-box-archive:before{content:"\\f1fd"}.icon-box-ballot:before{content:"\\f1fe"}.icon-box-check:before{content:"\\f1ff"}.icon-box-circle-check:before{content:"\\f200"}.icon-box-dollar:before{content:"\\f201"}.icon-box-full:before{content:"\\f202"}.icon-box-open-full:before{content:"\\f203"}.icon-box-open:before{content:"\\f204"}.icon-box-taped:before{content:"\\f205"}.icon-box-tissue:before{content:"\\f206"}.icon-box-up:before{content:"\\f207"}.icon-box-usd:before{content:"\\f208"}.icon-box:before{content:"\\f209"}.icon-boxes-alt:before{content:"\\f20a"}.icon-boxes-packing:before{content:"\\f20b"}.icon-boxes-stacked:before{content:"\\f20c"}.icon-boxes:before{content:"\\f20d"}.icon-bracket-curly-right:before{content:"\\f20e"}.icon-bracket-curly:before{content:"\\f20f"}.icon-bracket-round-right:before{content:"\\f210"}.icon-bracket-round:before{content:"\\f211"}.icon-bracket-square-right:before{content:"\\f212"}.icon-bracket-square:before{content:"\\f213"}.icon-brackets-curly:before{content:"\\f214"}.icon-brackets-round:before{content:"\\f215"}.icon-brackets-square:before{content:"\\f216"}.icon-brackets:before{content:"\\f217"}.icon-brake-warning:before{content:"\\f218"}.icon-briefcase-arrow-right:before{content:"\\f219"}.icon-briefcase-blank:before{content:"\\f21a"}.icon-briefcase-medical:before{content:"\\f21b"}.icon-briefcase:before{content:"\\f21c"}.icon-brightness-low:before{content:"\\f21d"}.icon-brightness:before{content:"\\f21e"}.icon-bring-forward:before{content:"\\f21f"}.icon-bring-front:before{content:"\\f220"}.icon-broadcast-tower:before{content:"\\f221"}.icon-broom-ball:before{content:"\\f222"}.icon-broom:before{content:"\\f223"}.icon-browser:before{content:"\\f224"}.icon-browsers:before{content:"\\f225"}.icon-bucket:before{content:"\\f226"}.icon-building-circle-arrow-right:before{content:"\\f227"}.icon-building-circle-check:before{content:"\\f228"}.icon-building-circle-exclamation:before{content:"\\f229"}.icon-building-circle-xmark:before{content:"\\f22a"}.icon-building-columns:before{content:"\\f22b"}.icon-building-flag:before{content:"\\f22c"}.icon-building-lock:before{content:"\\f22d"}.icon-building-shield:before{content:"\\f22e"}.icon-building-user:before{content:"\\f22f"}.icon-building:before{content:"\\f230"}.icon-buildings:before{content:"\\f231"}.icon-bullhorn:before{content:"\\f232"}.icon-bullseye-arrow:before{content:"\\f233"}.icon-bullseye-pointer:before{content:"\\f234"}.icon-bullseye:before{content:"\\f235"}.icon-business-time:before{content:"\\f236"}.icon-cabinet-filing:before{content:"\\f237"}.icon-cake-candles:before{content:"\\f238"}.icon-calculator-alt:before{content:"\\f239"}.icon-calculator-simple:before{content:"\\f23a"}.icon-calculator:before{content:"\\f23b"}.icon-calendar-alt:before{content:"\\f23c"}.icon-calendar-arrow-down:before{content:"\\f23d"}.icon-calendar-arrow-up:before{content:"\\f23e"}.icon-calendar-check:before{content:"\\f23f"}.icon-calendar-circle-exclamation:before{content:"\\f240"}.icon-calendar-circle-minus:before{content:"\\f241"}.icon-calendar-circle-plus:before{content:"\\f242"}.icon-calendar-circle-user:before{content:"\\f243"}.icon-calendar-clock:before{content:"\\f244"}.icon-calendar-day:before{content:"\\f245"}.icon-calendar-days:before{content:"\\f246"}.icon-calendar-edit:before{content:"\\f247"}.icon-calendar-exclamation:before{content:"\\f248"}.icon-calendar-heart:before{content:"\\f249"}.icon-calendar-image:before{content:"\\f24a"}.icon-calendar-lines-pen:before{content:"\\f24b"}.icon-calendar-lines:before{content:"\\f24c"}.icon-calendar-minus:before{content:"\\f24d"}.icon-calendar-pen:before{content:"\\f24e"}.icon-calendar-plus:before{content:"\\f24f"}.icon-calendar-range:before{content:"\\f250"}.icon-calendar-star:before{content:"\\f251"}.icon-calendar-times:before{content:"\\f252"}.icon-calendar-week:before{content:"\\f253"}.icon-calendar-xmark:before{content:"\\f254"}.icon-calendar:before{content:"\\f255"}.icon-calendars:before{content:"\\f256"}.icon-camera-alt:before{content:"\\f257"}.icon-camera-retro:before{content:"\\f258"}.icon-camera-rotate:before{content:"\\f259"}.icon-camera-slash:before{content:"\\f25a"}.icon-camera-viewfinder:before{content:"\\f25b"}.icon-camera-web-slash:before{content:"\\f25c"}.icon-camera-web:before{content:"\\f25d"}.icon-camera:before{content:"\\f25e"}.icon-cards-blank:before{content:"\\f25f"}.icon-caret-circle-down:before{content:"\\f260"}.icon-caret-circle-left:before{content:"\\f261"}.icon-caret-circle-right:before{content:"\\f262"}.icon-caret-circle-up:before{content:"\\f263"}.icon-caret-down:before{content:"\\f264"}.icon-caret-left:before{content:"\\f265"}.icon-caret-right:before{content:"\\f266"}.icon-caret-square-down:before{content:"\\f267"}.icon-caret-square-left:before{content:"\\f268"}.icon-caret-square-right:before{content:"\\f269"}.icon-caret-square-up:before{content:"\\f26a"}.icon-caret-up:before{content:"\\f26b"}.icon-cart-arrow-down:before{content:"\\f26c"}.icon-cart-arrow-up:before{content:"\\f26d"}.icon-cart-circle-arrow-down:before{content:"\\f26e"}.icon-cart-circle-arrow-up:before{content:"\\f26f"}.icon-cart-circle-check:before{content:"\\f270"}.icon-cart-circle-exclamation:before{content:"\\f271"}.icon-cart-circle-plus:before{content:"\\f272"}.icon-cart-circle-xmark:before{content:"\\f273"}.icon-cart-flatbed-boxes:before{content:"\\f274"}.icon-cart-flatbed-empty:before{content:"\\f275"}.icon-cart-flatbed-suitcase:before{content:"\\f276"}.icon-cart-flatbed:before{content:"\\f277"}.icon-cart-minus:before{content:"\\f278"}.icon-cart-plus:before{content:"\\f279"}.icon-cart-shopping-fast:before{content:"\\f27a"}.icon-cart-shopping:before{content:"\\f27b"}.icon-cart-xmark:before{content:"\\f27c"}.icon-certificate:before{content:"\\f27d"}.icon-chalkboard-teacher:before{content:"\\f27e"}.icon-chalkboard-user:before{content:"\\f27f"}.icon-chalkboard:before{content:"\\f280"}.icon-chart-area:before{content:"\\f281"}.icon-chart-bar:before{content:"\\f282"}.icon-chart-bullet:before{content:"\\f283"}.icon-chart-candlestick:before{content:"\\f284"}.icon-chart-column:before{content:"\\f285"}.icon-chart-gantt:before{content:"\\f286"}.icon-chart-line-down:before{content:"\\f287"}.icon-chart-line-up:before{content:"\\f288"}.icon-chart-line:before{content:"\\f289"}.icon-chart-mixed:before{content:"\\f28a"}.icon-chart-network:before{content:"\\f28b"}.icon-chart-pie-alt:before{content:"\\f28c"}.icon-chart-pie-simple:before{content:"\\f28d"}.icon-chart-pie:before{content:"\\f28e"}.icon-chart-pyramid:before{content:"\\f28f"}.icon-chart-radar:before{content:"\\f290"}.icon-chart-scatter-3d:before{content:"\\f291"}.icon-chart-scatter-bubble:before{content:"\\f292"}.icon-chart-scatter:before{content:"\\f293"}.icon-chart-simple-horizontal:before{content:"\\f294"}.icon-chart-simple:before{content:"\\f295"}.icon-chart-tree-map:before{content:"\\f296"}.icon-chart-user:before{content:"\\f297"}.icon-chart-waterfall:before{content:"\\f298"}.icon-check-circle:before{content:"\\f299"}.icon-check-double:before{content:"\\f29a"}.icon-check-square:before{content:"\\f29b"}.icon-check-to-slot:before{content:"\\f29c"}.icon-check:before{content:"\\f29d"}.icon-chevron-circle-down:before{content:"\\f29e"}.icon-chevron-circle-left:before{content:"\\f29f"}.icon-chevron-circle-right:before{content:"\\f2a0"}.icon-chevron-circle-up:before{content:"\\f2a1"}.icon-chevron-double-down:before{content:"\\f2a2"}.icon-chevron-double-left:before{content:"\\f2a3"}.icon-chevron-double-right:before{content:"\\f2a4"}.icon-chevron-double-up:before{content:"\\f2a5"}.icon-chevron-down:before{content:"\\f2a6"}.icon-chevron-left:before{content:"\\f2a7"}.icon-chevron-right:before{content:"\\f2a8"}.icon-chevron-square-down:before{content:"\\f2a9"}.icon-chevron-square-left:before{content:"\\f2aa"}.icon-chevron-square-right:before{content:"\\f2ab"}.icon-chevron-square-up:before{content:"\\f2ac"}.icon-chevron-up:before{content:"\\f2ad"}.icon-chevrons-down:before{content:"\\f2ae"}.icon-chevrons-left:before{content:"\\f2af"}.icon-chevrons-right:before{content:"\\f2b0"}.icon-chevrons-up:before{content:"\\f2b1"}.icon-circle-arrow-down-left:before{content:"\\f2b2"}.icon-circle-arrow-down-right:before{content:"\\f2b3"}.icon-circle-arrow-down:before{content:"\\f2b4"}.icon-circle-arrow-left:before{content:"\\f2b5"}.icon-circle-arrow-right:before{content:"\\f2b6"}.icon-circle-arrow-up-left:before{content:"\\f2b7"}.icon-circle-arrow-up-right:before{content:"\\f2b8"}.icon-circle-arrow-up:before{content:"\\f2b9"}.icon-circle-bolt:before{content:"\\f2ba"}.icon-circle-book-open:before{content:"\\f2bb"}.icon-circle-bookmark:before{content:"\\f2bc"}.icon-circle-calendar:before{content:"\\f2bd"}.icon-circle-camera:before{content:"\\f2be"}.icon-circle-caret-down:before{content:"\\f2bf"}.icon-circle-caret-left:before{content:"\\f2c0"}.icon-circle-caret-right:before{content:"\\f2c1"}.icon-circle-caret-up:before{content:"\\f2c2"}.icon-circle-check:before{content:"\\f2c3"}.icon-circle-chevron-down:before{content:"\\f2c4"}.icon-circle-chevron-left:before{content:"\\f2c5"}.icon-circle-chevron-right:before{content:"\\f2c6"}.icon-circle-chevron-up:before{content:"\\f2c7"}.icon-circle-dashed:before{content:"\\f2c8"}.icon-circle-divide:before{content:"\\f2c9"}.icon-circle-dollar-to-slot:before{content:"\\f2ca"}.icon-circle-dollar:before{content:"\\f2cb"}.icon-circle-dot:before{content:"\\f2cc"}.icon-circle-down-left:before{content:"\\f2cd"}.icon-circle-down-right:before{content:"\\f2ce"}.icon-circle-down:before{content:"\\f2cf"}.icon-circle-ellipsis-vertical:before{content:"\\f2d0"}.icon-circle-ellipsis:before{content:"\\f2d1"}.icon-circle-envelope:before{content:"\\f2d2"}.icon-circle-exclamation-check:before{content:"\\f2d3"}.icon-circle-exclamation:before{content:"\\f2d4"}.icon-circle-half-stroke:before{content:"\\f2d5"}.icon-circle-half:before{content:"\\f2d6"}.icon-circle-info:before{content:"\\f2d7"}.icon-circle-left:before{content:"\\f2d8"}.icon-circle-location-arrow:before{content:"\\f2d9"}.icon-circle-microphone-lines:before{content:"\\f2da"}.icon-circle-microphone:before{content:"\\f2db"}.icon-circle-minus:before{content:"\\f2dc"}.icon-circle-nodes:before{content:"\\f2dd"}.icon-circle-notch:before{content:"\\f2de"}.icon-circle-parking:before{content:"\\f2df"}.icon-circle-pause:before{content:"\\f2e0"}.icon-circle-phone-flip:before{content:"\\f2e1"}.icon-circle-phone-hangup:before{content:"\\f2e2"}.icon-circle-phone:before{content:"\\f2e3"}.icon-circle-play:before{content:"\\f2e4"}.icon-circle-plus:before{content:"\\f2e5"}.icon-circle-quarter:before{content:"\\f2e6"}.icon-circle-quarters:before{content:"\\f2e7"}.icon-circle-question:before{content:"\\f2e8"}.icon-circle-right:before{content:"\\f2e9"}.icon-circle-small:before{content:"\\f2ea"}.icon-circle-sort-down:before{content:"\\f2eb"}.icon-circle-sort-up:before{content:"\\f2ec"}.icon-circle-sort:before{content:"\\f2ed"}.icon-circle-star:before{content:"\\f2ee"}.icon-circle-stop:before{content:"\\f2ef"}.icon-circle-three-quarters:before{content:"\\f2f0"}.icon-circle-trash:before{content:"\\f2f1"}.icon-circle-up-left:before{content:"\\f2f2"}.icon-circle-up-right:before{content:"\\f2f3"}.icon-circle-up:before{content:"\\f2f4"}.icon-circle-user:before{content:"\\f2f5"}.icon-circle-video:before{content:"\\f2f6"}.icon-circle-waveform-lines:before{content:"\\f2f7"}.icon-circle-xmark:before{content:"\\f2f8"}.icon-circle:before{content:"\\f2f9"}.icon-city:before{content:"\\f2fa"}.icon-clapperboard-play:before{content:"\\f2fb"}.icon-clapperboard:before{content:"\\f2fc"}.icon-clinic-medical:before{content:"\\f2fd"}.icon-clipboard-check:before{content:"\\f2fe"}.icon-clipboard-list-check:before{content:"\\f2ff"}.icon-clipboard-list:before{content:"\\f300"}.icon-clipboard-medical:before{content:"\\f301"}.icon-clipboard-question:before{content:"\\f302"}.icon-clipboard-user:before{content:"\\f303"}.icon-clipboard:before{content:"\\f304"}.icon-clock-desk:before{content:"\\f305"}.icon-clock-eight-thirty:before{content:"\\f306"}.icon-clock-eight:before{content:"\\f307"}.icon-clock-eleven-thirty:before{content:"\\f308"}.icon-clock-eleven:before{content:"\\f309"}.icon-clock-five-thirty:before{content:"\\f30a"}.icon-clock-five:before{content:"\\f30b"}.icon-clock-four-thirty:before{content:"\\f30c"}.icon-clock-nine-thirty:before{content:"\\f30d"}.icon-clock-nine:before{content:"\\f30e"}.icon-clock-one-thirty:before{content:"\\f30f"}.icon-clock-one:before{content:"\\f310"}.icon-clock-rotate-left:before{content:"\\f311"}.icon-clock-seven-thirty:before{content:"\\f312"}.icon-clock-seven:before{content:"\\f313"}.icon-clock-six-thirty:before{content:"\\f314"}.icon-clock-six:before{content:"\\f315"}.icon-clock-ten-thirty:before{content:"\\f316"}.icon-clock-ten:before{content:"\\f317"}.icon-clock-three-thirty:before{content:"\\f318"}.icon-clock-three:before{content:"\\f319"}.icon-clock-twelve-thirty:before{content:"\\f31a"}.icon-clock-twelve:before{content:"\\f31b"}.icon-clock-two-thirty:before{content:"\\f31c"}.icon-clock-two:before{content:"\\f31d"}.icon-clock:before{content:"\\f31e"}.icon-clone:before{content:"\\f31f"}.icon-closed-captioning-slash:before{content:"\\f320"}.icon-closed-captioning:before{content:"\\f321"}.icon-cloud-arrow-down:before{content:"\\f322"}.icon-cloud-arrow-up:before{content:"\\f323"}.icon-cloud-check:before{content:"\\f324"}.icon-cloud-download-alt:before{content:"\\f325"}.icon-cloud-download:before{content:"\\f326"}.icon-cloud-exclamation:before{content:"\\f327"}.icon-cloud-fog:before{content:"\\f328"}.icon-cloud-minus:before{content:"\\f329"}.icon-cloud-music:before{content:"\\f32a"}.icon-cloud-plus:before{content:"\\f32b"}.icon-cloud-question:before{content:"\\f32c"}.icon-cloud-slash:before{content:"\\f32d"}.icon-cloud-upload-alt:before{content:"\\f32e"}.icon-cloud-upload:before{content:"\\f32f"}.icon-cloud-word:before{content:"\\f330"}.icon-cloud-xmark:before{content:"\\f331"}.icon-cloud:before{content:"\\f332"}.icon-clouds:before{content:"\\f333"}.icon-code-branch:before{content:"\\f334"}.icon-code-commit:before{content:"\\f335"}.icon-code-compare:before{content:"\\f336"}.icon-code-fork:before{content:"\\f337"}.icon-code-merge:before{content:"\\f338"}.icon-code-pull-request-closed:before{content:"\\f339"}.icon-code-pull-request-draft:before{content:"\\f33a"}.icon-code-pull-request:before{content:"\\f33b"}.icon-code-simple:before{content:"\\f33c"}.icon-code:before{content:"\\f33d"}.icon-cog:before{content:"\\f33e"}.icon-cogs:before{content:"\\f33f"}.icon-coins:before{content:"\\f340"}.icon-columns-3:before{content:"\\f341"}.icon-columns:before{content:"\\f342"}.icon-command:before{content:"\\f343"}.icon-comment-alt-check:before{content:"\\f344"}.icon-comment-alt-dollar:before{content:"\\f345"}.icon-comment-alt-dots:before{content:"\\f346"}.icon-comment-alt-edit:before{content:"\\f347"}.icon-comment-alt-exclamation:before{content:"\\f348"}.icon-comment-alt-lines:before{content:"\\f349"}.icon-comment-alt-medical:before{content:"\\f34a"}.icon-comment-alt-minus:before{content:"\\f34b"}.icon-comment-alt-music:before{content:"\\f34c"}.icon-comment-alt-plus:before{content:"\\f34d"}.icon-comment-alt-slash:before{content:"\\f34e"}.icon-comment-alt-smile:before{content:"\\f34f"}.icon-comment-alt-times:before{content:"\\f350"}.icon-comment-alt:before{content:"\\f351"}.icon-comment-arrow-down:before{content:"\\f352"}.icon-comment-arrow-up-right:before{content:"\\f353"}.icon-comment-arrow-up:before{content:"\\f354"}.icon-comment-captions:before{content:"\\f355"}.icon-comment-check:before{content:"\\f356"}.icon-comment-code:before{content:"\\f357"}.icon-comment-dollar:before{content:"\\f358"}.icon-comment-dots:before{content:"\\f359"}.icon-comment-edit:before{content:"\\f35a"}.icon-comment-exclamation:before{content:"\\f35b"}.icon-comment-image:before{content:"\\f35c"}.icon-comment-lines:before{content:"\\f35d"}.icon-comment-medical:before{content:"\\f35e"}.icon-comment-middle-top:before{content:"\\f35f"}.icon-comment-middle:before{content:"\\f360"}.icon-comment-minus:before{content:"\\f361"}.icon-comment-music:before{content:"\\f362"}.icon-comment-pen:before{content:"\\f363"}.icon-comment-plus:before{content:"\\f364"}.icon-comment-question:before{content:"\\f365"}.icon-comment-quote:before{content:"\\f366"}.icon-comment-slash:before{content:"\\f367"}.icon-comment-smile:before{content:"\\f368"}.icon-comment-sms:before{content:"\\f369"}.icon-comment-text:before{content:"\\f36a"}.icon-comment-times:before{content:"\\f36b"}.icon-comment-xmark:before{content:"\\f36c"}.icon-comment:before{content:"\\f36d"}.icon-comments-alt-dollar:before{content:"\\f36e"}.icon-comments-alt:before{content:"\\f36f"}.icon-comments-dollar:before{content:"\\f370"}.icon-comments-question-check:before{content:"\\f371"}.icon-comments-question:before{content:"\\f372"}.icon-comments:before{content:"\\f373"}.icon-compact-disc:before{content:"\\f374"}.icon-compass-slash:before{content:"\\f375"}.icon-compass:before{content:"\\f376"}.icon-compress-alt:before{content:"\\f377"}.icon-compress-arrows-alt:before{content:"\\f378"}.icon-compress-wide:before{content:"\\f379"}.icon-compress:before{content:"\\f37a"}.icon-container-storage:before{content:"\\f37b"}.icon-conveyor-belt-alt:before{content:"\\f37c"}.icon-conveyor-belt-boxes:before{content:"\\f37d"}.icon-conveyor-belt-empty:before{content:"\\f37e"}.icon-conveyor-belt:before{content:"\\f37f"}.icon-copy:before{content:"\\f380"}.icon-corner:before{content:"\\f381"}.icon-cowbell-circle-plus:before{content:"\\f382"}.icon-cowbell-more:before{content:"\\f383"}.icon-cowbell:before{content:"\\f384"}.icon-crate-apple:before{content:"\\f385"}.icon-crate-empty:before{content:"\\f386"}.icon-credit-card-blank:before{content:"\\f387"}.icon-credit-card-front:before{content:"\\f388"}.icon-credit-card:before{content:"\\f389"}.icon-crop-alt:before{content:"\\f38a"}.icon-crop-simple:before{content:"\\f38b"}.icon-crop:before{content:"\\f38c"}.icon-crosshairs:before{content:"\\f38d"}.icon-cube:before{content:"\\f38e"}.icon-cubes-stacked:before{content:"\\f38f"}.icon-cubes:before{content:"\\f390"}.icon-currency-sign:before{content:"\\f391"}.icon-dash:before{content:"\\f392"}.icon-dashboard:before{content:"\\f393"}.icon-database:before{content:"\\f394"}.icon-deaf:before{content:"\\f395"}.icon-delete-left:before{content:"\\f396"}.icon-delete-right:before{content:"\\f397"}.icon-desktop-alt:before{content:"\\f398"}.icon-desktop-arrow-down:before{content:"\\f399"}.icon-desktop:before{content:"\\f39a"}.icon-diagram-cells:before{content:"\\f39b"}.icon-diagram-lean-canvas:before{content:"\\f39c"}.icon-diagram-nested:before{content:"\\f39d"}.icon-diagram-next:before{content:"\\f39e"}.icon-diagram-predecessor:before{content:"\\f39f"}.icon-diagram-previous:before{content:"\\f3a0"}.icon-diagram-project:before{content:"\\f3a1"}.icon-diagram-sankey:before{content:"\\f3a2"}.icon-diagram-subtask:before{content:"\\f3a3"}.icon-diagram-successor:before{content:"\\f3a4"}.icon-diagram-venn:before{content:"\\f3a5"}.icon-diamond-exclamation:before{content:"\\f3a6"}.icon-diamond-turn-right:before{content:"\\f3a7"}.icon-diamond:before{content:"\\f3a8"}.icon-dice-d6:before{content:"\\f3a9"}.icon-digging:before{content:"\\f3aa"}.icon-diploma:before{content:"\\f3ab"}.icon-directions:before{content:"\\f3ac"}.icon-disc-drive:before{content:"\\f3ad"}.icon-display-arrow-down:before{content:"\\f3ae"}.icon-display-code:before{content:"\\f3af"}.icon-display-medical:before{content:"\\f3b0"}.icon-display-slash:before{content:"\\f3b1"}.icon-display:before{content:"\\f3b2"}.icon-distribute-spacing-horizontal:before{content:"\\f3b3"}.icon-distribute-spacing-vertical:before{content:"\\f3b4"}.icon-ditto:before{content:"\\f3b5"}.icon-divide:before{content:"\\f3b6"}.icon-do-not-enter:before{content:"\\f3b7"}.icon-dollar-sign:before{content:"\\f3b8"}.icon-dolly-empty:before{content:"\\f3b9"}.icon-dolly-flatbed-alt:before{content:"\\f3ba"}.icon-dolly-flatbed-empty:before{content:"\\f3bb"}.icon-dolly-flatbed:before{content:"\\f3bc"}.icon-dolly:before{content:"\\f3bd"}.icon-door-closed:before{content:"\\f3be"}.icon-door-open:before{content:"\\f3bf"}.icon-dot-circle:before{content:"\\f3c0"}.icon-down-from-dotted-line:before{content:"\\f3c1"}.icon-down-from-line:before{content:"\\f3c2"}.icon-down-left-and-up-right-to-center:before{content:"\\f3c3"}.icon-down-left:before{content:"\\f3c4"}.icon-down-long:before{content:"\\f3c5"}.icon-down-right:before{content:"\\f3c6"}.icon-down-to-bracket:before{content:"\\f3c7"}.icon-down-to-dotted-line:before{content:"\\f3c8"}.icon-down-to-line:before{content:"\\f3c9"}.icon-down:before{content:"\\f3ca"}.icon-download:before{content:"\\f3cb"}.icon-drafting-compass:before{content:"\\f3cc"}.icon-draw-circle:before{content:"\\f3cd"}.icon-draw-polygon:before{content:"\\f3ce"}.icon-draw-square:before{content:"\\f3cf"}.icon-earth-africa:before{content:"\\f3d0"}.icon-earth-americas:before{content:"\\f3d1"}.icon-earth-asia:before{content:"\\f3d2"}.icon-earth-europe:before{content:"\\f3d3"}.icon-earth-oceania:before{content:"\\f3d4"}.icon-edit:before{content:"\\f3d5"}.icon-eject:before{content:"\\f3d6"}.icon-elevator:before{content:"\\f3d7"}.icon-ellipsis-h-alt:before{content:"\\f3d8"}.icon-ellipsis-h:before{content:"\\f3d9"}.icon-ellipsis-stroke-vertical:before{content:"\\f3da"}.icon-ellipsis-stroke:before{content:"\\f3db"}.icon-ellipsis-v-alt:before{content:"\\f3dc"}.icon-ellipsis-v:before{content:"\\f3dd"}.icon-ellipsis-vertical:before{content:"\\f3de"}.icon-ellipsis:before{content:"\\f3df"}.icon-empty-set:before{content:"\\f3e0"}.icon-envelope-circle-check:before{content:"\\f3e1"}.icon-envelope-dot:before{content:"\\f3e2"}.icon-envelope-open-dollar:before{content:"\\f3e3"}.icon-envelope-open-text:before{content:"\\f3e4"}.icon-envelope-open:before{content:"\\f3e5"}.icon-envelope-square:before{content:"\\f3e6"}.icon-envelope:before{content:"\\f3e7"}.icon-envelopes-bulk:before{content:"\\f3e8"}.icon-envelopes:before{content:"\\f3e9"}.icon-equals:before{content:"\\f3ea"}.icon-eraser:before{content:"\\f3eb"}.icon-ethernet:before{content:"\\f3ec"}.icon-euro-sign:before{content:"\\f3ed"}.icon-exchange-alt:before{content:"\\f3ee"}.icon-exchange:before{content:"\\f3ef"}.icon-exclamation-circle:before{content:"\\f3f0"}.icon-exclamation-sign:before{content:"\\f3f1"}.icon-exclamation-square:before{content:"\\f3f2"}.icon-exclamation-triangle:before{content:"\\f3f3"}.icon-exclamation:before{content:"\\f3f4"}.icon-expand-alt:before{content:"\\f3f5"}.icon-expand-arrows-alt:before{content:"\\f3f6"}.icon-expand-arrows:before{content:"\\f3f7"}.icon-expand-wide:before{content:"\\f3f8"}.icon-expand:before{content:"\\f3f9"}.icon-external-link-alt:before{content:"\\f3fa"}.icon-external-link-square-alt:before{content:"\\f3fb"}.icon-external-link-square:before{content:"\\f3fc"}.icon-external-link:before{content:"\\f3fd"}.icon-eye-dropper-full:before{content:"\\f3fe"}.icon-eye-dropper-half:before{content:"\\f3ff"}.icon-eye-dropper:before{content:"\\f400"}.icon-eye-low-vision:before{content:"\\f401"}.icon-eye-slash:before{content:"\\f402"}.icon-eye:before{content:"\\f403"}.icon-face-smile:before{content:"\\f404"}.icon-fast-backward:before{content:"\\f405"}.icon-fast-forward:before{content:"\\f406"}.icon-fax:before{content:"\\f407"}.icon-file-alt:before{content:"\\f408"}.icon-file-archive:before{content:"\\f409"}.icon-file-arrow-down:before{content:"\\f40a"}.icon-file-arrow-up:before{content:"\\f40b"}.icon-file-audio:before{content:"\\f40c"}.icon-file-binary:before{content:"\\f40d"}.icon-file-certificate:before{content:"\\f40e"}.icon-file-chart-column:before{content:"\\f40f"}.icon-file-chart-line:before{content:"\\f410"}.icon-file-chart-pie:before{content:"\\f411"}.icon-file-check:before{content:"\\f412"}.icon-file-circle-check:before{content:"\\f413"}.icon-file-circle-exclamation:before{content:"\\f414"}.icon-file-circle-info:before{content:"\\f415"}.icon-file-circle-minus:before{content:"\\f416"}.icon-file-circle-plus:before{content:"\\f417"}.icon-file-circle-question:before{content:"\\f418"}.icon-file-circle-xmark:before{content:"\\f419"}.icon-file-code:before{content:"\\f41a"}.icon-file-contract:before{content:"\\f41b"}.icon-file-csv:before{content:"\\f41c"}.icon-file-dashed-line:before{content:"\\f41d"}.icon-file-download:before{content:"\\f41e"}.icon-file-edit:before{content:"\\f41f"}.icon-file-excel:before{content:"\\f420"}.icon-file-exclamation:before{content:"\\f421"}.icon-file-export:before{content:"\\f422"}.icon-file-heart:before{content:"\\f423"}.icon-file-image:before{content:"\\f424"}.icon-file-import:before{content:"\\f425"}.icon-file-invoice-dollar:before{content:"\\f426"}.icon-file-invoice:before{content:"\\f427"}.icon-file-lines:before{content:"\\f428"}.icon-file-lock:before{content:"\\f429"}.icon-file-magnifying-glass:before{content:"\\f42a"}.icon-file-medical-alt:before{content:"\\f42b"}.icon-file-medical:before{content:"\\f42c"}.icon-file-minus:before{content:"\\f42d"}.icon-file-music:before{content:"\\f42e"}.icon-file-pdf:before{content:"\\f42f"}.icon-file-pen:before{content:"\\f430"}.icon-file-plus-minus:before{content:"\\f431"}.icon-file-plus:before{content:"\\f432"}.icon-file-powerpoint:before{content:"\\f433"}.icon-file-search:before{content:"\\f434"}.icon-file-shield:before{content:"\\f435"}.icon-file-signature:before{content:"\\f436"}.icon-file-slash:before{content:"\\f437"}.icon-file-spreadsheet:before{content:"\\f438"}.icon-file-times:before{content:"\\f439"}.icon-file-upload:before{content:"\\f43a"}.icon-file-user:before{content:"\\f43b"}.icon-file-video:before{content:"\\f43c"}.icon-file-waveform:before{content:"\\f43d"}.icon-file-word:before{content:"\\f43e"}.icon-file-xmark:before{content:"\\f43f"}.icon-file-zipper:before{content:"\\f440"}.icon-file:before{content:"\\f441"}.icon-files-medical:before{content:"\\f442"}.icon-files:before{content:"\\f443"}.icon-fill-drip:before{content:"\\f444"}.icon-fill:before{content:"\\f445"}.icon-filter-circle-dollar:before{content:"\\f446"}.icon-filter-circle-xmark:before{content:"\\f447"}.icon-filter-list:before{content:"\\f448"}.icon-filter-slash:before{content:"\\f449"}.icon-filter:before{content:"\\f44a"}.icon-filters:before{content:"\\f44b"}.icon-fingerprint:before{content:"\\f44c"}.icon-fire-burner:before{content:"\\f44d"}.icon-fire-flame:before{content:"\\f44e"}.icon-fire:before{content:"\\f44f"}.icon-flag-alt:before{content:"\\f450"}.icon-flag-checkered:before{content:"\\f451"}.icon-flag-pennant:before{content:"\\f452"}.icon-flag-swallowtail:before{content:"\\f453"}.icon-flag:before{content:"\\f454"}.icon-flame:before{content:"\\f455"}.icon-floppy-disk-circle-arrow-right:before{content:"\\f456"}.icon-floppy-disk-circle-xmark:before{content:"\\f457"}.icon-floppy-disk-pen:before{content:"\\f458"}.icon-floppy-disk:before{content:"\\f459"}.icon-floppy-disks:before{content:"\\f45a"}.icon-folder-arrow-down:before{content:"\\f45b"}.icon-folder-arrow-up:before{content:"\\f45c"}.icon-folder-bookmark:before{content:"\\f45d"}.icon-folder-closed:before{content:"\\f45e"}.icon-folder-gear:before{content:"\\f45f"}.icon-folder-grid:before{content:"\\f460"}.icon-folder-heart:before{content:"\\f461"}.icon-folder-image:before{content:"\\f462"}.icon-folder-magnifying-glass:before{content:"\\f463"}.icon-folder-medical:before{content:"\\f464"}.icon-folder-minus:before{content:"\\f465"}.icon-folder-music:before{content:"\\f466"}.icon-folder-open:before{content:"\\f467"}.icon-folder-plus:before{content:"\\f468"}.icon-folder-times:before{content:"\\f469"}.icon-folder-tree:before{content:"\\f46a"}.icon-folder-user:before{content:"\\f46b"}.icon-folder-xmark:before{content:"\\f46c"}.icon-folder:before{content:"\\f46d"}.icon-folders:before{content:"\\f46e"}.icon-font-awesome-logo-full:before{content:"\\f46f"}.icon-font-awesome:before{content:"\\f470"}.icon-font-case:before{content:"\\f471"}.icon-font:before{content:"\\f472"}.icon-forward-fast:before{content:"\\f473"}.icon-forward-step:before{content:"\\f474"}.icon-forward:before{content:"\\f475"}.icon-frame:before{content:"\\f476"}.icon-frown-open:before{content:"\\f477"}.icon-frown:before{content:"\\f478"}.icon-function:before{content:"\\f479"}.icon-funnel-dollar:before{content:"\\f47a"}.icon-fup:before{content:"\\f47b"}.icon-g:before{content:"\\f47c"}.icon-gallery-thumbnails:before{content:"\\f47d"}.icon-gauge-circle-bolt:before{content:"\\f47e"}.icon-gauge-circle-minus:before{content:"\\f47f"}.icon-gauge-circle-plus:before{content:"\\f480"}.icon-gauge-high:before{content:"\\f481"}.icon-gauge-low:before{content:"\\f482"}.icon-gauge-max:before{content:"\\f483"}.icon-gauge-min:before{content:"\\f484"}.icon-gauge-simple-high:before{content:"\\f485"}.icon-gauge-simple-low:before{content:"\\f486"}.icon-gauge-simple-max:before{content:"\\f487"}.icon-gauge-simple-min:before{content:"\\f488"}.icon-gauge-simple:before{content:"\\f489"}.icon-gauge:before{content:"\\f48a"}.icon-gear:before{content:"\\f48b"}.icon-gears:before{content:"\\f48c"}.icon-genderless:before{content:"\\f48d"}.icon-gif:before{content:"\\f48e"}.icon-gift-card:before{content:"\\f48f"}.icon-gift:before{content:"\\f490"}.icon-gifts:before{content:"\\f491"}.icon-glass-empty:before{content:"\\f492"}.icon-glass-half:before{content:"\\f493"}.icon-glass-water-droplet:before{content:"\\f494"}.icon-glass-water:before{content:"\\f495"}.icon-glass:before{content:"\\f496"}.icon-globe-africa:before{content:"\\f497"}.icon-globe-americas:before{content:"\\f498"}.icon-globe-asia:before{content:"\\f499"}.icon-globe-europe:before{content:"\\f49a"}.icon-globe-snow:before{content:"\\f49b"}.icon-globe:before{content:"\\f49c"}.icon-greater-than-equal:before{content:"\\f49d"}.icon-greater-than:before{content:"\\f49e"}.icon-grid-2-plus:before{content:"\\f49f"}.icon-grid-2:before{content:"\\f4a0"}.icon-grid-4:before{content:"\\f4a1"}.icon-grid-5:before{content:"\\f4a2"}.icon-grid-dividers:before{content:"\\f4a3"}.icon-grid-horizontal:before{content:"\\f4a4"}.icon-grid:before{content:"\\f4a5"}.icon-grip-dots-vertical:before{content:"\\f4a6"}.icon-grip-dots:before{content:"\\f4a7"}.icon-grip-horizontal:before{content:"\\f4a8"}.icon-grip-lines-vertical:before{content:"\\f4a9"}.icon-grip-lines:before{content:"\\f4aa"}.icon-grip-vertical:before{content:"\\f4ab"}.icon-grip:before{content:"\\f4ac"}.icon-group-arrows-rotate:before{content:"\\f4ad"}.icon-h-square:before{content:"\\f4ae"}.icon-h:before{content:"\\f4af"}.icon-h1:before{content:"\\f4b0"}.icon-h2:before{content:"\\f4b1"}.icon-h3:before{content:"\\f4b2"}.icon-h4:before{content:"\\f4b3"}.icon-h5:before{content:"\\f4b4"}.icon-h6:before{content:"\\f4b5"}.icon-hammer:before{content:"\\f4b6"}.icon-hand-back-fist:before{content:"\\f4b7"}.icon-hand-back-point-down:before{content:"\\f4b8"}.icon-hand-back-point-left:before{content:"\\f4b9"}.icon-hand-back-point-ribbon:before{content:"\\f4ba"}.icon-hand-back-point-right:before{content:"\\f4bb"}.icon-hand-back-point-up:before{content:"\\f4bc"}.icon-hand-dots:before{content:"\\f4bd"}.icon-hand-fingers-crossed:before{content:"\\f4be"}.icon-hand-fist:before{content:"\\f4bf"}.icon-hand-heart:before{content:"\\f4c0"}.icon-hand-holding-box:before{content:"\\f4c1"}.icon-hand-holding-dollar:before{content:"\\f4c2"}.icon-hand-holding-droplet:before{content:"\\f4c3"}.icon-hand-holding-hand:before{content:"\\f4c4"}.icon-hand-holding-heart:before{content:"\\f4c5"}.icon-hand-holding-seedling:before{content:"\\f4c6"}.icon-hand-holding-usd:before{content:"\\f4c7"}.icon-hand-holding-water:before{content:"\\f4c8"}.icon-hand-holding:before{content:"\\f4c9"}.icon-hand-horns:before{content:"\\f4ca"}.icon-hand-love:before{content:"\\f4cb"}.icon-hand-paper:before{content:"\\f4cc"}.icon-hand-peace:before{content:"\\f4cd"}.icon-hand-point-down:before{content:"\\f4ce"}.icon-hand-point-left:before{content:"\\f4cf"}.icon-hand-point-ribbon:before{content:"\\f4d0"}.icon-hand-point-right:before{content:"\\f4d1"}.icon-hand-point-up:before{content:"\\f4d2"}.icon-hand-pointer:before{content:"\\f4d3"}.icon-hand-receiving:before{content:"\\f4d4"}.icon-hand-rock:before{content:"\\f4d5"}.icon-hand-scissors:before{content:"\\f4d6"}.icon-hand-sparkles:before{content:"\\f4d7"}.icon-hand-spock:before{content:"\\f4d8"}.icon-hand-wave:before{content:"\\f4d9"}.icon-hand:before{content:"\\f4da"}.icon-hands-asl-interpreting:before{content:"\\f4db"}.icon-hands-bound:before{content:"\\f4dc"}.icon-hands-bubbles:before{content:"\\f4dd"}.icon-hands-clapping:before{content:"\\f4de"}.icon-hands-heart:before{content:"\\f4df"}.icon-hands-helping:before{content:"\\f4e0"}.icon-hands-holding-child:before{content:"\\f4e1"}.icon-hands-holding-circle:before{content:"\\f4e2"}.icon-hands-holding-diamond:before{content:"\\f4e3"}.icon-hands-holding-dollar:before{content:"\\f4e4"}.icon-hands-holding-heart:before{content:"\\f4e5"}.icon-hands-holding:before{content:"\\f4e6"}.icon-hands-praying:before{content:"\\f4e7"}.icon-hands-usd:before{content:"\\f4e8"}.icon-hands:before{content:"\\f4e9"}.icon-handshake-alt:before{content:"\\f4ea"}.icon-handshake-angle:before{content:"\\f4eb"}.icon-handshake-simple-slash:before{content:"\\f4ec"}.icon-handshake-simple:before{content:"\\f4ed"}.icon-handshake-slash:before{content:"\\f4ee"}.icon-handshake:before{content:"\\f4ef"}.icon-hard-drive:before{content:"\\f4f0"}.icon-hashtag-lock:before{content:"\\f4f1"}.icon-hashtag:before{content:"\\f4f2"}.icon-hat-wizard:before{content:"\\f4f3"}.icon-hdd:before{content:"\\f4f4"}.icon-heading:before{content:"\\f4f5"}.icon-headphones-alt:before{content:"\\f4f6"}.icon-headphones-simple:before{content:"\\f4f7"}.icon-headphones:before{content:"\\f4f8"}.icon-headset:before{content:"\\f4f9"}.icon-heart:before{content:"\\f4fa"}.icon-hexagon-check:before{content:"\\f4fb"}.icon-hexagon-divide:before{content:"\\f4fc"}.icon-hexagon-exclamation:before{content:"\\f4fd"}.icon-hexagon-image:before{content:"\\f4fe"}.icon-hexagon-minus:before{content:"\\f4ff"}.icon-hexagon-plus:before{content:"\\f500"}.icon-hexagon-xmark:before{content:"\\f501"}.icon-hexagon:before{content:"\\f502"}.icon-high-definition:before{content:"\\f503"}.icon-highlighter-line:before{content:"\\f504"}.icon-highlighter:before{content:"\\f505"}.icon-history:before{content:"\\f506"}.icon-hockey-puck:before{content:"\\f507"}.icon-home-alt:before{content:"\\f508"}.icon-home-heart:before{content:"\\f509"}.icon-home-lg-alt:before{content:"\\f50a"}.icon-home-lg:before{content:"\\f50b"}.icon-home:before{content:"\\f50c"}.icon-horizontal-rule:before{content:"\\f50d"}.icon-hospital-alt:before{content:"\\f50e"}.icon-hospital-symbol:before{content:"\\f50f"}.icon-hotel:before{content:"\\f510"}.icon-hourglass-clock:before{content:"\\f511"}.icon-hourglass-empty:before{content:"\\f512"}.icon-hourglass-end:before{content:"\\f513"}.icon-hourglass-half:before{content:"\\f514"}.icon-hourglass-start:before{content:"\\f515"}.icon-hourglass:before{content:"\\f516"}.icon-house-blank:before{content:"\\f517"}.icon-house-building:before{content:"\\f518"}.icon-house-chimney-blank:before{content:"\\f519"}.icon-house-chimney-crack:before{content:"\\f51a"}.icon-house-chimney-heart:before{content:"\\f51b"}.icon-house-chimney-medical:before{content:"\\f51c"}.icon-house-chimney-user:before{content:"\\f51d"}.icon-house-chimney-window:before{content:"\\f51e"}.icon-house-chimney:before{content:"\\f51f"}.icon-house-circle-check:before{content:"\\f520"}.icon-house-circle-exclamation:before{content:"\\f521"}.icon-house-circle-xmark:before{content:"\\f522"}.icon-house-crack:before{content:"\\f523"}.icon-house-damage:before{content:"\\f524"}.icon-house-day:before{content:"\\f525"}.icon-house-fire:before{content:"\\f526"}.icon-house-flag:before{content:"\\f527"}.icon-house-flood-water-circle-arrow-right:before{content:"\\f528"}.icon-house-flood-water:before{content:"\\f529"}.icon-house-flood:before{content:"\\f52a"}.icon-house-heart:before{content:"\\f52b"}.icon-house-laptop:before{content:"\\f52c"}.icon-house-lock:before{content:"\\f52d"}.icon-house-medical-circle-check:before{content:"\\f52e"}.icon-house-medical-circle-exclamation:before{content:"\\f52f"}.icon-house-medical-circle-xmark:before{content:"\\f530"}.icon-house-medical-flag:before{content:"\\f531"}.icon-house-medical:before{content:"\\f532"}.icon-house-night:before{content:"\\f533"}.icon-house-person-leave:before{content:"\\f534"}.icon-house-person-return:before{content:"\\f535"}.icon-house-signal:before{content:"\\f536"}.icon-house-user:before{content:"\\f537"}.icon-house-water:before{content:"\\f538"}.icon-house-window:before{content:"\\f539"}.icon-house:before{content:"\\f53a"}.icon-hyphen:before{content:"\\f53b"}.icon-i-cursor:before{content:"\\f53c"}.icon-i:before{content:"\\f53d"}.icon-icons-alt:before{content:"\\f53e"}.icon-icons:before{content:"\\f53f"}.icon-id-badge:before{content:"\\f540"}.icon-id-card-alt:before{content:"\\f541"}.icon-id-card-clip:before{content:"\\f542"}.icon-id-card:before{content:"\\f543"}.icon-image-landscape:before{content:"\\f544"}.icon-image-polaroid-user:before{content:"\\f545"}.icon-image-polaroid:before{content:"\\f546"}.icon-image-portrait:before{content:"\\f547"}.icon-image-slash:before{content:"\\f548"}.icon-image-user:before{content:"\\f549"}.icon-image:before{content:"\\f54a"}.icon-images-user:before{content:"\\f54b"}.icon-images:before{content:"\\f54c"}.icon-inbox-full:before{content:"\\f54d"}.icon-inbox-in:before{content:"\\f54e"}.icon-inbox-out:before{content:"\\f54f"}.icon-inbox:before{content:"\\f550"}.icon-inboxes:before{content:"\\f551"}.icon-indent:before{content:"\\f552"}.icon-industry-alt:before{content:"\\f553"}.icon-industry-windows:before{content:"\\f554"}.icon-industry:before{content:"\\f555"}.icon-infinity:before{content:"\\f556"}.icon-info-circle:before{content:"\\f557"}.icon-info-square:before{content:"\\f558"}.icon-info:before{content:"\\f559"}.icon-input-numeric:before{content:"\\f55a"}.icon-input-pipe:before{content:"\\f55b"}.icon-input-text:before{content:"\\f55c"}.icon-integral:before{content:"\\f55d"}.icon-intersection:before{content:"\\f55e"}.icon-inventory:before{content:"\\f55f"}.icon-italic:before{content:"\\f560"}.icon-kaaba:before{content:"\\f561"}.icon-key-skeleton-left-right:before{content:"\\f562"}.icon-key-skeleton:before{content:"\\f563"}.icon-key:before{content:"\\f564"}.icon-keyboard-brightness-low:before{content:"\\f565"}.icon-keyboard-brightness:before{content:"\\f566"}.icon-keyboard-down:before{content:"\\f567"}.icon-keyboard-left:before{content:"\\f568"}.icon-keyboard:before{content:"\\f569"}.icon-keynote:before{content:"\\f56a"}.icon-lambda:before{content:"\\f56b"}.icon-landmark-alt:before{content:"\\f56c"}.icon-landmark-dome:before{content:"\\f56d"}.icon-landmark-flag:before{content:"\\f56e"}.icon-landmark:before{content:"\\f56f"}.icon-language:before{content:"\\f570"}.icon-laptop-arrow-down:before{content:"\\f571"}.icon-laptop-code:before{content:"\\f572"}.icon-laptop-file:before{content:"\\f573"}.icon-laptop-medical:before{content:"\\f574"}.icon-laptop-mobile:before{content:"\\f575"}.icon-laptop-slash:before{content:"\\f576"}.icon-laptop:before{content:"\\f577"}.icon-lasso-sparkles:before{content:"\\f578"}.icon-lasso:before{content:"\\f579"}.icon-layer-group:before{content:"\\f57a"}.icon-layer-minus:before{content:"\\f57b"}.icon-layer-plus:before{content:"\\f57c"}.icon-layout-full:before{content:"\\f57d"}.icon-layout-left:before{content:"\\f57e"}.icon-layout-splitted-columns:before{content:"\\f57f"}.icon-layout-splitted-vert:before{content:"\\f580"}.icon-layout-splitted:before{content:"\\f581"}.icon-left-from-line:before{content:"\\f582"}.icon-left-long-to-line:before{content:"\\f583"}.icon-left-long:before{content:"\\f584"}.icon-left-right:before{content:"\\f585"}.icon-left-to-line:before{content:"\\f586"}.icon-left:before{content:"\\f587"}.icon-less-than-equal:before{content:"\\f588"}.icon-less-than:before{content:"\\f589"}.icon-level-down-alt:before{content:"\\f58a"}.icon-level-down:before{content:"\\f58b"}.icon-level-up-alt:before{content:"\\f58c"}.icon-level-up:before{content:"\\f58d"}.icon-light-emergency-on:before{content:"\\f58e"}.icon-light-emergency:before{content:"\\f58f"}.icon-light-switch-off:before{content:"\\f590"}.icon-light-switch-on:before{content:"\\f591"}.icon-light-switch:before{content:"\\f592"}.icon-lightbulb-dollar:before{content:"\\f593"}.icon-lightbulb-exclamation-on:before{content:"\\f594"}.icon-lightbulb-exclamation:before{content:"\\f595"}.icon-lightbulb-on:before{content:"\\f596"}.icon-lightbulb-slash:before{content:"\\f597"}.icon-lightbulb:before{content:"\\f598"}.icon-lightning-bolt:before{content:"\\f599"}.icon-line-columns:before{content:"\\f59a"}.icon-line-height:before{content:"\\f59b"}.icon-lines-leaning:before{content:"\\f59c"}.icon-link-horizontal-slash:before{content:"\\f59d"}.icon-link-horizontal:before{content:"\\f59e"}.icon-link-simple-slash:before{content:"\\f59f"}.icon-link-simple:before{content:"\\f5a0"}.icon-link-slash:before{content:"\\f5a1"}.icon-link:before{content:"\\f5a2"}.icon-lira-sign:before{content:"\\f5a3"}.icon-list-alt:before{content:"\\f5a4"}.icon-list-check:before{content:"\\f5a5"}.icon-list-dropdown:before{content:"\\f5a6"}.icon-list-music:before{content:"\\f5a7"}.icon-list-ol:before{content:"\\f5a8"}.icon-list-radio:before{content:"\\f5a9"}.icon-list-timeline:before{content:"\\f5aa"}.icon-list-tree:before{content:"\\f5ab"}.icon-list-ul:before{content:"\\f5ac"}.icon-list:before{content:"\\f5ad"}.icon-loader:before{content:"\\f5ae"}.icon-location-arrow:before{content:"\\f5af"}.icon-location-check:before{content:"\\f5b0"}.icon-location-circle:before{content:"\\f5b1"}.icon-location-crosshairs-slash:before{content:"\\f5b2"}.icon-location-crosshairs:before{content:"\\f5b3"}.icon-location-dot-slash:before{content:"\\f5b4"}.icon-location-dot:before{content:"\\f5b5"}.icon-location-exclamation:before{content:"\\f5b6"}.icon-location-minus:before{content:"\\f5b7"}.icon-location-pen:before{content:"\\f5b8"}.icon-location-pin-lock:before{content:"\\f5b9"}.icon-location-pin-slash:before{content:"\\f5ba"}.icon-location-pin:before{content:"\\f5bb"}.icon-location-plus:before{content:"\\f5bc"}.icon-location-question:before{content:"\\f5bd"}.icon-location-slash:before{content:"\\f5be"}.icon-location-smile:before{content:"\\f5bf"}.icon-location-xmark:before{content:"\\f5c0"}.icon-location:before{content:"\\f5c1"}.icon-lock-a:before{content:"\\f5c2"}.icon-lock-alt:before{content:"\\f5c3"}.icon-lock-hashtag:before{content:"\\f5c4"}.icon-lock-keyhole-open:before{content:"\\f5c5"}.icon-lock-keyhole:before{content:"\\f5c6"}.icon-lock-open-alt:before{content:"\\f5c7"}.icon-lock-open:before{content:"\\f5c8"}.icon-lock:before{content:"\\f5c9"}.icon-long-arrow-alt-down:before{content:"\\f5ca"}.icon-long-arrow-alt-left:before{content:"\\f5cb"}.icon-long-arrow-alt-right:before{content:"\\f5cc"}.icon-long-arrow-alt-up:before{content:"\\f5cd"}.icon-long-arrow-down:before{content:"\\f5ce"}.icon-long-arrow-left:before{content:"\\f5cf"}.icon-long-arrow-right:before{content:"\\f5d0"}.icon-long-arrow-up:before{content:"\\f5d1"}.icon-low-vision:before{content:"\\f5d2"}.icon-luggage-cart:before{content:"\\f5d3"}.icon-magic:before{content:"\\f5d4"}.icon-magnet:before{content:"\\f5d5"}.icon-magnifying-glass-arrow-right:before{content:"\\f5d6"}.icon-magnifying-glass-chart:before{content:"\\f5d7"}.icon-magnifying-glass-dollar:before{content:"\\f5d8"}.icon-magnifying-glass-location:before{content:"\\f5d9"}.icon-magnifying-glass-minus:before{content:"\\f5da"}.icon-magnifying-glass-plus:before{content:"\\f5db"}.icon-magnifying-glass:before{content:"\\f5dc"}.icon-mail-bulk:before{content:"\\f5dd"}.icon-mailbox:before{content:"\\f5de"}.icon-male:before{content:"\\f5df"}.icon-map-location-dot:before{content:"\\f5e0"}.icon-map-location:before{content:"\\f5e1"}.icon-map-marked-alt:before{content:"\\f5e2"}.icon-map-marked:before{content:"\\f5e3"}.icon-map-marker-alt-slash:before{content:"\\f5e4"}.icon-map-marker-alt:before{content:"\\f5e5"}.icon-map-marker-check:before{content:"\\f5e6"}.icon-map-marker-edit:before{content:"\\f5e7"}.icon-map-marker-exclamation:before{content:"\\f5e8"}.icon-map-marker-minus:before{content:"\\f5e9"}.icon-map-marker-plus:before{content:"\\f5ea"}.icon-map-marker-question:before{content:"\\f5eb"}.icon-map-marker-slash:before{content:"\\f5ec"}.icon-map-marker-smile:before{content:"\\f5ed"}.icon-map-marker-times:before{content:"\\f5ee"}.icon-map-marker:before{content:"\\f5ef"}.icon-map-pin:before{content:"\\f5f0"}.icon-map-signs:before{content:"\\f5f1"}.icon-map:before{content:"\\f5f2"}.icon-marker:before{content:"\\f5f3"}.icon-market-place:before{content:"\\f5f4"}.icon-market:before{content:"\\f5f5"}.icon-mattress-pillow:before{content:"\\f5f6"}.icon-maximize:before{content:"\\f5f7"}.icon-me-logo:before{content:"\\f5f8"}.icon-memo-circle-check:before{content:"\\f5f9"}.icon-memo-circle-info:before{content:"\\f5fa"}.icon-memo-pad:before{content:"\\f5fb"}.icon-memo:before{content:"\\f5fc"}.icon-memory:before{content:"\\f5fd"}.icon-merge:before{content:"\\f5fe"}.icon-message-arrow-down:before{content:"\\f5ff"}.icon-message-arrow-up-right:before{content:"\\f600"}.icon-message-arrow-up:before{content:"\\f601"}.icon-message-bot:before{content:"\\f602"}.icon-message-captions:before{content:"\\f603"}.icon-message-check:before{content:"\\f604"}.icon-message-code:before{content:"\\f605"}.icon-message-dollar:before{content:"\\f606"}.icon-message-dots:before{content:"\\f607"}.icon-message-exclamation:before{content:"\\f608"}.icon-message-image:before{content:"\\f609"}.icon-message-lines:before{content:"\\f60a"}.icon-message-medical:before{content:"\\f60b"}.icon-message-middle-top:before{content:"\\f60c"}.icon-message-middle:before{content:"\\f60d"}.icon-message-minus:before{content:"\\f60e"}.icon-message-music:before{content:"\\f60f"}.icon-message-pen:before{content:"\\f610"}.icon-message-plus:before{content:"\\f611"}.icon-message-question:before{content:"\\f612"}.icon-message-quote:before{content:"\\f613"}.icon-message-slash:before{content:"\\f614"}.icon-message-smile:before{content:"\\f615"}.icon-message-sms:before{content:"\\f616"}.icon-message-text:before{content:"\\f617"}.icon-message-xmark:before{content:"\\f618"}.icon-message:before{content:"\\f619"}.icon-messages-dollar:before{content:"\\f61a"}.icon-messages-question:before{content:"\\f61b"}.icon-messages:before{content:"\\f61c"}.icon-meter-bolt:before{content:"\\f61d"}.icon-meter-droplet:before{content:"\\f61e"}.icon-meter-fire:before{content:"\\f61f"}.icon-meter:before{content:"\\f620"}.icon-microchip-ai:before{content:"\\f621"}.icon-microchip:before{content:"\\f622"}.icon-microphone-alt-slash:before{content:"\\f623"}.icon-microphone-alt:before{content:"\\f624"}.icon-microphone-lines-slash:before{content:"\\f625"}.icon-microphone-lines:before{content:"\\f626"}.icon-microphone-slash:before{content:"\\f627"}.icon-microphone:before{content:"\\f628"}.icon-minimize:before{content:"\\f629"}.icon-minus-circle:before{content:"\\f62a"}.icon-minus-hexagon:before{content:"\\f62b"}.icon-minus-octagon:before{content:"\\f62c"}.icon-minus-square:before{content:"\\f62d"}.icon-minus:before{content:"\\f62e"}.icon-mobile-alt:before{content:"\\f62f"}.icon-mobile-android-alt:before{content:"\\f630"}.icon-mobile-android:before{content:"\\f631"}.icon-mobile-button:before{content:"\\f632"}.icon-mobile-notch:before{content:"\\f633"}.icon-mobile-retro:before{content:"\\f634"}.icon-mobile-screen-button:before{content:"\\f635"}.icon-mobile-screen:before{content:"\\f636"}.icon-mobile-signal-out:before{content:"\\f637"}.icon-mobile-signal:before{content:"\\f638"}.icon-mobile:before{content:"\\f639"}.icon-money-bill-1-wave:before{content:"\\f63a"}.icon-money-bill-1:before{content:"\\f63b"}.icon-money-bill-alt:before{content:"\\f63c"}.icon-money-bill-simple-wave:before{content:"\\f63d"}.icon-money-bill-simple:before{content:"\\f63e"}.icon-money-bill-transfer:before{content:"\\f63f"}.icon-money-bill-trend-up:before{content:"\\f640"}.icon-money-bill-wave-alt:before{content:"\\f641"}.icon-money-bill-wave:before{content:"\\f642"}.icon-money-bill-wheat:before{content:"\\f643"}.icon-money-bill:before{content:"\\f644"}.icon-money-bills-simple:before{content:"\\f645"}.icon-money-bills:before{content:"\\f646"}.icon-money-check-alt:before{content:"\\f647"}.icon-money-check-dollar-pen:before{content:"\\f648"}.icon-money-check-dollar:before{content:"\\f649"}.icon-money-check-edit-alt:before{content:"\\f64a"}.icon-money-check-edit:before{content:"\\f64b"}.icon-money-check-pen:before{content:"\\f64c"}.icon-money-check:before{content:"\\f64d"}.icon-money-from-bracket:before{content:"\\f64e"}.icon-money-simple-from-bracket:before{content:"\\f64f"}.icon-monitor-heart-rate:before{content:"\\f650"}.icon-monitor-waveform:before{content:"\\f651"}.icon-mouse-alt:before{content:"\\f652"}.icon-mouse-pointer:before{content:"\\f653"}.icon-mouse:before{content:"\\f654"}.icon-mp3-player:before{content:"\\f655"}.icon-network-wired:before{content:"\\f656"}.icon-neuter:before{content:"\\f657"}.icon-newspaper:before{content:"\\f658"}.icon-nfc-lock:before{content:"\\f659"}.icon-nfc-magnifying-glass:before{content:"\\f65a"}.icon-nfc-pen:before{content:"\\f65b"}.icon-nfc-signal:before{content:"\\f65c"}.icon-nfc-slash:before{content:"\\f65d"}.icon-nfc-symbol:before{content:"\\f65e"}.icon-nfc-trash:before{content:"\\f65f"}.icon-nfc:before{content:"\\f660"}.icon-not-equal:before{content:"\\f661"}.icon-notdef:before{content:"\\f662"}.icon-note-medical:before{content:"\\f663"}.icon-note-sticky:before{content:"\\f664"}.icon-note:before{content:"\\f665"}.icon-notebook:before{content:"\\f666"}.icon-notes-medical:before{content:"\\f667"}.icon-notes:before{content:"\\f668"}.icon-o:before{content:"\\f669"}.icon-object-exclude:before{content:"\\f66a"}.icon-object-group:before{content:"\\f66b"}.icon-object-intersect:before{content:"\\f66c"}.icon-object-subtract:before{content:"\\f66d"}.icon-object-ungroup:before{content:"\\f66e"}.icon-object-union:before{content:"\\f66f"}.icon-objects-align-bottom:before{content:"\\f670"}.icon-objects-align-center-horizontal:before{content:"\\f671"}.icon-objects-align-center-vertical:before{content:"\\f672"}.icon-objects-align-left:before{content:"\\f673"}.icon-objects-align-right:before{content:"\\f674"}.icon-objects-align-top:before{content:"\\f675"}.icon-objects-column:before{content:"\\f676"}.icon-octagon-check:before{content:"\\f677"}.icon-octagon-divide:before{content:"\\f678"}.icon-octagon-exclamation:before{content:"\\f679"}.icon-octagon-minus:before{content:"\\f67a"}.icon-octagon-plus:before{content:"\\f67b"}.icon-octagon-xmark:before{content:"\\f67c"}.icon-octagon:before{content:"\\f67d"}.icon-omega:before{content:"\\f67e"}.icon-option:before{content:"\\f67f"}.icon-outdent:before{content:"\\f680"}.icon-overline:before{content:"\\f681"}.icon-page-break:before{content:"\\f682"}.icon-page-caret-down:before{content:"\\f683"}.icon-page-caret-up:before{content:"\\f684"}.icon-page:before{content:"\\f685"}.icon-pager:before{content:"\\f686"}.icon-paint-brush-alt:before{content:"\\f687"}.icon-paint-brush:before{content:"\\f688"}.icon-paint-roller:before{content:"\\f689"}.icon-paintbrush-fine:before{content:"\\f68a"}.icon-paintbrush-pencil:before{content:"\\f68b"}.icon-paintbrush:before{content:"\\f68c"}.icon-palette:before{content:"\\f68d"}.icon-pallet-alt:before{content:"\\f68e"}.icon-pallet-box:before{content:"\\f68f"}.icon-pallet-boxes:before{content:"\\f690"}.icon-pallet:before{content:"\\f691"}.icon-panel-ews:before{content:"\\f692"}.icon-panel-fire:before{content:"\\f693"}.icon-panorama:before{content:"\\f694"}.icon-paper-plane-top:before{content:"\\f695"}.icon-paper-plane:before{content:"\\f696"}.icon-paperclip-vertical:before{content:"\\f697"}.icon-paperclip:before{content:"\\f698"}.icon-paragraph-left:before{content:"\\f699"}.icon-paragraph-rtl:before{content:"\\f69a"}.icon-paragraph:before{content:"\\f69b"}.icon-paste:before{content:"\\f69c"}.icon-pause-circle:before{content:"\\f69d"}.icon-pause:before{content:"\\f69e"}.icon-pedestal:before{content:"\\f69f"}.icon-pen-alt:before{content:"\\f6a0"}.icon-pen-circle:before{content:"\\f6a1"}.icon-pen-clip-slash:before{content:"\\f6a2"}.icon-pen-clip:before{content:"\\f6a3"}.icon-pen-fancy-slash:before{content:"\\f6a4"}.icon-pen-fancy:before{content:"\\f6a5"}.icon-pen-field:before{content:"\\f6a6"}.icon-pen-line:before{content:"\\f6a7"}.icon-pen-nib-slash:before{content:"\\f6a8"}.icon-pen-nib:before{content:"\\f6a9"}.icon-pen-paintbrush:before{content:"\\f6aa"}.icon-pen-ruler:before{content:"\\f6ab"}.icon-pen-slash:before{content:"\\f6ac"}.icon-pen-square:before{content:"\\f6ad"}.icon-pen-swirl:before{content:"\\f6ae"}.icon-pen-to-square:before{content:"\\f6af"}.icon-pen:before{content:"\\f6b0"}.icon-pencil-alt:before{content:"\\f6b1"}.icon-pencil-paintbrush:before{content:"\\f6b2"}.icon-pencil-ruler:before{content:"\\f6b3"}.icon-pencil-slash:before{content:"\\f6b4"}.icon-pencil:before{content:"\\f6b5"}.icon-pennant:before{content:"\\f6b6"}.icon-people-arrows-left-right:before{content:"\\f6b7"}.icon-people-arrows:before{content:"\\f6b8"}.icon-people-carry-box:before{content:"\\f6b9"}.icon-people-carry:before{content:"\\f6ba"}.icon-people-dress-simple:before{content:"\\f6bb"}.icon-people-dress:before{content:"\\f6bc"}.icon-people-group:before{content:"\\f6bd"}.icon-people-line:before{content:"\\f6be"}.icon-people-pants-simple:before{content:"\\f6bf"}.icon-people-pants:before{content:"\\f6c0"}.icon-people-pulling:before{content:"\\f6c1"}.icon-people-robbery:before{content:"\\f6c2"}.icon-people-roof:before{content:"\\f6c3"}.icon-people-simple:before{content:"\\f6c4"}.icon-people:before{content:"\\f6c5"}.icon-percent:before{content:"\\f6c6"}.icon-percentage:before{content:"\\f6c7"}.icon-period:before{content:"\\f6c8"}.icon-person-arrow-down-to-line:before{content:"\\f6c9"}.icon-person-arrow-up-from-line:before{content:"\\f6ca"}.icon-person-biking-mountain:before{content:"\\f6cb"}.icon-person-biking:before{content:"\\f6cc"}.icon-person-booth:before{content:"\\f6cd"}.icon-person-breastfeeding:before{content:"\\f6ce"}.icon-person-burst:before{content:"\\f6cf"}.icon-person-carry-box:before{content:"\\f6d0"}.icon-person-carry:before{content:"\\f6d1"}.icon-person-chalkboard:before{content:"\\f6d2"}.icon-person-circle-check:before{content:"\\f6d3"}.icon-person-circle-exclamation:before{content:"\\f6d4"}.icon-person-circle-minus:before{content:"\\f6d5"}.icon-person-circle-plus:before{content:"\\f6d6"}.icon-person-circle-question:before{content:"\\f6d7"}.icon-person-circle-xmark:before{content:"\\f6d8"}.icon-person-digging:before{content:"\\f6d9"}.icon-person-dolly-empty:before{content:"\\f6da"}.icon-person-dolly:before{content:"\\f6db"}.icon-person-dots-from-line:before{content:"\\f6dc"}.icon-person-dress-simple:before{content:"\\f6dd"}.icon-person-dress:before{content:"\\f6de"}.icon-person-half-dress:before{content:"\\f6df"}.icon-person-harassing:before{content:"\\f6e0"}.icon-person-hiking:before{content:"\\f6e1"}.icon-person-military-pointing:before{content:"\\f6e2"}.icon-person-military-rifle:before{content:"\\f6e3"}.icon-person-military-to-person:before{content:"\\f6e4"}.icon-person-rays:before{content:"\\f6e5"}.icon-person-running:before{content:"\\f6e6"}.icon-person-shelter:before{content:"\\f6e7"}.icon-person-sign:before{content:"\\f6e8"}.icon-person-simple:before{content:"\\f6e9"}.icon-person-to-door:before{content:"\\f6ea"}.icon-person-walking-arrow-loop-left:before{content:"\\f6eb"}.icon-person-walking-arrow-right:before{content:"\\f6ec"}.icon-person-walking-dashed-line-arrow-right:before{content:"\\f6ed"}.icon-person-walking-luggage:before{content:"\\f6ee"}.icon-person-walking-with-cane:before{content:"\\f6ef"}.icon-person-walking:before{content:"\\f6f0"}.icon-person:before{content:"\\f6f1"}.icon-peseta-sign:before{content:"\\f6f2"}.icon-peso-sign:before{content:"\\f6f3"}.icon-phone-alt:before{content:"\\f6f4"}.icon-phone-arrow-down-left:before{content:"\\f6f5"}.icon-phone-arrow-up-right:before{content:"\\f6f6"}.icon-phone-flip:before{content:"\\f6f7"}.icon-phone-hangup:before{content:"\\f6f8"}.icon-phone-intercom:before{content:"\\f6f9"}.icon-phone-laptop:before{content:"\\f6fa"}.icon-phone-missed:before{content:"\\f6fb"}.icon-phone-office:before{content:"\\f6fc"}.icon-phone-plus:before{content:"\\f6fd"}.icon-phone-rotary:before{content:"\\f6fe"}.icon-phone-slash:before{content:"\\f6ff"}.icon-phone-square-alt:before{content:"\\f700"}.icon-phone-square:before{content:"\\f701"}.icon-phone-volume:before{content:"\\f702"}.icon-phone-xmark:before{content:"\\f703"}.icon-phone:before{content:"\\f704"}.icon-photo-film-music:before{content:"\\f705"}.icon-photo-film:before{content:"\\f706"}.icon-photo-video:before{content:"\\f707"}.icon-pi:before{content:"\\f708"}.icon-pipe-circle-check:before{content:"\\f709"}.icon-pipe-collar:before{content:"\\f70a"}.icon-pipe-section:before{content:"\\f70b"}.icon-pipe-valve:before{content:"\\f70c"}.icon-pipe:before{content:"\\f70d"}.icon-planet-moon:before{content:"\\f70e"}.icon-planet-ringed:before{content:"\\f70f"}.icon-play-circle:before{content:"\\f710"}.icon-play-pause:before{content:"\\f711"}.icon-play:before{content:"\\f712"}.icon-plug-circle-bolt:before{content:"\\f713"}.icon-plug-circle-check:before{content:"\\f714"}.icon-plug-circle-exclamation:before{content:"\\f715"}.icon-plug-circle-minus:before{content:"\\f716"}.icon-plug-circle-plus:before{content:"\\f717"}.icon-plug-circle-xmark:before{content:"\\f718"}.icon-plug:before{content:"\\f719"}.icon-plus-circle:before{content:"\\f71a"}.icon-plus-hexagon:before{content:"\\f71b"}.icon-plus-large:before{content:"\\f71c"}.icon-plus-minus:before{content:"\\f71d"}.icon-plus-octagon:before{content:"\\f71e"}.icon-plus-square:before{content:"\\f71f"}.icon-plus:before{content:"\\f720"}.icon-podium-star:before{content:"\\f721"}.icon-podium:before{content:"\\f722"}.icon-poll-h:before{content:"\\f723"}.icon-poll-people:before{content:"\\f724"}.icon-poll:before{content:"\\f725"}.icon-pompebled:before{content:"\\f726"}.icon-poo-storm:before{content:"\\f727"}.icon-portrait:before{content:"\\f728"}.icon-power-off:before{content:"\\f729"}.icon-presentation-screen:before{content:"\\f72a"}.icon-presentation:before{content:"\\f72b"}.icon-preview:before{content:"\\f72c"}.icon-print-magnifying-glass:before{content:"\\f72d"}.icon-print-search:before{content:"\\f72e"}.icon-print-slash:before{content:"\\f72f"}.icon-print:before{content:"\\f730"}.icon-products:before{content:"\\f731"}.icon-project-diagram:before{content:"\\f732"}.icon-project:before{content:"\\f733"}.icon-puzzle-piece-simple:before{content:"\\f734"}.icon-puzzle-piece:before{content:"\\f735"}.icon-puzzle:before{content:"\\f736"}.icon-q:before{content:"\\f737"}.icon-qrcode:before{content:"\\f738"}.icon-question-circle:before{content:"\\f739"}.icon-question-square:before{content:"\\f73a"}.icon-question:before{content:"\\f73b"}.icon-quote-left:before{content:"\\f73c"}.icon-quote-right:before{content:"\\f73d"}.icon-quotes:before{content:"\\f73e"}.icon-random:before{content:"\\f73f"}.icon-ranking-star:before{content:"\\f740"}.icon-receipt:before{content:"\\f741"}.icon-record-vinyl:before{content:"\\f742"}.icon-rectangle-ad:before{content:"\\f743"}.icon-rectangle-barcode:before{content:"\\f744"}.icon-rectangle-code:before{content:"\\f745"}.icon-rectangle-history-circle-plus:before{content:"\\f746"}.icon-rectangle-history-circle-user:before{content:"\\f747"}.icon-rectangle-history:before{content:"\\f748"}.icon-rectangle-landscape:before{content:"\\f749"}.icon-rectangle-list:before{content:"\\f74a"}.icon-rectangle-portrait:before{content:"\\f74b"}.icon-rectangle-pro:before{content:"\\f74c"}.icon-rectangle-terminal:before{content:"\\f74d"}.icon-rectangle-vertical-history:before{content:"\\f74e"}.icon-rectangle-vertical:before{content:"\\f74f"}.icon-rectangle-wide:before{content:"\\f750"}.icon-rectangle-xmark:before{content:"\\f751"}.icon-rectangle:before{content:"\\f752"}.icon-rectangles-mixed:before{content:"\\f753"}.icon-recycle:before{content:"\\f754"}.icon-redo-alt:before{content:"\\f755"}.icon-redo:before{content:"\\f756"}.icon-reel:before{content:"\\f757"}.icon-refrigerator:before{content:"\\f758"}.icon-registered:before{content:"\\f759"}.icon-remove-format:before{content:"\\f75a"}.icon-repeat-1-alt:before{content:"\\f75b"}.icon-repeat-1:before{content:"\\f75c"}.icon-repeat-alt:before{content:"\\f75d"}.icon-repeat:before{content:"\\f75e"}.icon-reply-all:before{content:"\\f75f"}.icon-reply-clock:before{content:"\\f760"}.icon-reply:before{content:"\\f761"}.icon-restroom-simple:before{content:"\\f762"}.icon-restroom:before{content:"\\f763"}.icon-retweet-alt:before{content:"\\f764"}.icon-retweet:before{content:"\\f765"}.icon-rhombus:before{content:"\\f766"}.icon-right-from-bracket:before{content:"\\f767"}.icon-right-from-line:before{content:"\\f768"}.icon-right-left:before{content:"\\f769"}.icon-right-long-to-line:before{content:"\\f76a"}.icon-right-long:before{content:"\\f76b"}.icon-right-to-bracket:before{content:"\\f76c"}.icon-right-to-line:before{content:"\\f76d"}.icon-right:before{content:"\\f76e"}.icon-ring:before{content:"\\f76f"}.icon-road-barrier:before{content:"\\f770"}.icon-road-bridge:before{content:"\\f771"}.icon-road-circle-check:before{content:"\\f772"}.icon-road-circle-exclamation:before{content:"\\f773"}.icon-road-circle-xmark:before{content:"\\f774"}.icon-road-lock:before{content:"\\f775"}.icon-road-spikes:before{content:"\\f776"}.icon-road:before{content:"\\f777"}.icon-robot:before{content:"\\f778"}.icon-rocket-launch:before{content:"\\f779"}.icon-rocket:before{content:"\\f77a"}.icon-rotate-exclamation:before{content:"\\f77b"}.icon-rotate-left:before{content:"\\f77c"}.icon-rotate-right:before{content:"\\f77d"}.icon-rotate:before{content:"\\f77e"}.icon-route-highway:before{content:"\\f77f"}.icon-route-interstate:before{content:"\\f780"}.icon-route:before{content:"\\f781"}.icon-router:before{content:"\\f782"}.icon-rss-square:before{content:"\\f783"}.icon-rss:before{content:"\\f784"}.icon-rug:before{content:"\\f785"}.icon-ruler-combined:before{content:"\\f786"}.icon-ruler-horizontal:before{content:"\\f787"}.icon-ruler-triangle:before{content:"\\f788"}.icon-ruler-vertical:before{content:"\\f789"}.icon-ruler:before{content:"\\f78a"}.icon-running:before{content:"\\f78b"}.icon-sack-dollar:before{content:"\\f78c"}.icon-sack-xmark:before{content:"\\f78d"}.icon-sack:before{content:"\\f78e"}.icon-satellite-dish:before{content:"\\f78f"}.icon-satellite:before{content:"\\f790"}.icon-save:before{content:"\\f791"}.icon-scanner-image:before{content:"\\f792"}.icon-scanner-keyboard:before{content:"\\f793"}.icon-scanner-touchscreen:before{content:"\\f794"}.icon-scanner:before{content:"\\f795"}.icon-school-circle-check:before{content:"\\f796"}.icon-school-circle-exclamation:before{content:"\\f797"}.icon-school-circle-xmark:before{content:"\\f798"}.icon-school-flag:before{content:"\\f799"}.icon-school-lock:before{content:"\\f79a"}.icon-school:before{content:"\\f79b"}.icon-scissors:before{content:"\\f79c"}.icon-screen-users:before{content:"\\f79d"}.icon-screencast:before{content:"\\f79e"}.icon-screwdriver-wrench:before{content:"\\f79f"}.icon-screwdriver:before{content:"\\f7a0"}.icon-scribble:before{content:"\\f7a1"}.icon-scroll-old:before{content:"\\f7a2"}.icon-scroll:before{content:"\\f7a3"}.icon-scrubber:before{content:"\\f7a4"}.icon-sd-card:before{content:"\\f7a5"}.icon-sd-cards:before{content:"\\f7a6"}.icon-seal-exclamation:before{content:"\\f7a7"}.icon-seal-question:before{content:"\\f7a8"}.icon-seal:before{content:"\\f7a9"}.icon-search-dollar:before{content:"\\f7aa"}.icon-search-location:before{content:"\\f7ab"}.icon-search-minus:before{content:"\\f7ac"}.icon-search-plus:before{content:"\\f7ad"}.icon-search:before{content:"\\f7ae"}.icon-section:before{content:"\\f7af"}.icon-semicolon:before{content:"\\f7b0"}.icon-send-back:before{content:"\\f7b1"}.icon-send-backward:before{content:"\\f7b2"}.icon-sensor-cloud:before{content:"\\f7b3"}.icon-sensor-fire:before{content:"\\f7b4"}.icon-sensor-on:before{content:"\\f7b5"}.icon-sensor-triangle-exclamation:before{content:"\\f7b6"}.icon-sensor:before{content:"\\f7b7"}.icon-server:before{content:"\\f7b8"}.icon-shapes:before{content:"\\f7b9"}.icon-share-all:before{content:"\\f7ba"}.icon-share-alt-square:before{content:"\\f7bb"}.icon-share-alt:before{content:"\\f7bc"}.icon-share-from-square:before{content:"\\f7bd"}.icon-share-nodes:before{content:"\\f7be"}.icon-share-square:before{content:"\\f7bf"}.icon-share:before{content:"\\f7c0"}.icon-sheet-plastic:before{content:"\\f7c1"}.icon-shelves-empty:before{content:"\\f7c2"}.icon-shelves:before{content:"\\f7c3"}.icon-shield-alt:before{content:"\\f7c4"}.icon-shield-cat:before{content:"\\f7c5"}.icon-shield-check:before{content:"\\f7c6"}.icon-shield-cross:before{content:"\\f7c7"}.icon-shield-dog:before{content:"\\f7c8"}.icon-shield-exclamation:before{content:"\\f7c9"}.icon-shield-halved:before{content:"\\f7ca"}.icon-shield-heart:before{content:"\\f7cb"}.icon-shield-keyhole:before{content:"\\f7cc"}.icon-shield-minus:before{content:"\\f7cd"}.icon-shield-plus:before{content:"\\f7ce"}.icon-shield-quartered:before{content:"\\f7cf"}.icon-shield-slash:before{content:"\\f7d0"}.icon-shield-xmark:before{content:"\\f7d1"}.icon-shield:before{content:"\\f7d2"}.icon-ship:before{content:"\\f7d3"}.icon-shipping-fast:before{content:"\\f7d4"}.icon-shipping-timed:before{content:"\\f7d5"}.icon-shop-lock:before{content:"\\f7d6"}.icon-shop-slash:before{content:"\\f7d7"}.icon-shop:before{content:"\\f7d8"}.icon-shopping-bag:before{content:"\\f7d9"}.icon-shopping-basket:before{content:"\\f7da"}.icon-shopping-cart:before{content:"\\f7db"}.icon-shredder:before{content:"\\f7dc"}.icon-shuffle:before{content:"\\f7dd"}.icon-shutters:before{content:"\\f7de"}.icon-sidebar-flip:before{content:"\\f7df"}.icon-sidebar:before{content:"\\f7e0"}.icon-sign-hanging:before{content:"\\f7e1"}.icon-sign-in-alt:before{content:"\\f7e2"}.icon-sign-in:before{content:"\\f7e3"}.icon-sign-language:before{content:"\\f7e4"}.icon-sign-out-alt:before{content:"\\f7e5"}.icon-sign-out:before{content:"\\f7e6"}.icon-sign:before{content:"\\f7e7"}.icon-signal-1:before{content:"\\f7e8"}.icon-signal-2:before{content:"\\f7e9"}.icon-signal-3:before{content:"\\f7ea"}.icon-signal-4:before{content:"\\f7eb"}.icon-signal-alt-1:before{content:"\\f7ec"}.icon-signal-alt-2:before{content:"\\f7ed"}.icon-signal-alt-3:before{content:"\\f7ee"}.icon-signal-alt-slash:before{content:"\\f7ef"}.icon-signal-alt:before{content:"\\f7f0"}.icon-signal-bars-fair:before{content:"\\f7f1"}.icon-signal-bars-good:before{content:"\\f7f2"}.icon-signal-bars-slash:before{content:"\\f7f3"}.icon-signal-bars-weak:before{content:"\\f7f4"}.icon-signal-bars:before{content:"\\f7f5"}.icon-signal-fair:before{content:"\\f7f6"}.icon-signal-good:before{content:"\\f7f7"}.icon-signal-slash:before{content:"\\f7f8"}.icon-signal-stream-slash:before{content:"\\f7f9"}.icon-signal-stream:before{content:"\\f7fa"}.icon-signal-strong:before{content:"\\f7fb"}.icon-signal-weak:before{content:"\\f7fc"}.icon-signal:before{content:"\\f7fd"}.icon-signature-lock:before{content:"\\f7fe"}.icon-signature-slash:before{content:"\\f7ff"}.icon-signature:before{content:"\\f800"}.icon-signs-post:before{content:"\\f801"}.icon-sim-card:before{content:"\\f802"}.icon-sim-cards:before{content:"\\f803"}.icon-sink:before{content:"\\f804"}.icon-siren-on:before{content:"\\f805"}.icon-siren:before{content:"\\f806"}.icon-sitemap:before{content:"\\f807"}.icon-slash-back:before{content:"\\f808"}.icon-slash-forward:before{content:"\\f809"}.icon-slash:before{content:"\\f80a"}.icon-slider:before{content:"\\f80b"}.icon-sliders-h-square:before{content:"\\f80c"}.icon-sliders-h:before{content:"\\f80d"}.icon-sliders-simple:before{content:"\\f80e"}.icon-sliders-up:before{content:"\\f80f"}.icon-sliders-v-square:before{content:"\\f810"}.icon-sliders-v:before{content:"\\f811"}.icon-sliders:before{content:"\\f812"}.icon-smog:before{content:"\\f813"}.icon-smoke:before{content:"\\f814"}.icon-sms:before{content:"\\f815"}.icon-snooze:before{content:"\\f816"}.icon-sort-alpha-down-alt:before{content:"\\f817"}.icon-sort-alpha-down:before{content:"\\f818"}.icon-sort-alpha-up-alt:before{content:"\\f819"}.icon-sort-alpha-up:before{content:"\\f81a"}.icon-sort-alt:before{content:"\\f81b"}.icon-sort-amount-down-alt:before{content:"\\f81c"}.icon-sort-amount-down:before{content:"\\f81d"}.icon-sort-amount-up-alt:before{content:"\\f81e"}.icon-sort-amount-up:before{content:"\\f81f"}.icon-sort-down:before{content:"\\f820"}.icon-sort-numeric-down-alt:before{content:"\\f821"}.icon-sort-numeric-down:before{content:"\\f822"}.icon-sort-numeric-up-alt:before{content:"\\f823"}.icon-sort-numeric-up:before{content:"\\f824"}.icon-sort-shapes-down-alt:before{content:"\\f825"}.icon-sort-shapes-down:before{content:"\\f826"}.icon-sort-shapes-up-alt:before{content:"\\f827"}.icon-sort-shapes-up:before{content:"\\f828"}.icon-sort-size-down-alt:before{content:"\\f829"}.icon-sort-size-down:before{content:"\\f82a"}.icon-sort-size-up-alt:before{content:"\\f82b"}.icon-sort-size-up:before{content:"\\f82c"}.icon-sort-up:before{content:"\\f82d"}.icon-sort:before{content:"\\f82e"}.icon-spell-check:before{content:"\\f82f"}.icon-spinner-third:before{content:"\\f830"}.icon-spinner:before{content:"\\f831"}.icon-split:before{content:"\\f832"}.icon-splotch:before{content:"\\f833"}.icon-square-a-lock:before{content:"\\f834"}.icon-square-ampersand:before{content:"\\f835"}.icon-square-arrow-down-left:before{content:"\\f836"}.icon-square-arrow-down-right:before{content:"\\f837"}.icon-square-arrow-down:before{content:"\\f838"}.icon-square-arrow-left:before{content:"\\f839"}.icon-square-arrow-right:before{content:"\\f83a"}.icon-square-arrow-up-left:before{content:"\\f83b"}.icon-square-arrow-up-right:before{content:"\\f83c"}.icon-square-arrow-up:before{content:"\\f83d"}.icon-square-bolt:before{content:"\\f83e"}.icon-square-caret-down:before{content:"\\f83f"}.icon-square-caret-left:before{content:"\\f840"}.icon-square-caret-right:before{content:"\\f841"}.icon-square-caret-up:before{content:"\\f842"}.icon-square-check:before{content:"\\f843"}.icon-square-chevron-down:before{content:"\\f844"}.icon-square-chevron-left:before{content:"\\f845"}.icon-square-chevron-right:before{content:"\\f846"}.icon-square-chevron-up:before{content:"\\f847"}.icon-square-code:before{content:"\\f848"}.icon-square-dashed:before{content:"\\f849"}.icon-square-divide:before{content:"\\f84a"}.icon-square-dollar:before{content:"\\f84b"}.icon-square-down-left:before{content:"\\f84c"}.icon-square-down-right:before{content:"\\f84d"}.icon-square-down:before{content:"\\f84e"}.icon-square-ellipsis-vertical:before{content:"\\f84f"}.icon-square-ellipsis:before{content:"\\f850"}.icon-square-envelope:before{content:"\\f851"}.icon-square-exclamation:before{content:"\\f852"}.icon-square-fragile:before{content:"\\f853"}.icon-square-full:before{content:"\\f854"}.icon-square-info:before{content:"\\f855"}.icon-square-kanban:before{content:"\\f856"}.icon-square-left:before{content:"\\f857"}.icon-square-list:before{content:"\\f858"}.icon-square-minus:before{content:"\\f859"}.icon-square-nfi:before{content:"\\f85a"}.icon-square-parking-slash:before{content:"\\f85b"}.icon-square-parking:before{content:"\\f85c"}.icon-square-pen:before{content:"\\f85d"}.icon-square-person-confined:before{content:"\\f85e"}.icon-square-phone-flip:before{content:"\\f85f"}.icon-square-phone-hangup:before{content:"\\f860"}.icon-square-phone:before{content:"\\f861"}.icon-square-plus:before{content:"\\f862"}.icon-square-poll-horizontal:before{content:"\\f863"}.icon-square-poll-vertical:before{content:"\\f864"}.icon-square-quarters:before{content:"\\f865"}.icon-square-question:before{content:"\\f866"}.icon-square-quote:before{content:"\\f867"}.icon-square-right:before{content:"\\f868"}.icon-square-ring:before{content:"\\f869"}.icon-square-root-alt:before{content:"\\f86a"}.icon-square-root-variable:before{content:"\\f86b"}.icon-square-root:before{content:"\\f86c"}.icon-square-rss:before{content:"\\f86d"}.icon-square-share-nodes:before{content:"\\f86e"}.icon-square-sliders-vertical:before{content:"\\f86f"}.icon-square-sliders:before{content:"\\f870"}.icon-square-small:before{content:"\\f871"}.icon-square-star:before{content:"\\f872"}.icon-square-t:before{content:"\\f873"}.icon-square-terminal:before{content:"\\f874"}.icon-square-this-way-up:before{content:"\\f875"}.icon-square-up-left:before{content:"\\f876"}.icon-square-up-right:before{content:"\\f877"}.icon-square-up:before{content:"\\f878"}.icon-square-user:before{content:"\\f879"}.icon-square-virus:before{content:"\\f87a"}.icon-square-xmark:before{content:"\\f87b"}.icon-square:before{content:"\\f87c"}.icon-stairs:before{content:"\\f87d"}.icon-stamp:before{content:"\\f87e"}.icon-standard-definition:before{content:"\\f87f"}.icon-star-exclamation:before{content:"\\f880"}.icon-star-half-alt:before{content:"\\f881"}.icon-star-half-stroke:before{content:"\\f882"}.icon-star-half:before{content:"\\f883"}.icon-star-sharp-half-stroke:before{content:"\\f884"}.icon-star-sharp-half:before{content:"\\f885"}.icon-star-sharp:before{content:"\\f886"}.icon-star-shooting:before{content:"\\f887"}.icon-star:before{content:"\\f888"}.icon-stars:before{content:"\\f889"}.icon-step-backward:before{content:"\\f88a"}.icon-step-forward:before{content:"\\f88b"}.icon-stethoscope:before{content:"\\f88c"}.icon-sticky-note:before{content:"\\f88d"}.icon-stop-circle:before{content:"\\f88e"}.icon-stop:before{content:"\\f88f"}.icon-stopwatch-20:before{content:"\\f890"}.icon-stopwatch:before{content:"\\f891"}.icon-store-alt:before{content:"\\f892"}.icon-store-lock:before{content:"\\f893"}.icon-store-slash:before{content:"\\f894"}.icon-store:before{content:"\\f895"}.icon-stream:before{content:"\\f896"}.icon-street-view:before{content:"\\f897"}.icon-stretcher:before{content:"\\f898"}.icon-strikethrough:before{content:"\\f899"}.icon-subscript:before{content:"\\f89a"}.icon-sun-bright:before{content:"\\f89b"}.icon-superscript:before{content:"\\f89c"}.icon-surprise:before{content:"\\f89d"}.icon-swatchbook:before{content:"\\f89e"}.icon-swords:before{content:"\\f89f"}.icon-symbols:before{content:"\\f8a0"}.icon-sync-alt:before{content:"\\f8a1"}.icon-sync:before{content:"\\f8a2"}.icon-table-cells-large:before{content:"\\f8a3"}.icon-table-cells:before{content:"\\f8a4"}.icon-table-columns:before{content:"\\f8a5"}.icon-table-layout:before{content:"\\f8a6"}.icon-table-list:before{content:"\\f8a7"}.icon-table-picnic:before{content:"\\f8a8"}.icon-table-pivot:before{content:"\\f8a9"}.icon-table-rows:before{content:"\\f8aa"}.icon-table-tree:before{content:"\\f8ab"}.icon-table:before{content:"\\f8ac"}.icon-tablet-alt:before{content:"\\f8ad"}.icon-tablet-android-alt:before{content:"\\f8ae"}.icon-tablet-android:before{content:"\\f8af"}.icon-tablet-button:before{content:"\\f8b0"}.icon-tablet-rugged:before{content:"\\f8b1"}.icon-tablet-screen-button:before{content:"\\f8b2"}.icon-tablet-screen:before{content:"\\f8b3"}.icon-tablet:before{content:"\\f8b4"}.icon-tablets:before{content:"\\f8b5"}.icon-tachograph-digital:before{content:"\\f8b6"}.icon-tachometer-alt-average:before{content:"\\f8b7"}.icon-tachometer-alt-fast:before{content:"\\f8b8"}.icon-tachometer-alt-fastest:before{content:"\\f8b9"}.icon-tachometer-alt-slow:before{content:"\\f8ba"}.icon-tachometer-alt-slowest:before{content:"\\f8bb"}.icon-tachometer-alt:before{content:"\\f8bc"}.icon-tachometer-average:before{content:"\\f8bd"}.icon-tachometer-fast:before{content:"\\f8be"}.icon-tachometer-fastest:before{content:"\\f8bf"}.icon-tachometer-slow:before{content:"\\f8c0"}.icon-tachometer-slowest:before{content:"\\f8c1"}.icon-tachometer:before{content:"\\f8c2"}.icon-tag:before{content:"\\f8c3"}.icon-tags:before{content:"\\f8c4"}.icon-tally-1:before{content:"\\f8c5"}.icon-tally-2:before{content:"\\f8c6"}.icon-tally-3:before{content:"\\f8c7"}.icon-tally-4:before{content:"\\f8c8"}.icon-tally:before{content:"\\f8c9"}.icon-tarp-droplet:before{content:"\\f8ca"}.icon-tarp:before{content:"\\f8cb"}.icon-tasks-alt:before{content:"\\f8cc"}.icon-tasks:before{content:"\\f8cd"}.icon-terminal:before{content:"\\f8ce"}.icon-text-height:before{content:"\\f8cf"}.icon-text-size:before{content:"\\f8d0"}.icon-text-slash:before{content:"\\f8d1"}.icon-text-width:before{content:"\\f8d2"}.icon-text:before{content:"\\f8d3"}.icon-th-large:before{content:"\\f8d4"}.icon-th-list:before{content:"\\f8d5"}.icon-th:before{content:"\\f8d6"}.icon-thermometer-empty:before{content:"\\f8d7"}.icon-thermometer-full:before{content:"\\f8d8"}.icon-thermometer-half:before{content:"\\f8d9"}.icon-thermometer-quarter:before{content:"\\f8da"}.icon-thermometer-three-quarters:before{content:"\\f8db"}.icon-thermometer:before{content:"\\f8dc"}.icon-theta:before{content:"\\f8dd"}.icon-thought-bubble:before{content:"\\f8de"}.icon-thumbs-down:before{content:"\\f8df"}.icon-thumbs-up:before{content:"\\f8e0"}.icon-thumbtack:before{content:"\\f8e1"}.icon-tick:before{content:"\\f8e2"}.icon-ticket-airline:before{content:"\\f8e3"}.icon-ticket-alt:before{content:"\\f8e4"}.icon-ticket-simple:before{content:"\\f8e5"}.icon-ticket:before{content:"\\f8e6"}.icon-tickets-airline:before{content:"\\f8e7"}.icon-tilde:before{content:"\\f8e8"}.icon-timeline-arrow:before{content:"\\f8e9"}.icon-timeline:before{content:"\\f8ea"}.icon-timer:before{content:"\\f8eb"}.icon-times-circle:before{content:"\\f8ec"}.icon-times-hexagon:before{content:"\\f8ed"}.icon-times-octagon:before{content:"\\f8ee"}.icon-times-square:before{content:"\\f8ef"}.icon-times:before{content:"\\f8f0"}.icon-tint-slash:before{content:"\\f8f1"}.icon-tint:before{content:"\\f8f2"}.icon-toggle-off:before{content:"\\f8f3"}.icon-toggle-on:before{content:"\\f8f4"}.icon-toolbox:before{content:"\\f8f5"}.icon-tools:before{content:"\\f8f6"}.icon-tower-broadcast:before{content:"\\f8f7"}.icon-tower-cell:before{content:"\\f8f8"}.icon-tower-control:before{content:"\\f8f9"}.icon-tower-observation:before{content:"\\f8fa"}.icon-trademark:before{content:"\\f8fb"}.icon-traffic-cone:before{content:"\\f8fc"}.icon-traffic-light-go:before{content:"\\f8fd"}.icon-traffic-light-slow:before{content:"\\f8fe"}.icon-traffic-light-stop:before{content:"\\f8ff"}.icon-traffic-light:before{content:"\\f900"}.icon-trailer:before{content:"\\f901"}.icon-train-subway-tunnel:before{content:"\\f902"}.icon-train-subway:before{content:"\\f903"}.icon-train-track:before{content:"\\f904"}.icon-train-tram:before{content:"\\f905"}.icon-train-tunnel:before{content:"\\f906"}.icon-train:before{content:"\\f907"}.icon-tram:before{content:"\\f908"}.icon-transformer-bolt:before{content:"\\f909"}.icon-trash-alt:before{content:"\\f90a"}.icon-trash-arrow-up:before{content:"\\f90b"}.icon-trash-can-arrow-up:before{content:"\\f90c"}.icon-trash-can-check:before{content:"\\f90d"}.icon-trash-can-clock:before{content:"\\f90e"}.icon-trash-can-list:before{content:"\\f90f"}.icon-trash-can-plus:before{content:"\\f910"}.icon-trash-can-slash:before{content:"\\f911"}.icon-trash-can-undo:before{content:"\\f912"}.icon-trash-can-xmark:before{content:"\\f913"}.icon-trash-can:before{content:"\\f914"}.icon-trash-check:before{content:"\\f915"}.icon-trash-clock:before{content:"\\f916"}.icon-trash-list:before{content:"\\f917"}.icon-trash-plus:before{content:"\\f918"}.icon-trash-restore-alt:before{content:"\\f919"}.icon-trash-restore:before{content:"\\f91a"}.icon-trash-slash:before{content:"\\f91b"}.icon-trash-undo-alt:before{content:"\\f91c"}.icon-trash-undo:before{content:"\\f91d"}.icon-trash-xmark:before{content:"\\f91e"}.icon-trash:before{content:"\\f91f"}.icon-treasure-chest:before{content:"\\f920"}.icon-tree-alt:before{content:"\\f921"}.icon-tree-city:before{content:"\\f922"}.icon-triangle-exclamation:before{content:"\\f923"}.icon-triangle-instrument:before{content:"\\f924"}.icon-triangle-music:before{content:"\\f925"}.icon-triangle-person-digging:before{content:"\\f926"}.icon-triangle:before{content:"\\f927"}.icon-trillium:before{content:"\\f928"}.icon-trophy-alt:before{content:"\\f929"}.icon-trophy-star:before{content:"\\f92a"}.icon-trophy:before{content:"\\f92b"}.icon-trowel-bricks:before{content:"\\f92c"}.icon-trowel:before{content:"\\f92d"}.icon-truck-arrow-right:before{content:"\\f92e"}.icon-truck-bolt:before{content:"\\f92f"}.icon-truck-clock:before{content:"\\f930"}.icon-truck-container-empty:before{content:"\\f931"}.icon-truck-container:before{content:"\\f932"}.icon-truck-couch:before{content:"\\f933"}.icon-truck-droplet:before{content:"\\f934"}.icon-truck-fast:before{content:"\\f935"}.icon-truck-field-un:before{content:"\\f936"}.icon-truck-field:before{content:"\\f937"}.icon-truck-flatbed:before{content:"\\f938"}.icon-truck-front:before{content:"\\f939"}.icon-truck-loading:before{content:"\\f93a"}.icon-truck-medical:before{content:"\\f93b"}.icon-truck-monster:before{content:"\\f93c"}.icon-truck-moving:before{content:"\\f93d"}.icon-truck-pickup:before{content:"\\f93e"}.icon-truck-plane:before{content:"\\f93f"}.icon-truck-plow:before{content:"\\f940"}.icon-truck-ramp-box:before{content:"\\f941"}.icon-truck-ramp-couch:before{content:"\\f942"}.icon-truck-ramp:before{content:"\\f943"}.icon-truck-tow:before{content:"\\f944"}.icon-truck:before{content:"\\f945"}.icon-tty-answer:before{content:"\\f946"}.icon-tty:before{content:"\\f947"}.icon-turn-down-left:before{content:"\\f948"}.icon-turn-down-right:before{content:"\\f949"}.icon-turn-down:before{content:"\\f94a"}.icon-turn-up:before{content:"\\f94b"}.icon-turntable:before{content:"\\f94c"}.icon-tv-alt:before{content:"\\f94d"}.icon-tv-music:before{content:"\\f94e"}.icon-tv-retro:before{content:"\\f94f"}.icon-tv:before{content:"\\f950"}.icon-typewriter:before{content:"\\f951"}.icon-underline:before{content:"\\f952"}.icon-undo-alt:before{content:"\\f953"}.icon-undo:before{content:"\\f954"}.icon-universal-access:before{content:"\\f955"}.icon-university:before{content:"\\f956"}.icon-unlink:before{content:"\\f957"}.icon-unlock-alt:before{content:"\\f958"}.icon-unlock-keyhole:before{content:"\\f959"}.icon-unlock:before{content:"\\f95a"}.icon-up-down-left-right:before{content:"\\f95b"}.icon-up-down:before{content:"\\f95c"}.icon-up-from-bracket:before{content:"\\f95d"}.icon-up-from-dotted-line:before{content:"\\f95e"}.icon-up-from-line:before{content:"\\f95f"}.icon-up-left:before{content:"\\f960"}.icon-up-long:before{content:"\\f961"}.icon-up-right-and-down-left-from-center:before{content:"\\f962"}.icon-up-right-from-square:before{content:"\\f963"}.icon-up-right:before{content:"\\f964"}.icon-up-to-dotted-line:before{content:"\\f965"}.icon-up-to-line:before{content:"\\f966"}.icon-up:before{content:"\\f967"}.icon-upload:before{content:"\\f968"}.icon-usb-drive:before{content:"\\f969"}.icon-usd-circle:before{content:"\\f96a"}.icon-usd-square:before{content:"\\f96b"}.icon-user-alien:before{content:"\\f96c"}.icon-user-alt-slash:before{content:"\\f96d"}.icon-user-alt:before{content:"\\f96e"}.icon-user-astronaut:before{content:"\\f96f"}.icon-user-bounty-hunter:before{content:"\\f970"}.icon-user-chart:before{content:"\\f971"}.icon-user-check:before{content:"\\f972"}.icon-user-chef:before{content:"\\f973"}.icon-user-circle:before{content:"\\f974"}.icon-user-clock:before{content:"\\f975"}.icon-user-cog:before{content:"\\f976"}.icon-user-cowboy:before{content:"\\f977"}.icon-user-crown:before{content:"\\f978"}.icon-user-doctor-hair-long:before{content:"\\f979"}.icon-user-doctor-hair:before{content:"\\f97a"}.icon-user-doctor-message:before{content:"\\f97b"}.icon-user-doctor:before{content:"\\f97c"}.icon-user-edit:before{content:"\\f97d"}.icon-user-friends:before{content:"\\f97e"}.icon-user-gear:before{content:"\\f97f"}.icon-user-graduate:before{content:"\\f980"}.icon-user-group-crown:before{content:"\\f981"}.icon-user-group:before{content:"\\f982"}.icon-user-hair-buns:before{content:"\\f983"}.icon-user-hair-long:before{content:"\\f984"}.icon-user-hair-mullet:before{content:"\\f985"}.icon-user-hair:before{content:"\\f986"}.icon-user-hard-hat:before{content:"\\f987"}.icon-user-headset:before{content:"\\f988"}.icon-user-helmet-safety:before{content:"\\f989"}.icon-user-injured:before{content:"\\f98a"}.icon-user-large-slash:before{content:"\\f98b"}.icon-user-large:before{content:"\\f98c"}.icon-user-lock:before{content:"\\f98d"}.icon-user-md-chat:before{content:"\\f98e"}.icon-user-md:before{content:"\\f98f"}.icon-user-minus:before{content:"\\f990"}.icon-user-music:before{content:"\\f991"}.icon-user-ninja:before{content:"\\f992"}.icon-user-nurse-hair-long:before{content:"\\f993"}.icon-user-nurse-hair:before{content:"\\f994"}.icon-user-nurse:before{content:"\\f995"}.icon-user-pen:before{content:"\\f996"}.icon-user-pilot-tie:before{content:"\\f997"}.icon-user-pilot:before{content:"\\f998"}.icon-user-plus:before{content:"\\f999"}.icon-user-police-tie:before{content:"\\f99a"}.icon-user-police:before{content:"\\f99b"}.icon-user-robot-xmarks:before{content:"\\f99c"}.icon-user-robot:before{content:"\\f99d"}.icon-user-secret:before{content:"\\f99e"}.icon-user-shakespeare:before{content:"\\f99f"}.icon-user-shield:before{content:"\\f9a0"}.icon-user-slash:before{content:"\\f9a1"}.icon-user-tag:before{content:"\\f9a2"}.icon-user-tie-hair-long:before{content:"\\f9a3"}.icon-user-tie-hair:before{content:"\\f9a4"}.icon-user-tie:before{content:"\\f9a5"}.icon-user-times:before{content:"\\f9a6"}.icon-user-unlock:before{content:"\\f9a7"}.icon-user-visor:before{content:"\\f9a8"}.icon-user-vneck-hair-long:before{content:"\\f9a9"}.icon-user-vneck-hair:before{content:"\\f9aa"}.icon-user-vneck:before{content:"\\f9ab"}.icon-user-xmark:before{content:"\\f9ac"}.icon-user:before{content:"\\f9ad"}.icon-users-between-lines:before{content:"\\f9ae"}.icon-users-class:before{content:"\\f9af"}.icon-users-cog:before{content:"\\f9b0"}.icon-users-crown:before{content:"\\f9b1"}.icon-users-gear:before{content:"\\f9b2"}.icon-users-line:before{content:"\\f9b3"}.icon-users-medical:before{content:"\\f9b4"}.icon-users-rays:before{content:"\\f9b5"}.icon-users-rectangle:before{content:"\\f9b6"}.icon-users-slash:before{content:"\\f9b7"}.icon-users-viewfinder:before{content:"\\f9b8"}.icon-users:before{content:"\\f9b9"}.icon-v:before{content:"\\f9ba"}.icon-vacuum-robot:before{content:"\\f9bb"}.icon-value-absolute:before{content:"\\f9bc"}.icon-van-shuttle:before{content:"\\f9bd"}.icon-vault:before{content:"\\f9be"}.icon-vector-circle:before{content:"\\f9bf"}.icon-vector-polygon:before{content:"\\f9c0"}.icon-vector-square:before{content:"\\f9c1"}.icon-vent-damper:before{content:"\\f9c2"}.icon-vest-patches:before{content:"\\f9c3"}.icon-vest:before{content:"\\f9c4"}.icon-vhs:before{content:"\\f9c5"}.icon-vial-circle-check:before{content:"\\f9c6"}.icon-vial-virus:before{content:"\\f9c7"}.icon-vial:before{content:"\\f9c8"}.icon-vials:before{content:"\\f9c9"}.icon-video-arrow-down-left:before{content:"\\f9ca"}.icon-video-arrow-up-right:before{content:"\\f9cb"}.icon-video-plus:before{content:"\\f9cc"}.icon-video-slash:before{content:"\\f9cd"}.icon-video:before{content:"\\f9ce"}.icon-volume-down:before{content:"\\f9cf"}.icon-volume-high:before{content:"\\f9d0"}.icon-volume-low:before{content:"\\f9d1"}.icon-volume-mute:before{content:"\\f9d2"}.icon-volume-off:before{content:"\\f9d3"}.icon-volume-slash:before{content:"\\f9d4"}.icon-volume-up:before{content:"\\f9d5"}.icon-volume-xmark:before{content:"\\f9d6"}.icon-volume:before{content:"\\f9d7"}.icon-vote-nay:before{content:"\\f9d8"}.icon-vote-yea:before{content:"\\f9d9"}.icon-vr-cardboard:before{content:"\\f9da"}.icon-walking:before{content:"\\f9db"}.icon-wallet:before{content:"\\f9dc"}.icon-wand-magic-sparkles:before{content:"\\f9dd"}.icon-wand-magic:before{content:"\\f9de"}.icon-wand-sparkles:before{content:"\\f9df"}.icon-warehouse-alt:before{content:"\\f9e0"}.icon-warehouse-full:before{content:"\\f9e1"}.icon-warehouse:before{content:"\\f9e2"}.icon-watch-apple:before{content:"\\f9e3"}.icon-watch-calculator:before{content:"\\f9e4"}.icon-watch-fitness:before{content:"\\f9e5"}.icon-watch-smart:before{content:"\\f9e6"}.icon-watch:before{content:"\\f9e7"}.icon-water-arrow-down:before{content:"\\f9e8"}.icon-water-arrow-up:before{content:"\\f9e9"}.icon-water-ladder:before{content:"\\f9ea"}.icon-water-lower:before{content:"\\f9eb"}.icon-water-rise:before{content:"\\f9ec"}.icon-water:before{content:"\\f9ed"}.icon-wave-pulse:before{content:"\\f9ee"}.icon-wave-sine:before{content:"\\f9ef"}.icon-wave-square:before{content:"\\f9f0"}.icon-wave-triangle:before{content:"\\f9f1"}.icon-waveform-lines:before{content:"\\f9f2"}.icon-waveform-path:before{content:"\\f9f3"}.icon-waveform:before{content:"\\f9f4"}.icon-webcam-slash:before{content:"\\f9f5"}.icon-webcam:before{content:"\\f9f6"}.icon-weight-hanging:before{content:"\\f9f7"}.icon-weight-scale:before{content:"\\f9f8"}.icon-weight:before{content:"\\f9f9"}.icon-wheelchair:before{content:"\\f9fa"}.icon-widgets:before{content:"\\f9fb"}.icon-wifi-1:before{content:"\\f9fc"}.icon-wifi-2:before{content:"\\f9fd"}.icon-wifi-exclamation:before{content:"\\f9fe"}.icon-wifi-fair:before{content:"\\f9ff"}.icon-wifi-slash:before{content:"\\fa00"}.icon-wifi-weak:before{content:"\\fa01"}.icon-wifi:before{content:"\\fa02"}.icon-wind-warning:before{content:"\\fa03"}.icon-wind:before{content:"\\fa04"}.icon-window-alt:before{content:"\\fa05"}.icon-window-close:before{content:"\\fa06"}.icon-window-flip:before{content:"\\fa07"}.icon-window-frame-open:before{content:"\\fa08"}.icon-window-frame:before{content:"\\fa09"}.icon-window-maximize:before{content:"\\fa0a"}.icon-window-minimize:before{content:"\\fa0b"}.icon-window-restore:before{content:"\\fa0c"}.icon-window:before{content:"\\fa0d"}.icon-wreath:before{content:"\\fa0e"}.icon-wrench-simple:before{content:"\\fa0f"}.icon-wrench:before{content:"\\fa10"}.icon-x:before{content:"\\fa11"}.icon-xmark-large:before{content:"\\fa12"}.icon-xmark-to-slot:before{content:"\\fa13"}.icon-xmark:before{content:"\\fa14"}.icon-xmarks-lines:before{content:"\\fa15"}@font-face{font-family:'ME Icons Brands';src:url('/me-icons-brands.eot?v=3.5.8');src:url('/me-icons-brands.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-brands.woff?v=3.5.8') format('woff'),url('/me-icons-brands.woff2?v=3.5.8') format('woff2'),url('/me-icons-brands.ttf?v=3.5.8') format('truetype'),url('/me-icons-brands.svg?v=3.5.8#me-icons-brands') format('svg');font-weight:400;font-style:normal}.me-icon-b{font-family:'ME Icons Brands'}.icon-42-group:before{content:"\\f101"}.icon-500px:before{content:"\\f102"}.icon-accessible-icon:before{content:"\\f103"}.icon-accusoft:before{content:"\\f104"}.icon-acquisitions-incorporated:before{content:"\\f105"}.icon-adn:before{content:"\\f106"}.icon-adobe:before{content:"\\f107"}.icon-adversal:before{content:"\\f108"}.icon-affiliatetheme:before{content:"\\f109"}.icon-airbnb:before{content:"\\f10a"}.icon-algolia:before{content:"\\f10b"}.icon-alipay:before{content:"\\f10c"}.icon-amazon-pay:before{content:"\\f10d"}.icon-amazon:before{content:"\\f10e"}.icon-amilia:before{content:"\\f10f"}.icon-android:before{content:"\\f110"}.icon-angellist:before{content:"\\f111"}.icon-angrycreative:before{content:"\\f112"}.icon-angular:before{content:"\\f113"}.icon-app-store-ios:before{content:"\\f114"}.icon-app-store:before{content:"\\f115"}.icon-apper:before{content:"\\f116"}.icon-apple-pay:before{content:"\\f117"}.icon-apple:before{content:"\\f118"}.icon-artstation:before{content:"\\f119"}.icon-asymmetrik:before{content:"\\f11a"}.icon-atlassian:before{content:"\\f11b"}.icon-audible:before{content:"\\f11c"}.icon-autoprefixer:before{content:"\\f11d"}.icon-avianex:before{content:"\\f11e"}.icon-aviato:before{content:"\\f11f"}.icon-aws:before{content:"\\f120"}.icon-bandcamp:before{content:"\\f121"}.icon-battle-net:before{content:"\\f122"}.icon-behance-square:before{content:"\\f123"}.icon-behance:before{content:"\\f124"}.icon-bilibili:before{content:"\\f125"}.icon-bimobject:before{content:"\\f126"}.icon-bitbucket:before{content:"\\f127"}.icon-bitcoin:before{content:"\\f128"}.icon-bity:before{content:"\\f129"}.icon-black-tie:before{content:"\\f12a"}.icon-blackberry:before{content:"\\f12b"}.icon-blogger-b:before{content:"\\f12c"}.icon-blogger:before{content:"\\f12d"}.icon-bluetooth-b:before{content:"\\f12e"}.icon-bluetooth:before{content:"\\f12f"}.icon-bootstrap:before{content:"\\f130"}.icon-bots:before{content:"\\f131"}.icon-bridgestone:before{content:"\\f132"}.icon-btc:before{content:"\\f133"}.icon-buffer:before{content:"\\f134"}.icon-buromobelexperte:before{content:"\\f135"}.icon-buy-n-large:before{content:"\\f136"}.icon-buysellads:before{content:"\\f137"}.icon-canadian-maple-leaf:before{content:"\\f138"}.icon-cc-amazon-pay:before{content:"\\f139"}.icon-cc-amex:before{content:"\\f13a"}.icon-cc-apple-pay:before{content:"\\f13b"}.icon-cc-diners-club:before{content:"\\f13c"}.icon-cc-discover:before{content:"\\f13d"}.icon-cc-jcb:before{content:"\\f13e"}.icon-cc-mastercard:before{content:"\\f13f"}.icon-cc-paypal:before{content:"\\f140"}.icon-cc-stripe:before{content:"\\f141"}.icon-cc-visa:before{content:"\\f142"}.icon-centercode:before{content:"\\f143"}.icon-centos:before{content:"\\f144"}.icon-chrome:before{content:"\\f145"}.icon-chromecast:before{content:"\\f146"}.icon-cloudflare:before{content:"\\f147"}.icon-cloudscale:before{content:"\\f148"}.icon-cloudsmith:before{content:"\\f149"}.icon-cloudversify:before{content:"\\f14a"}.icon-cmplid:before{content:"\\f14b"}.icon-codepen:before{content:"\\f14c"}.icon-codiepie:before{content:"\\f14d"}.icon-confluence:before{content:"\\f14e"}.icon-connectdevelop:before{content:"\\f14f"}.icon-contao:before{content:"\\f150"}.icon-cotton-bureau:before{content:"\\f151"}.icon-cpanel:before{content:"\\f152"}.icon-creative-commons-by:before{content:"\\f153"}.icon-creative-commons-nc-eu:before{content:"\\f154"}.icon-creative-commons-nc-jp:before{content:"\\f155"}.icon-creative-commons-nc:before{content:"\\f156"}.icon-creative-commons-nd:before{content:"\\f157"}.icon-creative-commons-pd-alt:before{content:"\\f158"}.icon-creative-commons-pd:before{content:"\\f159"}.icon-creative-commons-remix:before{content:"\\f15a"}.icon-creative-commons-sa:before{content:"\\f15b"}.icon-creative-commons-sampling-plus:before{content:"\\f15c"}.icon-creative-commons-sampling:before{content:"\\f15d"}.icon-creative-commons-share:before{content:"\\f15e"}.icon-creative-commons-zero:before{content:"\\f15f"}.icon-creative-commons:before{content:"\\f160"}.icon-critical-role:before{content:"\\f161"}.icon-css3-alt:before{content:"\\f162"}.icon-css3:before{content:"\\f163"}.icon-cuttlefish:before{content:"\\f164"}.icon-d-and-d-beyond:before{content:"\\f165"}.icon-d-and-d:before{content:"\\f166"}.icon-dailymotion:before{content:"\\f167"}.icon-dashcube:before{content:"\\f168"}.icon-deezer:before{content:"\\f169"}.icon-delicious:before{content:"\\f16a"}.icon-deploydog:before{content:"\\f16b"}.icon-deskpro:before{content:"\\f16c"}.icon-dev:before{content:"\\f16d"}.icon-deviantart:before{content:"\\f16e"}.icon-dhl:before{content:"\\f16f"}.icon-diaspora:before{content:"\\f170"}.icon-digg:before{content:"\\f171"}.icon-digital-ocean:before{content:"\\f172"}.icon-discord:before{content:"\\f173"}.icon-discourse:before{content:"\\f174"}.icon-dochub:before{content:"\\f175"}.icon-docker:before{content:"\\f176"}.icon-draft2digital:before{content:"\\f177"}.icon-dribbble-square:before{content:"\\f178"}.icon-dribbble:before{content:"\\f179"}.icon-dropbox:before{content:"\\f17a"}.icon-drupal:before{content:"\\f17b"}.icon-dyalog:before{content:"\\f17c"}.icon-earlybirds:before{content:"\\f17d"}.icon-ebay:before{content:"\\f17e"}.icon-edge-legacy:before{content:"\\f17f"}.icon-edge:before{content:"\\f180"}.icon-elementor:before{content:"\\f181"}.icon-ello:before{content:"\\f182"}.icon-ember:before{content:"\\f183"}.icon-empire:before{content:"\\f184"}.icon-envira:before{content:"\\f185"}.icon-erlang:before{content:"\\f186"}.icon-ethereum:before{content:"\\f187"}.icon-etsy:before{content:"\\f188"}.icon-evernote:before{content:"\\f189"}.icon-expeditedssl:before{content:"\\f18a"}.icon-facebook-f:before{content:"\\f18b"}.icon-facebook-messenger:before{content:"\\f18c"}.icon-facebook-square:before{content:"\\f18d"}.icon-facebook:before{content:"\\f18e"}.icon-fantasy-flight-games:before{content:"\\f18f"}.icon-fedex:before{content:"\\f190"}.icon-fedora:before{content:"\\f191"}.icon-figma:before{content:"\\f192"}.icon-firefox-browser:before{content:"\\f193"}.icon-firefox:before{content:"\\f194"}.icon-first-order-alt:before{content:"\\f195"}.icon-first-order:before{content:"\\f196"}.icon-firstdraft:before{content:"\\f197"}.icon-flickr:before{content:"\\f198"}.icon-flipboard:before{content:"\\f199"}.icon-fly:before{content:"\\f19a"}.icon-font-awesome-alt:before{content:"\\f19b"}.icon-font-awesome-flag:before{content:"\\f19c"}.icon-font-awesome-logo-full:before{content:"\\f19d"}.icon-font-awesome:before{content:"\\f19e"}.icon-fonticons-fi:before{content:"\\f19f"}.icon-fonticons:before{content:"\\f1a0"}.icon-fort-awesome-alt:before{content:"\\f1a1"}.icon-fort-awesome:before{content:"\\f1a2"}.icon-forumbee:before{content:"\\f1a3"}.icon-foursquare:before{content:"\\f1a4"}.icon-free-code-camp:before{content:"\\f1a5"}.icon-freebsd:before{content:"\\f1a6"}.icon-fulcrum:before{content:"\\f1a7"}.icon-galactic-republic:before{content:"\\f1a8"}.icon-galactic-senate:before{content:"\\f1a9"}.icon-get-pocket:before{content:"\\f1aa"}.icon-gg-circle:before{content:"\\f1ab"}.icon-gg:before{content:"\\f1ac"}.icon-git-alt:before{content:"\\f1ad"}.icon-git-square:before{content:"\\f1ae"}.icon-git:before{content:"\\f1af"}.icon-github-alt:before{content:"\\f1b0"}.icon-github-square:before{content:"\\f1b1"}.icon-github:before{content:"\\f1b2"}.icon-gitkraken:before{content:"\\f1b3"}.icon-gitlab:before{content:"\\f1b4"}.icon-gitter:before{content:"\\f1b5"}.icon-glide-g:before{content:"\\f1b6"}.icon-glide:before{content:"\\f1b7"}.icon-gofore:before{content:"\\f1b8"}.icon-golang:before{content:"\\f1b9"}.icon-goodreads-g:before{content:"\\f1ba"}.icon-goodreads:before{content:"\\f1bb"}.icon-google-drive:before{content:"\\f1bc"}.icon-google-pay:before{content:"\\f1bd"}.icon-google-play:before{content:"\\f1be"}.icon-google-plus-g:before{content:"\\f1bf"}.icon-google-plus-square:before{content:"\\f1c0"}.icon-google-plus:before{content:"\\f1c1"}.icon-google-wallet:before{content:"\\f1c2"}.icon-google:before{content:"\\f1c3"}.icon-gratipay:before{content:"\\f1c4"}.icon-grav:before{content:"\\f1c5"}.icon-gripfire:before{content:"\\f1c6"}.icon-grunt:before{content:"\\f1c7"}.icon-guilded:before{content:"\\f1c8"}.icon-gulp:before{content:"\\f1c9"}.icon-hacker-news-square:before{content:"\\f1ca"}.icon-hacker-news:before{content:"\\f1cb"}.icon-hackerrank:before{content:"\\f1cc"}.icon-hashnode:before{content:"\\f1cd"}.icon-hips:before{content:"\\f1ce"}.icon-hire-a-helper:before{content:"\\f1cf"}.icon-hive:before{content:"\\f1d0"}.icon-hooli:before{content:"\\f1d1"}.icon-hornbill:before{content:"\\f1d2"}.icon-hotjar:before{content:"\\f1d3"}.icon-houzz:before{content:"\\f1d4"}.icon-html5:before{content:"\\f1d5"}.icon-hubspot:before{content:"\\f1d6"}.icon-ideal:before{content:"\\f1d7"}.icon-imdb:before{content:"\\f1d8"}.icon-instagram-square:before{content:"\\f1d9"}.icon-instagram:before{content:"\\f1da"}.icon-instalod:before{content:"\\f1db"}.icon-intercom:before{content:"\\f1dc"}.icon-internet-explorer:before{content:"\\f1dd"}.icon-invision:before{content:"\\f1de"}.icon-ioxhost:before{content:"\\f1df"}.icon-itch-io:before{content:"\\f1e0"}.icon-itunes-note:before{content:"\\f1e1"}.icon-itunes:before{content:"\\f1e2"}.icon-java:before{content:"\\f1e3"}.icon-jedi-order:before{content:"\\f1e4"}.icon-jenkins:before{content:"\\f1e5"}.icon-jira:before{content:"\\f1e6"}.icon-joget:before{content:"\\f1e7"}.icon-joomla:before{content:"\\f1e8"}.icon-js-square:before{content:"\\f1e9"}.icon-js:before{content:"\\f1ea"}.icon-jsfiddle:before{content:"\\f1eb"}.icon-kaggle:before{content:"\\f1ec"}.icon-keybase:before{content:"\\f1ed"}.icon-keycdn:before{content:"\\f1ee"}.icon-kickstarter-k:before{content:"\\f1ef"}.icon-kickstarter:before{content:"\\f1f0"}.icon-korvue:before{content:"\\f1f1"}.icon-laravel:before{content:"\\f1f2"}.icon-lastfm-square:before{content:"\\f1f3"}.icon-lastfm:before{content:"\\f1f4"}.icon-leanpub:before{content:"\\f1f5"}.icon-less:before{content:"\\f1f6"}.icon-line:before{content:"\\f1f7"}.icon-linkedin-in:before{content:"\\f1f8"}.icon-linkedin:before{content:"\\f1f9"}.icon-linode:before{content:"\\f1fa"}.icon-linux:before{content:"\\f1fb"}.icon-lyft:before{content:"\\f1fc"}.icon-magento:before{content:"\\f1fd"}.icon-mailchimp:before{content:"\\f1fe"}.icon-mandalorian:before{content:"\\f1ff"}.icon-markdown:before{content:"\\f200"}.icon-mastodon:before{content:"\\f201"}.icon-maxcdn:before{content:"\\f202"}.icon-mdb:before{content:"\\f203"}.icon-me-pulse:before{content:"\\f204"}.icon-me:before{content:"\\f205"}.icon-medapps:before{content:"\\f206"}.icon-medium-m:before{content:"\\f207"}.icon-medium:before{content:"\\f208"}.icon-medrt:before{content:"\\f209"}.icon-meetup:before{content:"\\f20a"}.icon-megaport:before{content:"\\f20b"}.icon-mendeley:before{content:"\\f20c"}.icon-meta:before{content:"\\f20d"}.icon-microblog:before{content:"\\f20e"}.icon-microsoft:before{content:"\\f20f"}.icon-misy:before{content:"\\f210"}.icon-mix:before{content:"\\f211"}.icon-mixcloud:before{content:"\\f212"}.icon-mixer:before{content:"\\f213"}.icon-mizuni:before{content:"\\f214"}.icon-modx:before{content:"\\f215"}.icon-monero:before{content:"\\f216"}.icon-napster:before{content:"\\f217"}.icon-neos:before{content:"\\f218"}.icon-nfc-directional:before{content:"\\f219"}.icon-nfc-symbol:before{content:"\\f21a"}.icon-nimblr:before{content:"\\f21b"}.icon-node-js:before{content:"\\f21c"}.icon-node:before{content:"\\f21d"}.icon-npm:before{content:"\\f21e"}.icon-ns8:before{content:"\\f21f"}.icon-nutritionix:before{content:"\\f220"}.icon-octopus-deploy:before{content:"\\f221"}.icon-odnoklassniki-square:before{content:"\\f222"}.icon-odnoklassniki:before{content:"\\f223"}.icon-office365:before{content:"\\f224"}.icon-old-republic:before{content:"\\f225"}.icon-opencart:before{content:"\\f226"}.icon-openid:before{content:"\\f227"}.icon-opera:before{content:"\\f228"}.icon-optin-monster:before{content:"\\f229"}.icon-orcid:before{content:"\\f22a"}.icon-osi:before{content:"\\f22b"}.icon-padlet:before{content:"\\f22c"}.icon-page4:before{content:"\\f22d"}.icon-pagelines:before{content:"\\f22e"}.icon-palfed:before{content:"\\f22f"}.icon-patreon:before{content:"\\f230"}.icon-paypal:before{content:"\\f231"}.icon-penny-arcade:before{content:"\\f232"}.icon-perbyte:before{content:"\\f233"}.icon-periscope:before{content:"\\f234"}.icon-phabricator:before{content:"\\f235"}.icon-phoenix-framework:before{content:"\\f236"}.icon-phoenix-squadron:before{content:"\\f237"}.icon-php:before{content:"\\f238"}.icon-pied-piper-alt:before{content:"\\f239"}.icon-pied-piper-hat:before{content:"\\f23a"}.icon-pied-piper-pp:before{content:"\\f23b"}.icon-pied-piper-square:before{content:"\\f23c"}.icon-pied-piper:before{content:"\\f23d"}.icon-pinterest-p:before{content:"\\f23e"}.icon-pinterest-square:before{content:"\\f23f"}.icon-pinterest:before{content:"\\f240"}.icon-pix:before{content:"\\f241"}.icon-playstation:before{content:"\\f242"}.icon-product-hunt:before{content:"\\f243"}.icon-pushed:before{content:"\\f244"}.icon-python:before{content:"\\f245"}.icon-qq:before{content:"\\f246"}.icon-quinscape:before{content:"\\f247"}.icon-quora:before{content:"\\f248"}.icon-r-project:before{content:"\\f249"}.icon-raspberry-pi:before{content:"\\f24a"}.icon-ravelry:before{content:"\\f24b"}.icon-react:before{content:"\\f24c"}.icon-reacteurope:before{content:"\\f24d"}.icon-readme:before{content:"\\f24e"}.icon-rebel:before{content:"\\f24f"}.icon-receita:before{content:"\\f250"}.icon-red-river:before{content:"\\f251"}.icon-reddit-alien:before{content:"\\f252"}.icon-reddit-square:before{content:"\\f253"}.icon-reddit:before{content:"\\f254"}.icon-redhat:before{content:"\\f255"}.icon-renren:before{content:"\\f256"}.icon-replyd:before{content:"\\f257"}.icon-researchgate:before{content:"\\f258"}.icon-resolving:before{content:"\\f259"}.icon-rev:before{content:"\\f25a"}.icon-rocketchat:before{content:"\\f25b"}.icon-rockrms:before{content:"\\f25c"}.icon-rust:before{content:"\\f25d"}.icon-safari:before{content:"\\f25e"}.icon-salesforce:before{content:"\\f25f"}.icon-sass:before{content:"\\f260"}.icon-schlix:before{content:"\\f261"}.icon-screenpal:before{content:"\\f262"}.icon-scribd:before{content:"\\f263"}.icon-searchengin:before{content:"\\f264"}.icon-sellcast:before{content:"\\f265"}.icon-sellsy:before{content:"\\f266"}.icon-servicestack:before{content:"\\f267"}.icon-shirtsinbulk:before{content:"\\f268"}.icon-shopify:before{content:"\\f269"}.icon-shopware:before{content:"\\f26a"}.icon-simplybuilt:before{content:"\\f26b"}.icon-sintegra:before{content:"\\f26c"}.icon-sistrix:before{content:"\\f26d"}.icon-sith:before{content:"\\f26e"}.icon-sitrox:before{content:"\\f26f"}.icon-sketch:before{content:"\\f270"}.icon-skyatlas:before{content:"\\f271"}.icon-skype:before{content:"\\f272"}.icon-slack-hash:before{content:"\\f273"}.icon-slack:before{content:"\\f274"}.icon-slideshare:before{content:"\\f275"}.icon-snapchat-ghost:before{content:"\\f276"}.icon-snapchat-square:before{content:"\\f277"}.icon-snapchat:before{content:"\\f278"}.icon-soundcloud:before{content:"\\f279"}.icon-sourcetree:before{content:"\\f27a"}.icon-speakap:before{content:"\\f27b"}.icon-speaker-deck:before{content:"\\f27c"}.icon-spotify:before{content:"\\f27d"}.icon-square-font-awesome-stroke:before{content:"\\f27e"}.icon-square-font-awesome:before{content:"\\f27f"}.icon-squarespace:before{content:"\\f280"}.icon-stack-exchange:before{content:"\\f281"}.icon-stack-overflow:before{content:"\\f282"}.icon-stackpath:before{content:"\\f283"}.icon-staylinked:before{content:"\\f284"}.icon-steam-square:before{content:"\\f285"}.icon-steam-symbol:before{content:"\\f286"}.icon-steam:before{content:"\\f287"}.icon-sticker-mule:before{content:"\\f288"}.icon-strava:before{content:"\\f289"}.icon-stripe-s:before{content:"\\f28a"}.icon-stripe:before{content:"\\f28b"}.icon-studiovinari:before{content:"\\f28c"}.icon-stumbleupon-circle:before{content:"\\f28d"}.icon-stumbleupon:before{content:"\\f28e"}.icon-superpowers:before{content:"\\f28f"}.icon-supple:before{content:"\\f290"}.icon-suse:before{content:"\\f291"}.icon-swift:before{content:"\\f292"}.icon-symfony:before{content:"\\f293"}.icon-teamspeak:before{content:"\\f294"}.icon-telegram-plane:before{content:"\\f295"}.icon-telegram:before{content:"\\f296"}.icon-tencent-weibo:before{content:"\\f297"}.icon-the-red-yeti:before{content:"\\f298"}.icon-themeco:before{content:"\\f299"}.icon-themeisle:before{content:"\\f29a"}.icon-think-peaks:before{content:"\\f29b"}.icon-tiktok:before{content:"\\f29c"}.icon-trade-federation:before{content:"\\f29d"}.icon-trello:before{content:"\\f29e"}.icon-tripadvisor:before{content:"\\f29f"}.icon-tumblr-square:before{content:"\\f2a0"}.icon-tumblr:before{content:"\\f2a1"}.icon-twitch:before{content:"\\f2a2"}.icon-twitter-square:before{content:"\\f2a3"}.icon-twitter:before{content:"\\f2a4"}.icon-typo3:before{content:"\\f2a5"}.icon-uber:before{content:"\\f2a6"}.icon-ubuntu:before{content:"\\f2a7"}.icon-uikit:before{content:"\\f2a8"}.icon-umbraco:before{content:"\\f2a9"}.icon-uncharted:before{content:"\\f2aa"}.icon-uniregistry:before{content:"\\f2ab"}.icon-unity:before{content:"\\f2ac"}.icon-unsplash:before{content:"\\f2ad"}.icon-untappd:before{content:"\\f2ae"}.icon-ups:before{content:"\\f2af"}.icon-usb:before{content:"\\f2b0"}.icon-usps:before{content:"\\f2b1"}.icon-ussunnah:before{content:"\\f2b2"}.icon-vaadin:before{content:"\\f2b3"}.icon-vale:before{content:"\\f2b4"}.icon-viacoin:before{content:"\\f2b5"}.icon-viadeo-square:before{content:"\\f2b6"}.icon-viadeo:before{content:"\\f2b7"}.icon-viber:before{content:"\\f2b8"}.icon-vimeo-square:before{content:"\\f2b9"}.icon-vimeo-v:before{content:"\\f2ba"}.icon-vimeo:before{content:"\\f2bb"}.icon-vine:before{content:"\\f2bc"}.icon-vk:before{content:"\\f2bd"}.icon-vnv:before{content:"\\f2be"}.icon-vuejs:before{content:"\\f2bf"}.icon-watchman-monitoring:before{content:"\\f2c0"}.icon-waze:before{content:"\\f2c1"}.icon-weebly:before{content:"\\f2c2"}.icon-weibo:before{content:"\\f2c3"}.icon-weixin:before{content:"\\f2c4"}.icon-whatsapp-square:before{content:"\\f2c5"}.icon-whatsapp:before{content:"\\f2c6"}.icon-whmcs:before{content:"\\f2c7"}.icon-wikipedia-w:before{content:"\\f2c8"}.icon-windows:before{content:"\\f2c9"}.icon-wirsindhandwerk:before{content:"\\f2ca"}.icon-wix:before{content:"\\f2cb"}.icon-wizards-of-the-coast:before{content:"\\f2cc"}.icon-wodu:before{content:"\\f2cd"}.icon-wolf-pack-battalion:before{content:"\\f2ce"}.icon-wordpress-simple:before{content:"\\f2cf"}.icon-wordpress:before{content:"\\f2d0"}.icon-wpbeginner:before{content:"\\f2d1"}.icon-wpexplorer:before{content:"\\f2d2"}.icon-wpforms:before{content:"\\f2d3"}.icon-wpressr:before{content:"\\f2d4"}.icon-xbox:before{content:"\\f2d5"}.icon-xing-square:before{content:"\\f2d6"}.icon-xing:before{content:"\\f2d7"}.icon-y-combinator:before{content:"\\f2d8"}.icon-yahoo:before{content:"\\f2d9"}.icon-yammer:before{content:"\\f2da"}.icon-yandex-international:before{content:"\\f2db"}.icon-yandex:before{content:"\\f2dc"}.icon-yarn:before{content:"\\f2dd"}.icon-yelp:before{content:"\\f2de"}.icon-yoast:before{content:"\\f2df"}.icon-youtube-square:before{content:"\\f2e0"}.icon-youtube:before{content:"\\f2e1"}.icon-zhihu:before{content:"\\f2e2"}@font-face{font-family:'ME Icons Solid';src:url('/me-icons-solid.eot?v=3.5.8');src:url('/me-icons-solid.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-solid.woff?v=3.5.8') format('woff'),url('/me-icons-solid.woff2?v=3.5.8') format('woff2'),url('/me-icons-solid.ttf?v=3.5.8') format('truetype'),url('/me-icons-solid.svg?v=3.5.8#me-icons-solid') format('svg');font-weight:400;font-style:normal}.me-icon-s{font-family:'ME Icons Solid'}@font-face{font-family:'ME Icons';src:url('/me-icons-regular.eot?v=3.5.8');src:url('/me-icons-regular.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-regular.woff?v=3.5.8') format('woff'),url('/me-icons-regular.woff2?v=3.5.8') format('woff2'),url('/me-icons-regular.ttf?v=3.5.8') format('truetype'),url('/me-icons-regular.svg?v=3.5.8#me-icons-regular') format('svg');font-weight:400;font-style:normal}.me-icon{font-family:'ME Icons'}@font-face{font-family:'ME Icons Light';src:url('/me-icons-light.eot?v=3.5.8');src:url('/me-icons-light.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-light.woff?v=3.5.8') format('woff'),url('/me-icons-light.woff2?v=3.5.8') format('woff2'),url('/me-icons-light.ttf?v=3.5.8') format('truetype'),url('/me-icons-light.svg?v=3.5.8#me-icons-light') format('svg');font-weight:400;font-style:normal}.me-icon-l{font-family:'ME Icons Light'}.me-icon-2xs{font-size:.625rem}.me-icon-xs{font-size:.75rem}.me-icon-sm{font-size:.875rem}.me-icon-md{font-size:1rem}.me-icon-lg{font-size:1.25rem}.me-icon-xl{font-size:1.5rem}.me-icon-2xl{font-size:2rem}.me-icon-spin{-webkit-animation:me-icon-spin 2s infinite linear;animation:me-icon-spin 2s infinite linear}.me-icon-pulse{-webkit-animation:me-icon-spin 1s infinite steps(8);animation:me-icon-spin 1s infinite steps(8)}@-webkit-keyframes me-icon-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes me-icon-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}`;
export {
  useHideOthers as A,
  useBodyScrollLock as B,
  createReusableTemplate as C,
  DropdownMenu as D,
  _sfc_main$8 as E,
  _sfc_main$n as F,
  _sfc_main$l as G,
  HoverCard as H,
  Presence as P,
  _sfc_main$X as _,
  useCollection as a,
  useDirection as b,
  _sfc_main$18 as c,
  getActiveElement as d,
  _sfc_main$Y as e,
  focusFirst as f,
  getFocusIntent as g,
  context as h,
  injectRovingFocusGroupContext as i,
  focusFirst$1 as j,
  getTabbableCandidates as k,
  usePortal as l,
  _sfc_main$17 as m,
  Popover as n,
  useVModel as o,
  portalTargetInjectionKey as p,
  _sfc_main as q,
  _sfc_main$1 as r,
  defaultDocument as s,
  unrefElement as t,
  useId as u,
  meIconStyles as v,
  wrapArray$1 as w,
  _sfc_main$Z as x,
  getOpenState as y,
  _sfc_main$_ as z
};
