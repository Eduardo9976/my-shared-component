/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber$1 = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a2, b) {
  if (a2.length !== b.length) return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a2.length; i2++) {
    equal = looseEqual(a2[i2], b[i2]);
  }
  return equal;
}
function looseEqual(a2, b) {
  if (a2 === b) return true;
  let aValidType = isDate(a2);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a2);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a2 === b;
  }
  aValidType = isArray(a2);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b) : false;
  }
  aValidType = isObject$1(a2);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject$1(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$1(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
};
function normalizeCssVarValue(value) {
  if (value == null) {
    return "initial";
  }
  if (typeof value === "string") {
    return value === "" ? " " : value;
  }
  return String(value);
}
/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i2, l2;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].pause();
        }
      }
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].resume();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      this.effects.length = 0;
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
        removeSub(l2, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    extend$1(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
        addSub(l2);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive$2);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive$2);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x2) => isArray(x2) ? reactiveReadArray(x2) : x2)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive$2(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v2) => v2.map(toReactive$2), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive$2, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive$2, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator2) {
    return reactiveReadArray(this).join(separator2);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive$2);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive$2(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index2) {
        return fn.call(this, toReactive$2(item), index2, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index2) {
        return fn.call(this, item, index2, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, toReactive$2(item), index2, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, item, index2, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$2;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive$2;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive$2;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend$1(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get: get2 } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get: get2 } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive$2 = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive$2(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive$2(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue$2(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get: get2, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get2;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef$2(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$1(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}
/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a, _b;
          return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  return;
}
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b) => getId(a2) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools$1;
let buffer = [];
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount2(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state2,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state2,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state2,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c2 of children) {
      if (c2.type !== Comment) {
        child = c2;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state2,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function useId$1() {
  const i2 = getCurrentInstance();
  if (i2) {
    return (i2.appContext.config.idPrefix || "v") + "-" + i2.ids[0] + i2.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function useTemplateRef(key) {
  const i2 = getCurrentInstance();
  const r = shallowRef(null);
  if (i2) {
    const refs = i2.refs === EMPTY_OBJ ? i2.refs = {} : i2.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  }
  const ret = r;
  return ret;
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else ;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          const cls = content.getAttribute("class");
          if (cls) content.$cls = cls;
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          if (!isMismatchAllowed(
            el,
            1
            /* CHILDREN */
          )) {
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(
            el,
            0
            /* TEXT */
          )) {
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp2(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && isReactive(props.style)) {
          for (const key in props.style) props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l2 = children.length;
    for (let i2 = 0; i2 < l2; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i2 + 1 < l2 && normalizeVNode(children[i2 + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(
          container,
          1
          /* CHILDREN */
        )) {
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(
      node.parentElement,
      1
      /* CHILDREN */
    )) {
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate2, hydrateNode];
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [
    0
    /* TEXT */
  ]: "text",
  [
    1
    /* CHILDREN */
  ]: "children",
  [
    2
    /* CLASS */
  ]: "class",
  [
    3
    /* STYLE */
  ]: "style",
  [
    4
    /* ATTRIBUTE */
  ]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 || allowedType === 1) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 && list.includes("children")) {
      return true;
    }
    return list.includes(MismatchTypeString[allowedType]);
  }
}
const requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate2) => {
  const id = requestIdleCallback(hydrate2, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate2, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate2();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate2();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate2) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate2();
    } else {
      mql.addEventListener("change", hydrate2, { once: true });
      return () => mql.removeEventListener("change", hydrate2);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate2, forEach) => {
  if (isString(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate2();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i2 of interactions) {
        el.removeEventListener(i2, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i2 of interactions) {
      el.addEventListener(i2, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate2) {
      let patched = false;
      (instance.bu || (instance.bu = [])).push(() => patched = true);
      const performHydrate = () => {
        if (patched) {
          return;
        }
        hydrate2();
      };
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : performHydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce: ce2 } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce2;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches$1(include, name));
        exclude && pruneCache((name) => !matches$1(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max: max2 } = props;
      if (include && (!name || !matches$1(include, name)) || exclude && name && matches$1(exclude, name)) {
        vnode.shapeFlag &= -257;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max2 && keys.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches$1(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p2) => matches$1(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= -257;
  vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive$2(source[i2])) : toReactive$2(source[i2]) : source[i2],
        i2,
        void 0,
        cached && cached[i2]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $host: (i2) => i2.ce,
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state2, key) => state2 !== EMPTY_OBJ && !state2.__isScriptSetup && hasOwn(state2, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_2, key) {
    const has = key[0] !== "_" && !isGloballyAllowed(key);
    return has;
  }
});
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults2) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext(calledFunctionName) {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults2) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults2) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults2[key] };
      } else {
        opt.default = defaults2[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults2[key] };
    } else ;
    if (opt && defaults2[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a2, b) {
  if (!a2 || !b) return a2 || b;
  if (isArray(a2) && isArray(b)) return a2.concat(b);
  return extend$1({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$1(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context2 = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context2.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context2,
      _instance: null,
      version: version$1,
      get config() {
        return context2.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context2.mixins.includes(mixin)) {
            context2.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context2.components[name];
        }
        context2.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context2.directives[name];
        }
        context2.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context2;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context2.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index2 = 0; index2 < propType.length; ++index2) {
            const type = propType[index2];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key === "_" || key === "__" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const cacheIndexes = children.__;
    if (cacheIndexes) def(slots, "__", cacheIndexes, true);
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex2;
        if (prevChild.key != null) {
          newIndex2 = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex2 = j;
              break;
            }
          }
        }
        if (newIndex2 === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex2 - s2] = i2 + 1;
          if (newIndex2 >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex2;
          } else {
            moved2 = true;
          }
          patch(
            prevChild,
            c2[newIndex2],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, fallback to el placeholder for unresolved async component
          anchorVNode.el || anchorVNode.placeholder
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved2) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a: a2,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    if (parent && isArray(slotCacheKeys)) {
      slotCacheKeys.forEach((v2) => {
        parent.renderCache[v2] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render2 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++)
      hooks[i2].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function useModel(props, name, options = EMPTY_OBJ) {
  const i2 = getCurrentInstance();
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = customRef((track2, trigger2) => {
    let localValue;
    let prevSetValue = EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
          return;
        }
        const rawProps = i2.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger2();
        }
        i2.emit(`update:${name}`, emittedValue);
        if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
          trigger2();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i22 = 0;
    return {
      next() {
        if (i22 < 2) {
          return { value: i22++ ? modifiers || EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a2) => isString(a2) ? a2.trim() : a2);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber$1);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false) ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c2) => c2 !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key])) setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set) => set(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$1(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  ret.cacheIndex = index2;
  return cache[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev.length; i2++) {
    if (hasChanged(prev[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$1 = "3.5.18";
const warn = NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools = devtools$1;
const setDevtoolsHook = setDevtoolsHook$1;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;
/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is2, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeUpdate(() => {
    queuePostFlushCb(setVars);
  });
  onMounted(() => {
    watch(setVars, NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      const value = normalizeCssVarValue(vars[key]);
      style.setProperty(`--${key}`, value);
      cssText += `--${key}: ${value};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
  if (isPlainObject$1(Comp)) extend$1(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    this._instance = null;
    this._app = null;
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot && !this._resolved) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._mount(this._def);
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._inheritParentContext(parent);
    }
  }
  _inheritParentContext(parent = this._parent) {
    if (parent && this._app) {
      Object.setPrototypeOf(
        this._app._context.provides,
        parent._instance.provides
      );
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      this._resolveProps(def2);
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def2);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then((def2) => {
        def2.configureApp = this._def.configureApp;
        resolve2(this._def = def2, true);
      });
    } else {
      resolve2(this._def);
    }
  }
  _mount(def2) {
    this._app = this._createApp(def2);
    this._inheritParentContext();
    if (def2.configureApp) {
      def2.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        ob && ob.disconnect();
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    const vnode = this._createVNode();
    if (this._app) vnode.appContext = this._app._context;
    render$1(vnode, this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend$1(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject$1(args[0]) ? extend$1({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i2 = styles.length - 1; i2 >= 0; i2--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i2];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i2 = 0; i2 < outlets.length; i2++) {
      const o = outlets[i2];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
function useHost(caller) {
  const instance = getCurrentInstance();
  const el = instance && instance.ce;
  if (el) {
    return el;
  }
  return null;
}
function useShadowRoot() {
  const el = useHost();
  return el && el.shadowRoot;
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state2,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state2, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c2.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
  clone2.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber$1(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber$1(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber$1(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
    const option2 = el.options[i2];
    const optionValue = getValue(option2);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option2.selected = value.some((v2) => String(v2) === String(optionValue));
        } else {
          option2.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option2.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option2), value)) {
      if (el.selectedIndex !== i2) el.selectedIndex = i2;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$1 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
/**
* vue v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const compile = () => {
};
const vue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getCurrentWatcher,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  hydrateOnIdle,
  hydrateOnInteraction,
  hydrateOnMediaQuery,
  hydrateOnVisible,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  onWatcherCleanup,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$1,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef: toRef$2,
  toRefs,
  toValue: toValue$2,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useHost,
  useId: useId$1,
  useModel,
  useSSRContext,
  useShadowRoot,
  useSlots,
  useTemplateRef,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version: version$1,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x: x2,
        y: y2,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const hide = hide$1;
const arrow$1 = arrow$2;
const limitShift = limitShift$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue$1(source) {
  return typeof source === "function" ? source() : unref(source);
}
function arrow(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement(toValue$1(options.element));
      if (element == null) {
        return {};
      }
      return arrow$1({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _toValue;
    return (_toValue = toValue$1(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed(() => toValue$1(options.middleware));
  const placementOption = computed(() => {
    var _toValue2;
    return (_toValue2 = toValue$1(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _toValue3;
    return (_toValue3 = toValue$1(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed(() => {
    var _toValue4;
    return (_toValue4 = toValue$1(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed(() => unwrapElement(reference.value));
  const floatingElement = computed(() => unwrapElement(floating.value));
  const x2 = ref(0);
  const y2 = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x2.value);
    const yVal = roundByDPR(floatingElement.value, y2.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x2.value = position.x;
      y2.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x2),
    y: shallowReadonly(y2),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}
function renderSlotFragments(children) {
  if (!children)
    return [];
  return children.flatMap((child) => {
    if (child.type === Fragment)
      return renderSlotFragments(child.children);
    return [child];
  });
}
const Slot = /* @__PURE__ */ defineComponent({
  name: "PrimitiveSlot",
  inheritAttrs: false,
  setup(_2, { attrs, slots }) {
    return () => {
      if (!slots.default)
        return null;
      const children = renderSlotFragments(slots.default());
      const firstNonCommentChildrenIndex = children.findIndex((child) => child.type !== Comment);
      if (firstNonCommentChildrenIndex === -1)
        return children;
      const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
      delete firstNonCommentChildren.props?.ref;
      const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs, firstNonCommentChildren.props) : attrs;
      const cloned = cloneVNode({ ...firstNonCommentChildren, props: {} }, mergedProps);
      if (children.length === 1)
        return cloned;
      children[firstNonCommentChildrenIndex] = cloned;
      return children;
    };
  }
});
const SELF_CLOSING_TAGS = ["area", "img", "input"];
const Primitive = /* @__PURE__ */ defineComponent({
  name: "Primitive",
  inheritAttrs: false,
  props: {
    asChild: {
      type: Boolean,
      default: false
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(props, { attrs, slots }) {
    const asTag = props.asChild ? "template" : props.as;
    if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag))
      return () => h(asTag, attrs);
    if (asTag !== "template")
      return () => h(props.as, attrs, { default: slots.default });
    return () => h(Slot, attrs, { default: slots.default });
  }
});
function computedEager(fn, options) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a = void 0) != null ? _a : "sync"
  });
  return readonly(result);
}
function tryOnScopeDispose$1(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off2 = (fn) => {
    fns.delete(fn);
  };
  const clear = () => {
    fns.clear();
  };
  const on2 = (fn) => {
    fns.add(fn);
    const offFn = () => off2(fn);
    tryOnScopeDispose$1(offFn);
    return {
      off: offFn
    };
  };
  const trigger2 = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on: on2,
    off: off2,
    trigger: trigger2,
    clear
  };
}
function createGlobalState(stateFactory) {
  let initialized = false;
  let state2;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state2 = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state2;
  };
}
function createSharedComposable$1(composable) {
  let subscribers = 0;
  let state2;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state2 = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!scope) {
      scope = effectScope(true);
      state2 = scope.run(() => composable(...args));
    }
    tryOnScopeDispose$1(dispose);
    return state2;
  };
}
function toReactive$1(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(_2, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value))
        objectRef.value[p2].value = value;
      else
        objectRef.value[p2] = value;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function reactiveComputed$1(fn) {
  return toReactive$1(computed(fn));
}
function reactiveOmit$1(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed$1(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k, v2]) => !predicate(toValue$2(v2), k))) : Object.fromEntries(Object.entries(toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
const isClient$1 = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef$1 = (val) => typeof val !== "undefined";
const toString = Object.prototype.toString;
const isObject = (val) => toString.call(val) === "[object Object]";
const noop$1 = () => {
};
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper$1(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function pausableFilter(extendFilter = bypassFilter, options = {}) {
  const {
    initialState = "active"
  } = options;
  const isActive = toRef$1(initialState === "active");
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function getLifeCycleTarget$1(target) {
  return getCurrentInstance();
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function toRef$1(...args) {
  if (args.length !== 1)
    return toRef$2(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop$1 }))) : ref(r);
}
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track2, trigger2) => {
    let value = toValue$2(defaultValue);
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = toValue$2(defaultValue);
      trigger2();
    }, toValue$2(afterMs));
    tryOnScopeDispose$1(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track2();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger2();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper$1(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    initialState = "active",
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });
  const stop2 = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop: stop2, pause, resume, isActive };
}
function syncRef(left, right, ...[options]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform = {}
  } = options || {};
  const watchers = [];
  const transformLTR = "ltr" in transform && transform.ltr || ((v2) => v2);
  const transformRTL = "rtl" in transform && transform.rtl || ((v2) => v2);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable(
      left,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable(
      right,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop2 = () => {
    watchers.forEach((w) => w.stop());
  };
  return stop2;
}
function tryOnBeforeUnmount(fn, target) {
  const instance = getLifeCycleTarget$1();
  if (instance)
    onBeforeUnmount(fn, target);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue$2(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient$1)
      start();
  }
  tryOnScopeDispose$1(stop2);
  return {
    isPending: readonly(isPending),
    start,
    stop: stop2
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop$1,
    interval,
    options
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
const defaultWindow = isClient$1 ? window : void 0;
function unrefElement$1(elRef) {
  var _a;
  const plain = toValue$2(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue$2(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement$1(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue$2(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue$2(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(cleanup);
  return stop2;
}
function useMounted() {
  const isMounted = shallowRef(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue$2(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef(false);
  const intervalLimit = computed(() => {
    return fpsLimit ? 1e3 / toValue$2(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose$1(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function cloneFnJSON$1(source) {
  return JSON.parse(JSON.stringify(source));
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue$2(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement$1(el)) : [unrefElement$1(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
function useVModel$1(props, key, emit2, options = {}) {
  var _a, _b, _c;
  const {
    clone: clone2 = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone2 ? val : typeof clone2 === "function" ? clone2(val) : cloneFnJSON$1(val);
  const getValue2 = () => isDef$1(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v2) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v2);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v2) => {
        if (!isUpdating && (v2 !== props[key] || deep))
          triggerEmit(v2);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
function createContext(providerComponentName, contextName) {
  const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
  const injectionKey = Symbol(symbolDescription);
  const injectContext = (fallback) => {
    const context2 = inject(injectionKey, fallback);
    if (context2)
      return context2;
    if (context2 === null)
      return context2;
    throw new Error(
      `Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(
        ", "
      )}` : `\`${providerComponentName}\``}`
    );
  };
  const provideContext = (contextValue) => {
    provide(injectionKey, contextValue);
    return contextValue;
  };
  return [injectContext, provideContext];
}
function serialize(o) {
  return typeof o == "string" ? `'${o}'` : new c().serialize(o);
}
const c = /* @__PURE__ */ function() {
  class o {
    #t = /* @__PURE__ */ new Map();
    compare(t, r) {
      const e = typeof t, n = typeof r;
      return e === "string" && n === "string" ? t.localeCompare(r) : e === "number" && n === "number" ? t - r : String.prototype.localeCompare.call(this.serialize(t, true), this.serialize(r, true));
    }
    serialize(t, r) {
      if (t === null) return "null";
      switch (typeof t) {
        case "string":
          return r ? t : `'${t}'`;
        case "bigint":
          return `${t}n`;
        case "object":
          return this.$object(t);
        case "function":
          return this.$function(t);
      }
      return String(t);
    }
    serializeObject(t) {
      const r = Object.prototype.toString.call(t);
      if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), t);
      const e = t.constructor, n = e === Object || e === void 0 ? "" : e.name;
      if (n !== "" && globalThis[n] === e) return this.serializeBuiltInType(n, t);
      if (typeof t.toJSON == "function") {
        const i2 = t.toJSON();
        return n + (i2 !== null && typeof i2 == "object" ? this.$object(i2) : `(${this.serialize(i2)})`);
      }
      return this.serializeObjectEntries(n, Object.entries(t));
    }
    serializeBuiltInType(t, r) {
      const e = this["$" + t];
      if (e) return e.call(this, r);
      if (typeof r?.entries == "function") return this.serializeObjectEntries(t, r.entries());
      throw new Error(`Cannot serialize ${t}`);
    }
    serializeObjectEntries(t, r) {
      const e = Array.from(r).sort((i2, a2) => this.compare(i2[0], a2[0]));
      let n = `${t}{`;
      for (let i2 = 0; i2 < e.length; i2++) {
        const [a2, l2] = e[i2];
        n += `${this.serialize(a2, true)}:${this.serialize(l2)}`, i2 < e.length - 1 && (n += ",");
      }
      return n + "}";
    }
    $object(t) {
      let r = this.#t.get(t);
      return r === void 0 && (this.#t.set(t, `#${this.#t.size}`), r = this.serializeObject(t), this.#t.set(t, r)), r;
    }
    $function(t) {
      const r = Function.prototype.toString.call(t);
      return r.slice(-15) === "[native code] }" ? `${t.name || ""}()[native]` : `${t.name}(${t.length})${r.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(t) {
      let r = "[";
      for (let e = 0; e < t.length; e++) r += this.serialize(t[e]), e < t.length - 1 && (r += ",");
      return r + "]";
    }
    $Date(t) {
      try {
        return `Date(${t.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(t) {
      return `ArrayBuffer[${new Uint8Array(t).join(",")}]`;
    }
    $Set(t) {
      return `Set${this.$Array(Array.from(t).sort((r, e) => this.compare(r, e)))}`;
    }
    $Map(t) {
      return this.serializeObjectEntries("Map", t.entries());
    }
  }
  for (const s of ["Error", "RegExp", "URL"]) o.prototype["$" + s] = function(t) {
    return `${s}(${t})`;
  };
  for (const s of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join(",")}]`;
  };
  for (const s of ["BigInt64Array", "BigUint64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join("n,")}${t.length > 0 ? "n" : ""}]`;
  };
  return o;
}();
function isEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize(object1) === serialize(object2)) {
    return true;
  }
  return false;
}
function isNullish(value) {
  return value === null || value === void 0;
}
function isValueEqualOrExist(base, current) {
  if (isNullish(base))
    return false;
  if (Array.isArray(base)) {
    return base.some((val) => isEqual(val, current));
  } else {
    return isEqual(base, current);
  }
}
function validateProps({ type, defaultValue, modelValue }) {
  const value = modelValue || defaultValue;
  const canTypeBeInferred = modelValue !== void 0 || defaultValue !== void 0;
  if (canTypeBeInferred)
    return Array.isArray(value) ? "multiple" : "single";
  else
    return type ?? "single";
}
function getDefaultType({ type, defaultValue, modelValue }) {
  if (type)
    return type;
  return validateProps({ type, defaultValue, modelValue });
}
function getDefaultValue({ type, defaultValue }) {
  if (defaultValue !== void 0)
    return defaultValue;
  return type === "single" ? void 0 : [];
}
function useSingleOrMultipleValue(props, emits) {
  const type = computed(() => getDefaultType(props));
  const modelValue = useVModel$1(props, "modelValue", emits, {
    defaultValue: getDefaultValue(props),
    passive: props.modelValue === void 0,
    deep: true
  });
  function changeModelValue(value) {
    if (type.value === "single") {
      modelValue.value = isEqual(value, modelValue.value) ? void 0 : value;
    } else {
      const modelValueArray = Array.isArray(modelValue.value) ? [...modelValue.value || []] : [modelValue.value].filter(Boolean);
      if (isValueEqualOrExist(modelValueArray, value)) {
        const index2 = modelValueArray.findIndex((i2) => isEqual(i2, value));
        modelValueArray.splice(index2, 1);
      } else {
        modelValueArray.push(value);
      }
      modelValue.value = modelValueArray;
    }
  }
  const isSingle = computed(() => type.value === "single");
  return {
    modelValue,
    changeModelValue,
    isSingle
  };
}
const [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    locale: { default: "en" },
    scrollBody: { type: [Boolean, Object], default: true },
    nonce: { default: void 0 },
    useId: { type: Function, default: void 0 }
  },
  setup(__props) {
    const props = __props;
    const { dir, locale, scrollBody, nonce } = toRefs(props);
    provideConfigProviderContext({
      dir,
      locale,
      scrollBody,
      nonce,
      useId: props.useId
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
function useDirection(dir) {
  const context2 = injectConfigProviderContext({
    dir: ref("ltr")
  });
  return computed(() => dir?.value || context2.dir?.value || "ltr");
}
function useForwardExpose() {
  const instance = getCurrentInstance();
  const currentRef = ref();
  const currentElement = computed(() => {
    return ["#text", "#comment"].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement$1(currentRef);
  });
  const localExpose = Object.assign({}, instance.exposed);
  const ret = {};
  for (const key in instance.props) {
    Object.defineProperty(ret, key, {
      enumerable: true,
      configurable: true,
      get: () => instance.props[key]
    });
  }
  if (Object.keys(localExpose).length > 0) {
    for (const key in localExpose) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        configurable: true,
        get: () => localExpose[key]
      });
    }
  }
  Object.defineProperty(ret, "$el", {
    enumerable: true,
    configurable: true,
    get: () => instance.vnode.el
  });
  instance.exposed = ret;
  function forwardRef(ref2) {
    currentRef.value = ref2;
    if (!ref2)
      return;
    Object.defineProperty(ret, "$el", {
      enumerable: true,
      configurable: true,
      get: () => ref2 instanceof Element ? ref2 : ref2.$el
    });
    instance.exposed = ret;
  }
  return { forwardRef, currentRef, currentElement };
}
const [injectAccordionRootContext, provideAccordionRootContext] = createContext("AccordionRoot");
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "AccordionRoot",
  props: {
    collapsible: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dir: {},
    orientation: { default: "vertical" },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { dir, disabled, unmountOnHide } = toRefs(props);
    const direction = useDirection(dir);
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props, emits);
    const { forwardRef, currentElement: parentElement } = useForwardExpose();
    provideAccordionRootContext({
      disabled,
      direction,
      orientation: props.orientation,
      parentElement,
      isSingle,
      collapsible: props.collapsible,
      modelValue,
      changeModelValue,
      unmountOnHide
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
const [injectCollapsibleRootContext, provideCollapsibleRootContext] = createContext("CollapsibleRoot");
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const open = useVModel$1(props, "open", emit2, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const { disabled, unmountOnHide } = toRefs(props);
    provideCollapsibleRootContext({
      contentId: "",
      disabled,
      open,
      unmountOnHide,
      onOpenToggle: () => {
        if (disabled.value)
          return;
        open.value = !open.value;
      }
    });
    __expose({ open });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: _ctx.as,
        "as-child": props.asChild,
        "data-state": unref(open) ? "open" : "closed",
        "data-disabled": unref(disabled) ? "" : void 0
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-state", "data-disabled"]);
    };
  }
});
const ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options = {}) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName))
    return null;
  const {
    arrowKeyOptions = "both",
    attributeName = "[data-reka-collection-item]",
    itemsArray = [],
    loop = true,
    dir = "ltr",
    preventScroll = true,
    focus: focus2 = false
  } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical)) {
    return null;
  }
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item?.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, options, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index2 = elements.indexOf(currentElement);
  const newIndex2 = options.goForward ? index2 + 1 : index2 - 1;
  if (!options.loop && (newIndex2 < 0 || newIndex2 >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex2 + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(
      elements,
      candidate,
      options,
      iterations
    );
  }
  return candidate;
}
const [injectAccordionItemContext, provideAccordionItemContext] = createContext("AccordionItem");
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const open = computed(
      () => rootContext.isSingle.value ? props.value === rootContext.modelValue.value : Array.isArray(rootContext.modelValue.value) && rootContext.modelValue.value.includes(props.value)
    );
    const disabled = computed(() => {
      return rootContext.disabled.value || props.disabled;
    });
    const dataDisabled = computed(() => disabled.value ? "" : void 0);
    const dataState = computed(
      () => open.value ? "open" : "closed"
      /* Closed */
    );
    __expose({ open, dataDisabled });
    const { currentRef, currentElement } = useForwardExpose();
    provideAccordionItemContext({
      open,
      dataState,
      disabled,
      dataDisabled,
      triggerId: "",
      currentRef,
      currentElement,
      value: computed(() => props.value)
    });
    function handleArrowKey(e) {
      const target = e.target;
      const allCollectionItems = Array.from(rootContext.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []);
      const collectionItemIndex = allCollectionItems.findIndex((item) => item === target);
      if (collectionItemIndex === -1)
        return null;
      useArrowNavigation(
        e,
        target,
        rootContext.parentElement.value,
        {
          arrowKeyOptions: rootContext.orientation,
          dir: rootContext.direction.value,
          focus: true
        }
      );
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$X), {
        "data-orientation": unref(rootContext).orientation,
        "data-disabled": dataDisabled.value,
        "data-state": dataState.value,
        disabled: disabled.value,
        open: open.value,
        as: props.as,
        "as-child": props.asChild,
        "unmount-on-hide": unref(rootContext).unmountOnHide.value,
        onKeydown: withKeys(handleArrowKey, ["up", "down", "left", "right", "home", "end"])
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: open.value })
        ]),
        _: 3
      }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as", "as-child", "unmount-on-hide"]);
    };
  }
});
let count$1 = 0;
function useId(deterministicId, prefix = "reka") {
  const configProviderContext = injectConfigProviderContext({ useId: void 0 });
  if (Object.hasOwn(vue, "useId")) {
    return `${prefix}-${useId$1?.()}`;
  } else if (configProviderContext.useId) {
    return `${prefix}-${configProviderContext.useId()}`;
  }
  return `${prefix}-${++count$1}`;
}
function useStateMachine(initialState, machine) {
  const state2 = ref(initialState);
  function reducer(event) {
    const nextState = machine[state2.value][event];
    return nextState ?? state2.value;
  }
  const dispatch = (event) => {
    state2.value = reducer(event);
  };
  return {
    state: state2,
    dispatch
  };
}
function usePresence(present, node) {
  const stylesRef = ref({});
  const prevAnimationNameRef = ref("none");
  const prevPresentRef = ref(present);
  const initialState = present.value ? "mounted" : "unmounted";
  let timeoutId;
  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow;
  const { state: state2, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  const dispatchCustomEvent = (name) => {
    if (isClient$1) {
      const customEvent = new CustomEvent(name, { bubbles: false, cancelable: false });
      node.value?.dispatchEvent(customEvent);
    }
  };
  watch(
    present,
    async (currentPresent, prevPresent) => {
      const hasPresentChanged = prevPresent !== currentPresent;
      await nextTick();
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.value;
        const currentAnimationName = getAnimationName(node.value);
        if (currentPresent) {
          dispatch("MOUNT");
          dispatchCustomEvent("enter");
          if (currentAnimationName === "none")
            dispatchCustomEvent("after-enter");
        } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
          dispatch("UNMOUNT");
          dispatchCustomEvent("leave");
          dispatchCustomEvent("after-leave");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (prevPresent && isAnimating) {
            dispatch("ANIMATION_OUT");
            dispatchCustomEvent("leave");
          } else {
            dispatch("UNMOUNT");
            dispatchCustomEvent("after-leave");
          }
        }
      }
    },
    { immediate: true }
  );
  const handleAnimationEnd = (event) => {
    const currentAnimationName = getAnimationName(node.value);
    const isCurrentAnimation = currentAnimationName.includes(
      event.animationName
    );
    const directionName = state2.value === "mounted" ? "enter" : "leave";
    if (event.target === node.value && isCurrentAnimation) {
      dispatchCustomEvent(`after-${directionName}`);
      dispatch("ANIMATION_END");
      if (!prevPresentRef.value) {
        const currentFillMode = node.value.style.animationFillMode;
        node.value.style.animationFillMode = "forwards";
        timeoutId = ownerWindow?.setTimeout(() => {
          if (node.value?.style.animationFillMode === "forwards") {
            node.value.style.animationFillMode = currentFillMode;
          }
        });
      }
    }
    if (event.target === node.value && currentAnimationName === "none")
      dispatch("ANIMATION_END");
  };
  const handleAnimationStart = (event) => {
    if (event.target === node.value) {
      prevAnimationNameRef.value = getAnimationName(node.value);
    }
  };
  const watcher = watch(
    node,
    (newNode, oldNode) => {
      if (newNode) {
        stylesRef.value = getComputedStyle(newNode);
        newNode.addEventListener("animationstart", handleAnimationStart);
        newNode.addEventListener("animationcancel", handleAnimationEnd);
        newNode.addEventListener("animationend", handleAnimationEnd);
      } else {
        dispatch("ANIMATION_END");
        if (timeoutId !== void 0)
          ownerWindow?.clearTimeout(timeoutId);
        oldNode?.removeEventListener("animationstart", handleAnimationStart);
        oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
        oldNode?.removeEventListener("animationend", handleAnimationEnd);
      }
    },
    { immediate: true }
  );
  const stateWatcher = watch(state2, () => {
    const currentAnimationName = getAnimationName(node.value);
    prevAnimationNameRef.value = state2.value === "mounted" ? currentAnimationName : "none";
  });
  onUnmounted(() => {
    watcher();
    stateWatcher();
  });
  const isPresent = computed(
    () => ["mounted", "unmountSuspended"].includes(state2.value)
  );
  return {
    isPresent
  };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}
const Presence = /* @__PURE__ */ defineComponent({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(props, { slots, expose }) {
    const { present, forceMount } = toRefs(props);
    const node = ref();
    const { isPresent } = usePresence(present, node);
    expose({ present: isPresent });
    let children = slots.default({ present: isPresent.value });
    children = renderSlotFragments(children || []);
    const instance = getCurrentInstance();
    if (children && children?.length > 1) {
      const componentName = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((line) => `  - ${line}`).join("\n")
        ].join("\n")
      );
    }
    return () => {
      if (forceMount.value || present.value || isPresent.value) {
        return h(slots.default({ present: isPresent.value })[0], {
          ref: (v2) => {
            const el = unrefElement$1(v2);
            if (typeof el?.hasAttribute === "undefined")
              return el;
            if (el?.hasAttribute("data-reka-popper-content-wrapper"))
              node.value = el.firstElementChild;
            else
              node.value = el;
            return el;
          }
        });
      } else {
        return null;
      }
    };
  }
});
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["contentFound"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectCollapsibleRootContext();
    rootContext.contentId ||= useId(void 0, "reka-collapsible-content");
    const presentRef = ref();
    const { forwardRef, currentElement } = useForwardExpose();
    const width = ref(0);
    const height = ref(0);
    const isOpen = computed(() => rootContext.open.value);
    const isMountAnimationPrevented = ref(isOpen.value);
    const currentStyle = ref();
    watch(
      () => [isOpen.value, presentRef.value?.present],
      async () => {
        await nextTick();
        const node = currentElement.value;
        if (!node)
          return;
        currentStyle.value = currentStyle.value || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        };
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        height.value = rect.height;
        width.value = rect.width;
        if (!isMountAnimationPrevented.value) {
          node.style.transitionDuration = currentStyle.value.transitionDuration;
          node.style.animationName = currentStyle.value.animationName;
        }
      },
      {
        immediate: true
      }
    );
    const skipAnimation = computed(() => isMountAnimationPrevented.value && rootContext.open.value);
    onMounted(() => {
      requestAnimationFrame(() => {
        isMountAnimationPrevented.value = false;
      });
    });
    useEventListener(currentElement, "beforematch", (ev) => {
      requestAnimationFrame(() => {
        rootContext.onOpenToggle();
        emits("contentFound");
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        ref_key: "presentRef",
        ref: presentRef,
        present: _ctx.forceMount || unref(rootContext).open.value,
        "force-mount": true
      }, {
        default: withCtx(({ present }) => [
          createVNode(unref(Primitive), mergeProps(_ctx.$attrs, {
            id: unref(rootContext).contentId,
            ref: unref(forwardRef),
            "as-child": props.asChild,
            as: _ctx.as,
            hidden: !present ? unref(rootContext).unmountOnHide.value ? "" : "until-found" : void 0,
            "data-state": skipAnimation.value ? void 0 : unref(rootContext).open.value ? "open" : "closed",
            "data-disabled": unref(rootContext).disabled?.value ? "" : void 0,
            style: {
              [`--reka-collapsible-content-height`]: `${height.value}px`,
              [`--reka-collapsible-content-width`]: `${width.value}px`
            }
          }), {
            default: withCtx(() => [
              (unref(rootContext).unmountOnHide.value ? present : true) ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1040, ["id", "as-child", "as", "hidden", "data-state", "data-disabled", "style"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$V), {
        role: "region",
        "as-child": props.asChild,
        as: _ctx.as,
        "force-mount": props.forceMount,
        "aria-labelledby": unref(itemContext).triggerId,
        "data-state": unref(itemContext).dataState.value,
        "data-disabled": unref(itemContext).dataDisabled.value,
        "data-orientation": unref(rootContext).orientation,
        style: { "--reka-accordion-content-width": "var(--reka-collapsible-content-width)", "--reka-accordion-content-height": "var(--reka-collapsible-content-height)" },
        onContentFound: _cache[0] || (_cache[0] = ($event) => unref(rootContext).changeModelValue(unref(itemContext).value.value))
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "force-mount", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]);
    };
  }
});
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: props.as,
        "as-child": props.asChild,
        "data-orientation": unref(rootContext).orientation,
        "data-state": unref(itemContext).dataState.value,
        "data-disabled": unref(itemContext).dataDisabled.value
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]);
    };
  }
});
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectCollapsibleRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props.asChild,
        "aria-controls": unref(rootContext).contentId,
        "aria-expanded": unref(rootContext).open.value,
        "data-state": unref(rootContext).open.value ? "open" : "closed",
        "data-disabled": unref(rootContext).disabled?.value ? "" : void 0,
        disabled: unref(rootContext).disabled?.value,
        onClick: unref(rootContext).onOpenToggle
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    itemContext.triggerId ||= useId(void 0, "reka-accordion-trigger");
    function changeItem() {
      const triggerDisabled = rootContext.isSingle.value && itemContext.open.value && !rootContext.collapsible;
      if (itemContext.disabled.value || triggerDisabled)
        return;
      rootContext.changeModelValue(itemContext.value.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$S), {
        id: unref(itemContext).triggerId,
        ref: unref(itemContext).currentRef,
        "data-reka-collection-item": "",
        as: props.as,
        "as-child": props.asChild,
        "aria-disabled": unref(itemContext).disabled.value || void 0,
        "aria-expanded": unref(itemContext).open.value || false,
        "data-disabled": unref(itemContext).dataDisabled.value,
        "data-orientation": unref(rootContext).orientation,
        "data-state": unref(itemContext).dataState.value,
        disabled: unref(itemContext).disabled.value,
        onClick: changeItem
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]);
    };
  }
});
function useEmitAsProps(emit2) {
  const vm = getCurrentInstance();
  const events = vm?.type.emits;
  const result = {};
  if (!events?.length) {
    console.warn(
      `No emitted event found. Please check component: ${vm?.type.__name}`
    );
  }
  events?.forEach((ev) => {
    result[toHandlerKey(camelize(ev))] = (...arg) => emit2(ev, ...arg);
  });
  return result;
}
function getActiveElement() {
  let activeElement = document.activeElement;
  if (activeElement == null) {
    return null;
  }
  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}
const useFocusStackState = createGlobalState(() => {
  const stack2 = ref([]);
  return stack2;
});
function createFocusScopesStack() {
  const stack2 = useFocusStackState();
  return {
    add(focusScope) {
      const activeFocusScope = stack2.value[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope?.pause();
      stack2.value = arrayRemove(stack2.value, focusScope);
      stack2.value.unshift(focusScope);
    },
    remove(focusScope) {
      stack2.value = arrayRemove(stack2.value, focusScope);
      stack2.value[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
function focusFirst$1(candidates, { select = false } = {}) {
  const previouslyFocusedElement = getActiveElement();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = getActiveElement();
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) {
      element.select();
    }
  }
}
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: false },
    trapped: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { currentRef, currentElement } = useForwardExpose();
    const lastFocusedElementRef = ref(null);
    const focusScopesStack = createFocusScopesStack();
    const focusScope = reactive({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    });
    watchEffect((cleanupFn) => {
      if (!isClient$1)
        return;
      const container = currentElement.value;
      if (!props.trapped)
        return;
      function handleFocusIn(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target))
          lastFocusedElementRef.value = target;
        else focus(lastFocusedElementRef.value, { select: true });
      }
      function handleFocusOut(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget))
          focus(lastFocusedElementRef.value, { select: true });
      }
      function handleMutations(mutations) {
        const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value);
        if (!isLastFocusedElementExist)
          focus(container);
      }
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      cleanupFn(() => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      });
    });
    watchEffect(async (cleanupFn) => {
      const container = currentElement.value;
      await nextTick();
      if (!container)
        return;
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = getActiveElement();
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$1(removeLinks(getTabbableCandidates(container)), {
            select: true
          });
          if (getActiveElement() === previouslyFocusedElement)
            focus(container);
        }
      }
      cleanupFn(() => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
        const unmountEventHandler = (ev) => {
          emits("unmountAutoFocus", ev);
        };
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
        container.dispatchEvent(unmountEvent);
        setTimeout(() => {
          if (!unmountEvent.defaultPrevented)
            focus(previouslyFocusedElement ?? document.body, { select: true });
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
          focusScopesStack.remove(focusScope);
        }, 0);
      });
    });
    function handleKeyDown(event) {
      if (!props.loop && !props.trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = getActiveElement();
      if (isTabKey && focusedElement) {
        const container = event.currentTarget;
        const [first, last] = getTabbableEdges(container);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (props.loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (props.loop)
              focus(last, { select: true });
          }
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref_key: "currentRef",
        ref: currentRef,
        tabindex: "-1",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        onKeydown: handleKeyDown
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}
const POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(layerElement, targetElement) {
  const targetLayer = targetElement.closest(
    "[data-dismissable-layer]"
  );
  const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector(
    "[data-dismissable-layer]"
  );
  const nodeList = Array.from(
    layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))) {
    return true;
  } else {
    return false;
  }
}
function usePointerDownOutside(onPointerDownOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isPointerInsideDOMTree = ref(false);
  const handleClickRef = ref(() => {
  });
  watchEffect((cleanupFn) => {
    if (!isClient$1 || !toValue$2(enabled))
      return;
    const handlePointerDown = async (event) => {
      const target = event.target;
      if (!element?.value || !target)
        return;
      if (isLayerExist(element.value, target)) {
        isPointerInsideDOMTree.value = false;
        return;
      }
      if (event.target && !isPointerInsideDOMTree.value) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            onPointerDownOutside,
            eventDetail
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.value);
          handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.value, {
            once: true
          });
        } else {
          handleAndDispatchPointerDownOutsideEvent();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.value);
      }
      isPointerInsideDOMTree.value = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    cleanupFn(() => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.value);
    });
  });
  return {
    onPointerDownCapture: () => {
      if (!toValue$2(enabled))
        return;
      isPointerInsideDOMTree.value = true;
    }
  };
}
function useFocusOutside(onFocusOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isFocusInsideDOMTree = ref(false);
  watchEffect((cleanupFn) => {
    if (!isClient$1 || !toValue$2(enabled))
      return;
    const handleFocus = async (event) => {
      if (!element?.value)
        return;
      await nextTick();
      await nextTick();
      const target = event.target;
      if (!element.value || !target || isLayerExist(element.value, target))
        return;
      if (event.target && !isFocusInsideDOMTree.value) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(
          FOCUS_OUTSIDE,
          onFocusOutside,
          eventDetail
        );
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
  });
  return {
    onFocusCapture: () => {
      if (!toValue$2(enabled))
        return;
      isFocusInsideDOMTree.value = true;
    },
    onBlurCapture: () => {
      if (!toValue$2(enabled))
        return;
      isFocusInsideDOMTree.value = false;
    }
  };
}
const context = reactive({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef, currentElement: layerElement } = useForwardExpose();
    const ownerDocument = computed(
      () => layerElement.value?.ownerDocument ?? globalThis.document
    );
    const layers = computed(() => context.layersRoot);
    const index2 = computed(() => {
      return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
    });
    const isBodyPointerEventsDisabled = computed(() => {
      return context.layersWithOutsidePointerEventsDisabled.size > 0;
    });
    const isPointerEventsEnabled = computed(() => {
      const localLayers = Array.from(layers.value);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      return index2.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
    });
    const pointerDownOutside = usePointerDownOutside(async (event) => {
      const isPointerDownOnBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (!isPointerEventsEnabled.value || isPointerDownOnBranch)
        return;
      emits("pointerDownOutside", event);
      emits("interactOutside", event);
      await nextTick();
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    const focusOutside = useFocusOutside((event) => {
      const isFocusInBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (isFocusInBranch)
        return;
      emits("focusOutside", event);
      emits("interactOutside", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    onKeyStroke("Escape", (event) => {
      const isHighestLayer = index2.value === layers.value.size - 1;
      if (!isHighestLayer)
        return;
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    });
    let originalBodyPointerEvents;
    watchEffect((cleanupFn) => {
      if (!layerElement.value)
        return;
      if (props.disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
          ownerDocument.value.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
      }
      layers.value.add(layerElement.value);
      cleanupFn(() => {
        if (props.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
        }
      });
    });
    watchEffect((cleanupFn) => {
      cleanupFn(() => {
        if (!layerElement.value)
          return;
        layers.value.delete(layerElement.value);
        context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-dismissable-layer": "",
        style: normalizeStyle({
          pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: unref(focusOutside).onFocusCapture,
        onBlurCapture: unref(focusOutside).onBlurCapture,
        onPointerdownCapture: unref(pointerDownOutside).onPointerDownCapture
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]);
    };
  }
});
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
function useHideOthers(target) {
  let undo;
  watch(() => unrefElement$1(target), (el) => {
    if (el)
      undo = hideOthers(el);
    else if (undo)
      undo();
  });
  onUnmounted(() => {
    if (undo)
      undo();
  });
}
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults2, namespace = ".", merger) {
  if (!isPlainObject(defaults2)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults2);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p2, c2) => _defu(p2, c2, "", merger), {})
  );
}
const defu = createDefu();
const useBodyLockStackCount = createSharedComposable$1(() => {
  const map = ref(/* @__PURE__ */ new Map());
  const initialOverflow = ref();
  const locked = computed(() => {
    for (const value of map.value.values()) {
      if (value)
        return true;
    }
    return false;
  });
  const context2 = injectConfigProviderContext({
    scrollBody: ref(true)
  });
  let stopTouchMoveListener = null;
  const resetBodyStyle = () => {
    document.body.style.paddingRight = "";
    document.body.style.marginRight = "";
    document.body.style.pointerEvents = "";
    document.documentElement.style.removeProperty("--scrollbar-width");
    document.body.style.overflow = initialOverflow.value ?? "";
    isIOS && stopTouchMoveListener?.();
    initialOverflow.value = void 0;
  };
  watch(locked, (val, oldVal) => {
    if (!isClient$1)
      return;
    if (!val) {
      if (oldVal)
        resetBodyStyle();
      return;
    }
    if (initialOverflow.value === void 0)
      initialOverflow.value = document.body.style.overflow;
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const defaultConfig2 = { padding: verticalScrollbarWidth, margin: 0 };
    const config = context2.scrollBody?.value ? typeof context2.scrollBody.value === "object" ? defu({
      padding: context2.scrollBody.value.padding === true ? verticalScrollbarWidth : context2.scrollBody.value.padding,
      margin: context2.scrollBody.value.margin === true ? verticalScrollbarWidth : context2.scrollBody.value.margin
    }, defaultConfig2) : defaultConfig2 : { padding: 0, margin: 0 };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = typeof config.padding === "number" ? `${config.padding}px` : String(config.padding);
      document.body.style.marginRight = typeof config.margin === "number" ? `${config.margin}px` : String(config.margin);
      document.documentElement.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        document,
        "touchmove",
        (e) => preventDefault(e),
        { passive: false }
      );
    }
    nextTick(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  }, { immediate: true, flush: "sync" });
  return map;
});
function useBodyScrollLock(initialState) {
  const id = Math.random().toString(36).substring(2, 7);
  const map = useBodyLockStackCount();
  map.value.set(id, initialState);
  const locked = computed({
    get: () => map.value.get(id) ?? false,
    set: (value) => map.value.set(id, value)
  });
  tryOnBeforeUnmount(() => {
    map.value.delete(id);
  });
  return locked;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!(parent instanceof Element) || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (_target instanceof Element && checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault && e.cancelable)
    e.preventDefault();
  return false;
}
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const isMounted = useMounted();
    return (_ctx, _cache) => {
      return unref(isMounted) || _ctx.forceMount ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: _ctx.to,
        disabled: _ctx.disabled,
        defer: _ctx.defer
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, ["to", "disabled", "defer"])) : createCommentVNode("", true);
    };
  }
});
function useForwardProps(props) {
  const vm = getCurrentInstance();
  const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {
    const defaultValue = (vm?.type.props[curr]).default;
    if (defaultValue !== void 0)
      prev[curr] = defaultValue;
    return prev;
  }, {});
  const refProps = toRef$2(props);
  return computed(() => {
    const preservedProps = {};
    const assignedProps = vm?.vnode.props ?? {};
    Object.keys(assignedProps).forEach((key) => {
      preservedProps[camelize(key)] = assignedProps[key];
    });
    return Object.keys({ ...defaultProps, ...preservedProps }).reduce((prev, curr) => {
      if (refProps.value[curr] !== void 0)
        prev[curr] = refProps.value[curr];
      return prev;
    }, {});
  });
}
function useForwardPropsEmits(props, emit2) {
  const parsedProps = useForwardProps(props);
  const emitsAsProps = emit2 ? useEmitAsProps(emit2) : {};
  return computed(() => ({
    ...parsedProps.value,
    ...emitsAsProps
  }));
}
function usePrimitiveElement() {
  const primitiveElement = ref();
  const currentElement = computed(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement$1(primitiveElement));
  return {
    primitiveElement,
    currentElement
  };
}
const ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options = {}) {
  const { key = "", isProvider = false } = options;
  const injectionKey = `${key}CollectionProvider`;
  let context2;
  if (isProvider) {
    const itemMap = ref(/* @__PURE__ */ new Map());
    const collectionRef = ref();
    context2 = {
      collectionRef,
      itemMap
    };
    provide(injectionKey, context2);
  } else {
    context2 = inject(injectionKey);
  }
  const getItems = (includeDisabledItem = false) => {
    const collectionNode = context2.collectionRef.value;
    if (!collectionNode)
      return [];
    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
    const items = Array.from(context2.itemMap.value.values());
    const orderedItems = items.sort(
      (a2, b) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b.ref)
    );
    if (includeDisabledItem)
      return orderedItems;
    else
      return orderedItems.filter((i2) => i2.ref.dataset.disabled !== "");
  };
  const CollectionSlot = /* @__PURE__ */ defineComponent({
    name: "CollectionSlot",
    setup(_2, { slots }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watch(currentElement, () => {
        context2.collectionRef.value = currentElement.value;
      });
      return () => h(Slot, { ref: primitiveElement }, slots);
    }
  });
  const CollectionItem = /* @__PURE__ */ defineComponent({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        // It accepts any value
        validator: () => true
      }
    },
    setup(props, { slots, attrs }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watchEffect((cleanupFn) => {
        if (currentElement.value) {
          const key2 = markRaw(currentElement.value);
          context2.itemMap.value.set(key2, { ref: currentElement.value, value: props.value });
          cleanupFn(() => context2.itemMap.value.delete(key2));
        }
      });
      return () => h(Slot, { ...attrs, [ITEM_DATA_ATTR]: "", ref: primitiveElement }, slots);
    }
  });
  const reactiveItems = computed(() => Array.from(context2.itemMap.value.values()));
  const itemMapSize = computed(() => context2.itemMap.value.size);
  return { getItems, reactiveItems, itemMapSize, CollectionSlot, CollectionItem };
}
const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
const [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup");
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: false },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { loop, orientation, dir: propDir } = toRefs(props);
    const dir = useDirection(propDir);
    const currentTabStopId = useVModel$1(props, "currentTabStopId", emits, {
      defaultValue: props.defaultCurrentTabStopId,
      passive: props.currentTabStopId === void 0
    });
    const isTabbingBackOut = ref(false);
    const isClickFocus = ref(false);
    const focusableItemsCount = ref(0);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    function handleFocus(event) {
      const isKeyboardFocus = !isClickFocus.value;
      if (event.currentTarget && event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        emits("entryFocus", entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().map((i2) => i2.ref).filter((i2) => i2.dataset.disabled !== "");
          const activeItem = items.find((item) => item.getAttribute("data-active") === "");
          const currentItem = items.find(
            (item) => item.id === currentTabStopId.value
          );
          const candidateItems = [activeItem, currentItem, ...items].filter(
            Boolean
          );
          focusFirst(candidateItems, props.preventScrollOnEntryFocus);
        }
      }
      isClickFocus.value = false;
    }
    function handleMouseUp() {
      setTimeout(() => {
        isClickFocus.value = false;
      }, 1);
    }
    __expose({
      getItems
    });
    provideRovingFocusGroupContext({
      loop,
      dir,
      orientation,
      currentTabStopId,
      onItemFocus: (tabStopId) => {
        currentTabStopId.value = tabStopId;
      },
      onItemShiftTab: () => {
        isTabbingBackOut.value = true;
      },
      onFocusableItemAdd: () => {
        focusableItemsCount.value++;
      },
      onFocusableItemRemove: () => {
        focusableItemsCount.value--;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(CollectionSlot), null, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            tabindex: isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0,
            "data-orientation": unref(orientation),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref(dir),
            style: { "outline": "none" },
            onMousedown: _cache[0] || (_cache[0] = ($event) => isClickFocus.value = true),
            onMouseup: handleMouseUp,
            onFocus: handleFocus,
            onBlur: _cache[1] || (_cache[1] = ($event) => isTabbingBackOut.value = false)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: true },
    active: { type: Boolean },
    allowShiftKey: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props = __props;
    const context2 = injectRovingFocusGroupContext();
    const randomId = useId();
    const id = computed(() => props.tabStopId || randomId);
    const isCurrentTabStop = computed(
      () => context2.currentTabStopId.value === id.value
    );
    const { getItems, CollectionItem } = useCollection();
    onMounted(() => {
      if (props.focusable)
        context2.onFocusableItemAdd();
    });
    onUnmounted(() => {
      if (props.focusable)
        context2.onFocusableItemRemove();
    });
    function handleKeydown(event) {
      if (event.key === "Tab" && event.shiftKey) {
        context2.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = getFocusIntent(
        event,
        context2.orientation.value,
        context2.dir.value
      );
      if (focusIntent !== void 0) {
        if (event.metaKey || event.ctrlKey || event.altKey || (props.allowShiftKey ? false : event.shiftKey))
          return;
        event.preventDefault();
        let candidateNodes = [...getItems().map((i2) => i2.ref).filter((i2) => i2.dataset.disabled !== "")];
        if (focusIntent === "last") {
          candidateNodes.reverse();
        } else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(
            event.currentTarget
          );
          candidateNodes = context2.loop.value ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        nextTick(() => focusFirst(candidateNodes));
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(CollectionItem), null, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            tabindex: isCurrentTabStop.value ? 0 : -1,
            "data-orientation": unref(context2).orientation.value,
            "data-active": _ctx.active ? "" : void 0,
            "data-disabled": !_ctx.focusable ? "" : void 0,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            onMousedown: _cache[0] || (_cache[0] = (event) => {
              if (!_ctx.focusable) event.preventDefault();
              else unref(context2).onItemFocus(id.value);
            }),
            onFocus: _cache[1] || (_cache[1] = ($event) => unref(context2).onItemFocus(id.value)),
            onKeydown: handleKeydown
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"])
        ]),
        _: 3
      });
    };
  }
});
const [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperRoot",
  setup(__props) {
    const anchor = ref();
    providePopperRootContext({
      anchor,
      onAnchorChange: (element) => anchor.value = element
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "PopperAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectPopperRootContext();
    watchPostEffect(() => {
      rootContext.onAnchorChange(props.reference ?? currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        ref: unref(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
const _hoisted_1$e = {
  key: 0,
  d: "M0 0L6 6L12 0"
};
const _hoisted_2$7 = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
        width: _ctx.width,
        height: _ctx.height,
        viewBox: _ctx.asChild ? void 0 : "0 0 12 6",
        preserveAspectRatio: _ctx.asChild ? void 0 : "none"
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            !_ctx.rounded ? (openBlock(), createElementBlock("path", _hoisted_1$e)) : (openBlock(), createElementBlock("path", _hoisted_2$7))
          ])
        ]),
        _: 3
      }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]);
    };
  }
});
function isNotNull(value) {
  return value !== null;
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x2 = "";
      let y2 = "";
      if (placedSide === "bottom") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x2 = `${-arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x2 = `${rects.floating.width + arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x: x2, y: y2 } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function useSize(element) {
  const size2 = ref();
  const width = computed(() => size2.value?.width ?? 0);
  const height = computed(() => size2.value?.height ?? 0);
  onMounted(() => {
    const el = unrefElement$1(element);
    if (el) {
      size2.value = { width: el.offsetWidth, height: el.offsetHeight };
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width2;
        let height2;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry.borderBoxSize;
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width2 = borderSize.inlineSize;
          height2 = borderSize.blockSize;
        } else {
          width2 = el.offsetWidth;
          height2 = el.offsetHeight;
        }
        size2.value = { width: width2, height: height2 };
      });
      resizeObserver.observe(el, { box: "border-box" });
      return () => resizeObserver.unobserve(el);
    } else {
      size2.value = void 0;
    }
  });
  return {
    width,
    height
  };
}
const PopperContentPropsDefaultValue = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: true,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: false,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: false
};
const [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperContent",
  props: /* @__PURE__ */ mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopperRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const floatingRef = ref();
    const arrow$12 = ref();
    const { width: arrowWidth, height: arrowHeight } = useSize(arrow$12);
    const desiredPlacement = computed(
      () => props.side + (props.align !== "center" ? `-${props.align}` : "")
    );
    const collisionPadding = computed(() => {
      return typeof props.collisionPadding === "number" ? props.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...props.collisionPadding };
    });
    const boundary = computed(() => {
      return Array.isArray(props.collisionBoundary) ? props.collisionBoundary : [props.collisionBoundary];
    });
    const detectOverflowOptions = computed(() => {
      return {
        padding: collisionPadding.value,
        boundary: boundary.value.filter(isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: boundary.value.length > 0
      };
    });
    const computedMiddleware = computedEager(() => {
      return [
        offset({
          mainAxis: props.sideOffset + arrowHeight.value,
          alignmentAxis: props.alignOffset
        }),
        props.prioritizePosition && props.avoidCollisions && flip({
          ...detectOverflowOptions.value
        }),
        props.avoidCollisions && shift({
          mainAxis: true,
          crossAxis: !!props.prioritizePosition,
          limiter: props.sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions.value
        }),
        !props.prioritizePosition && props.avoidCollisions && flip({
          ...detectOverflowOptions.value
        }),
        size({
          ...detectOverflowOptions.value,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty(
              "--reka-popper-available-width",
              `${availableWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-available-height",
              `${availableHeight}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-width",
              `${anchorWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-height",
              `${anchorHeight}px`
            );
          }
        }),
        arrow$12.value && arrow({ element: arrow$12.value, padding: props.arrowPadding }),
        transformOrigin({
          arrowWidth: arrowWidth.value,
          arrowHeight: arrowHeight.value
        }),
        props.hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions.value })
      ];
    });
    const reference = computed(() => props.reference ?? rootContext.anchor.value);
    const { floatingStyles, placement, isPositioned, middlewareData } = useFloating(
      reference,
      floatingRef,
      {
        strategy: props.positionStrategy,
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            layoutShift: !props.disableUpdateOnLayoutShift,
            animationFrame: props.updatePositionStrategy === "always"
          });
          return cleanup;
        },
        middleware: computedMiddleware
      }
    );
    const placedSide = computed(
      () => getSideAndAlignFromPlacement(placement.value)[0]
    );
    const placedAlign = computed(
      () => getSideAndAlignFromPlacement(placement.value)[1]
    );
    watchPostEffect(() => {
      if (isPositioned.value)
        emits("placed");
    });
    const cannotCenterArrow = computed(
      () => middlewareData.value.arrow?.centerOffset !== 0
    );
    const contentZIndex = ref("");
    watchEffect(() => {
      if (contentElement.value)
        contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    const arrowX = computed(() => middlewareData.value.arrow?.x ?? 0);
    const arrowY = computed(() => middlewareData.value.arrow?.y ?? 0);
    providePopperContentContext({
      placedSide,
      onArrowChange: (element) => arrow$12.value = element,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "floatingRef",
        ref: floatingRef,
        "data-reka-popper-content-wrapper": "",
        style: normalizeStyle({
          ...unref(floatingStyles),
          transform: unref(isPositioned) ? unref(floatingStyles).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex.value,
          ["--reka-popper-transform-origin"]: [
            unref(middlewareData).transformOrigin?.x,
            unref(middlewareData).transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...unref(middlewareData).hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        createVNode(unref(Primitive), mergeProps({ ref: unref(forwardRef) }, _ctx.$attrs, {
          "as-child": props.asChild,
          as: _ctx.as,
          "data-side": placedSide.value,
          "data-align": placedAlign.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: !unref(isPositioned) ? "none" : void 0
          }
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
});
const OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const contentContext = injectPopperContentContext();
    const baseSide = computed(() => OPPOSITE_SIDE[contentContext.placedSide.value]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref: (el) => {
          unref(contentContext).onArrowChange(el);
          return void 0;
        },
        style: normalizeStyle({
          position: "absolute",
          left: unref(contentContext).arrowX?.value ? `${unref(contentContext).arrowX?.value}px` : void 0,
          top: unref(contentContext).arrowY?.value ? `${unref(contentContext).arrowY?.value}px` : void 0,
          [baseSide.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref(contentContext).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref(contentContext).placedSide.value],
          visibility: unref(contentContext).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        createVNode(_sfc_main$J, mergeProps(_ctx.$attrs, {
          ref: unref(forwardRef),
          style: {
            display: "block"
          },
          as: _ctx.as,
          "as-child": _ctx.asChild,
          rounded: _ctx.rounded,
          width: _ctx.width,
          height: _ctx.height
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "rounded", "width", "height"])
      ], 4);
    };
  }
});
let count = 0;
function useFocusGuards() {
  watchEffect((cleanupFn) => {
    if (!isClient$1)
      return;
    const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      edgeGuards[0] ?? createFocusGuard()
    );
    document.body.insertAdjacentElement(
      "beforeend",
      edgeGuards[1] ?? createFocusGuard()
    );
    count++;
    cleanupFn(() => {
      if (count === 1) {
        document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    });
  });
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-reka-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
const [injectPopoverRootContext, providePopoverRootContext] = createContext("PopoverRoot");
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { modal } = toRefs(props);
    const open = useVModel$1(props, "open", emit2, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const triggerElement = ref();
    const hasCustomAnchor = ref(false);
    providePopoverRootContext({
      contentId: "",
      triggerId: "",
      modal,
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerElement,
      hasCustomAnchor
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$L), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "PopoverAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    onBeforeMount(() => {
      rootContext.hasCustomAnchor.value = true;
    });
    onUnmounted(() => {
      rootContext.hasCustomAnchor.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$K), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "PopoverArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$H), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props.asChild,
        onClick: _cache[0] || (_cache[0] = ($event) => unref(rootContext).onOpenChange(false))
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child"]);
    };
  }
});
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$O), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardProps(reactiveOmit$1(props, "trapFocus", "disableOutsidePointerEvents"));
    const { forwardRef } = useForwardExpose();
    const rootContext = injectPopoverRootContext();
    useFocusGuards();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Q), {
        "as-child": "",
        loop: "",
        trapped: _ctx.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$P), {
            "as-child": "",
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            onPointerDownOutside: _cache[0] || (_cache[0] = ($event) => emits("pointerDownOutside", $event)),
            onInteractOutside: _cache[1] || (_cache[1] = ($event) => emits("interactOutside", $event)),
            onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
            onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
            onDismiss: _cache[4] || (_cache[4] = ($event) => unref(rootContext).onOpenChange(false))
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$I), mergeProps(unref(forwarded), {
                id: unref(rootContext).contentId,
                ref: unref(forwardRef),
                "data-state": unref(rootContext).open.value ? "open" : "closed",
                "aria-labelledby": unref(rootContext).triggerId,
                style: {
                  "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                  "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                  "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                  "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                  "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
                },
                role: "dialog"
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "aria-labelledby"])
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const isRightClickOutsideRef = ref(false);
    useBodyScrollLock(true);
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$B, mergeProps(unref(forwarded), {
        ref: unref(forwardRef),
        "trap-focus": unref(rootContext).open.value,
        "disable-outside-pointer-events": "",
        onCloseAutoFocus: _cache[0] || (_cache[0] = withModifiers(
          (event) => {
            emits("closeAutoFocus", event);
            if (!isRightClickOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
          },
          ["prevent"]
        )),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          emits("pointerDownOutside", event);
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.value = isRightClick;
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentNonModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const hasInteractedOutsideRef = ref(false);
    const hasPointerDownOutsideRef = ref(false);
    const forwarded = useForwardPropsEmits(props, emits);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$B, mergeProps(unref(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("closeAutoFocus", event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = async (event) => {
          emits("interactOutside", event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.value = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = unref(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) {
            event.preventDefault();
          }
        })
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef } = useForwardExpose();
    rootContext.contentId ||= useId(void 0, "reka-popover-content");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(rootContext).open.value
      }, {
        default: withCtx(() => [
          unref(rootContext).modal.value ? (openBlock(), createBlock(_sfc_main$A, mergeProps({ key: 0 }, unref(forwarded), { ref: unref(forwardRef) }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock(), createBlock(_sfc_main$z, mergeProps({ key: 1 }, unref(forwarded), { ref: unref(forwardRef) }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectPopoverRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    rootContext.triggerId ||= useId(void 0, "reka-popover-trigger");
    onMounted(() => {
      rootContext.triggerElement.value = triggerElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(rootContext).hasCustomAnchor.value ? unref(Primitive) : unref(_sfc_main$K)), { "as-child": "" }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            id: unref(rootContext).triggerId,
            ref: unref(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "aria-haspopup": "dialog",
            "aria-expanded": unref(rootContext).open.value,
            "aria-controls": unref(rootContext).contentId,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            as: _ctx.as,
            "as-child": props.asChild,
            onClick: unref(rootContext).onOpenToggle
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
        ]),
        _: 3
      });
    };
  }
});
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "HoverCardArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$H), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
const [injectHoverCardRootContext, provideHoverCardRootContext] = createContext("HoverCardRoot");
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { openDelay, closeDelay } = toRefs(props);
    useForwardExpose();
    const open = useVModel$1(props, "open", emit2, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    const openTimerRef = ref(0);
    const closeTimerRef = ref(0);
    const hasSelectionRef = ref(false);
    const isPointerDownOnContentRef = ref(false);
    const isPointerInTransitRef = ref(false);
    const triggerElement = ref();
    function handleOpen() {
      clearTimeout(closeTimerRef.value);
      openTimerRef.value = window.setTimeout(() => open.value = true, openDelay.value);
    }
    function handleClose() {
      clearTimeout(openTimerRef.value);
      if (!hasSelectionRef.value && !isPointerDownOnContentRef.value)
        closeTimerRef.value = window.setTimeout(() => open.value = false, closeDelay.value);
    }
    function handleDismiss() {
      open.value = false;
    }
    provideHoverCardRootContext({
      open,
      onOpenChange(value) {
        open.value = value;
      },
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      isPointerInTransitRef,
      triggerElement
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$L), null, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { open: unref(open) })
        ]),
        _: 3
      });
    };
  }
});
function useGraceArea(triggerElement, containerElement) {
  const isPointerInTransit = refAutoReset(false, 300);
  const pointerGraceArea = ref(null);
  const pointerExit = createEventHook();
  function handleRemoveGraceArea() {
    pointerGraceArea.value = null;
    isPointerInTransit.value = false;
  }
  function handleCreateGraceArea(event, hoverTarget) {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    pointerGraceArea.value = graceArea;
    isPointerInTransit.value = true;
  }
  watchEffect((cleanupFn) => {
    if (triggerElement.value && containerElement.value) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, containerElement.value);
      const handleContentLeave = (event) => handleCreateGraceArea(event, triggerElement.value);
      triggerElement.value.addEventListener("pointerleave", handleTriggerLeave);
      containerElement.value.addEventListener("pointerleave", handleContentLeave);
      cleanupFn(() => {
        triggerElement.value?.removeEventListener("pointerleave", handleTriggerLeave);
        containerElement.value?.removeEventListener("pointerleave", handleContentLeave);
      });
    }
  });
  watchEffect((cleanupFn) => {
    if (pointerGraceArea.value) {
      const handleTrackPointerGrace = (event) => {
        if (!pointerGraceArea.value || !(event.target instanceof HTMLElement))
          return;
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = triggerElement.value?.contains(target) || containerElement.value?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value);
        const isAnotherGraceAreaTrigger = !!target.closest("[data-grace-area-trigger]");
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {
          handleRemoveGraceArea();
          pointerExit.trigger();
        }
      };
      triggerElement.value?.ownerDocument.addEventListener("pointermove", handleTrackPointerGrace);
      cleanupFn(() => triggerElement.value?.ownerDocument.removeEventListener("pointermove", handleTrackPointerGrace));
    }
  });
  return {
    isPointerInTransit,
    onPointerExit: pointerExit.on
  };
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x)
      return -1;
    else if (a2.x > b.x)
      return 1;
    else if (a2.y < b.y)
      return -1;
    else if (a2.y > b.y)
      return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q2.x - r.x) * (p2.y - r.y) >= (q2.y - r.y) * (p2.x - r.x))
        upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points.length - 1; i2 >= 0; i2--) {
    const p2 = points[i2];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q2.x - r.x) * (p2.y - r.y) >= (q2.y - r.y) * (p2.x - r.x))
        lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardProps(props);
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(rootContext.triggerElement, contentElement);
    syncRef(rootContext.isPointerInTransitRef, isPointerInTransit, { direction: "rtl" });
    onPointerExit(() => {
      rootContext.onClose();
    });
    const containSelection = ref(false);
    let originalBodyUserSelect;
    watchEffect((cleanupFn) => {
      if (containSelection.value) {
        const body = document.body;
        originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
        body.style.userSelect = "none";
        body.style.webkitUserSelect = "none";
        cleanupFn(() => {
          body.style.userSelect = originalBodyUserSelect;
          body.style.webkitUserSelect = originalBodyUserSelect;
        });
      }
    });
    function handlePointerUp() {
      containSelection.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
      nextTick(() => {
        const hasSelection = document.getSelection()?.toString() !== "";
        if (hasSelection)
          rootContext.hasSelectionRef.value = true;
      });
    }
    onMounted(() => {
      if (contentElement.value) {
        document.addEventListener("pointerup", handlePointerUp);
        const tabbables = getTabbableNodes(contentElement.value);
        tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
      }
    });
    onUnmounted(() => {
      document.removeEventListener("pointerup", handlePointerUp);
      rootContext.hasSelectionRef.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$P), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
        onFocusOutside: _cache[3] || (_cache[3] = withModifiers(($event) => emits("focusOutside", $event), ["prevent"])),
        onDismiss: unref(rootContext).onDismiss
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$I), mergeProps({ ...unref(forwarded), ..._ctx.$attrs }, {
            ref: unref(forwardRef),
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            style: {
              "userSelect": containSelection.value ? "text" : void 0,
              // Safari requires prefix
              "WebkitUserSelect": containSelection.value ? "text" : void 0,
              // re-namespace exposed content custom properties
              "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
              "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
              "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
              "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
              "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
            },
            onPointerdown: _cache[0] || (_cache[0] = (event) => {
              if (event.currentTarget.contains(event.target)) {
                containSelection.value = true;
              }
              unref(rootContext).hasSelectionRef.value = false;
              unref(rootContext).isPointerDownOnContentRef.value = true;
            })
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["onDismiss"]);
    };
  }
});
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || unref(rootContext).open.value
      }, {
        default: withCtx(() => [
          createVNode(_sfc_main$u, mergeProps(unref(forwarded), {
            ref: unref(forwardRef),
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref(excludeTouch)(unref(rootContext).onOpen)($event))
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$O), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(__props) {
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    rootContext.triggerElement = currentElement;
    function handleLeave() {
      setTimeout(() => {
        if (!rootContext.isPointerInTransitRef.value && !rootContext.open.value) {
          rootContext.onClose();
        }
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$K), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            ref: unref(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            "data-grace-area-trigger": "",
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref(excludeTouch)(unref(rootContext).onOpen)($event)),
            onPointerleave: _cache[1] || (_cache[1] = ($event) => unref(excludeTouch)(handleLeave)($event)),
            onFocus: _cache[2] || (_cache[2] = ($event) => unref(rootContext).onOpen()),
            onBlur: _cache[3] || (_cache[3] = ($event) => unref(rootContext).onClose())
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "data-state"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
const [injectTabsRootContext, provideTabsRootContext] = createContext("TabsRoot");
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { orientation, unmountOnHide, dir: propDir } = toRefs(props);
    const dir = useDirection(propDir);
    useForwardExpose();
    const modelValue = useVModel$1(props, "modelValue", emits, {
      defaultValue: props.defaultValue,
      passive: props.modelValue === void 0
    });
    const tabsList = ref();
    provideTabsRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      orientation,
      dir,
      unmountOnHide,
      activationMode: props.activationMode,
      baseId: useId(void 0, "reka-tabs"),
      tabsList
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        dir: unref(dir),
        "data-orientation": unref(orientation),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })
        ]),
        _: 3
      }, 8, ["dir", "data-orientation", "as-child", "as"]);
    };
  }
});
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed(() => makeTriggerId(rootContext.baseId, props.value));
    const contentId = computed(() => makeContentId(rootContext.baseId, props.value));
    const isSelected = computed(() => props.value === rootContext.modelValue.value);
    const isMountAnimationPreventedRef = ref(isSelected.value);
    onMounted(() => {
      requestAnimationFrame(() => {
        isMountAnimationPreventedRef.value = false;
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence), {
        present: _ctx.forceMount || isSelected.value,
        "force-mount": ""
      }, {
        default: withCtx(({ present }) => [
          createVNode(unref(Primitive), {
            id: contentId.value,
            ref: unref(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            role: "tabpanel",
            "data-state": isSelected.value ? "active" : "inactive",
            "data-orientation": unref(rootContext).orientation.value,
            "aria-labelledby": triggerId.value,
            hidden: !present,
            tabindex: "0",
            style: normalizeStyle({
              animationDuration: isMountAnimationPreventedRef.value ? "0s" : void 0
            })
          }, {
            default: withCtx(() => [
              (unref(rootContext).unmountOnHide.value ? present : true) ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "TabsIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const context2 = injectTabsRootContext();
    useForwardExpose();
    const activeTab = ref();
    const indicatorStyle = ref({
      size: null,
      position: null
    });
    watch(() => [context2.modelValue.value, context2?.dir.value], async () => {
      await nextTick();
      updateIndicatorStyle();
    }, { immediate: true });
    useResizeObserver([context2.tabsList, activeTab], updateIndicatorStyle);
    function updateIndicatorStyle() {
      activeTab.value = context2.tabsList.value?.querySelector('[role="tab"][data-state="active"]');
      if (!activeTab.value)
        return;
      if (context2.orientation.value === "horizontal") {
        indicatorStyle.value = {
          size: activeTab.value.offsetWidth,
          position: activeTab.value.offsetLeft
        };
      } else {
        indicatorStyle.value = {
          size: activeTab.value.offsetHeight,
          position: activeTab.value.offsetTop
        };
      }
    }
    return (_ctx, _cache) => {
      return typeof indicatorStyle.value.size === "number" ? (openBlock(), createBlock(unref(Primitive), mergeProps({ key: 0 }, props, {
        style: {
          "--reka-tabs-indicator-size": `${indicatorStyle.value.size}px`,
          "--reka-tabs-indicator-position": `${indicatorStyle.value.position}px`
        }
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props = __props;
    const { loop } = toRefs(props);
    const { forwardRef, currentElement } = useForwardExpose();
    const context2 = injectTabsRootContext();
    context2.tabsList = currentElement;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$N), {
        "as-child": "",
        orientation: unref(context2).orientation.value,
        dir: unref(context2).dir.value,
        loop: unref(loop)
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            ref: unref(forwardRef),
            role: "tablist",
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "aria-orientation": unref(context2).orientation.value
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "aria-orientation"])
        ]),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed(() => makeTriggerId(rootContext.baseId, props.value));
    const contentId = computed(() => makeContentId(rootContext.baseId, props.value));
    const isSelected = computed(() => props.value === rootContext.modelValue.value);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$M), {
        "as-child": "",
        focusable: !_ctx.disabled,
        active: isSelected.value
      }, {
        default: withCtx(() => [
          createVNode(unref(Primitive), {
            id: triggerId.value,
            ref: unref(forwardRef),
            role: "tab",
            type: _ctx.as === "button" ? "button" : void 0,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-selected": isSelected.value ? "true" : "false",
            "aria-controls": contentId.value,
            "data-state": isSelected.value ? "active" : "inactive",
            disabled: _ctx.disabled,
            "data-disabled": _ctx.disabled ? "" : void 0,
            "data-orientation": unref(rootContext).orientation.value,
            onMousedown: _cache[0] || (_cache[0] = withModifiers((event) => {
              if (!_ctx.disabled && event.ctrlKey === false) {
                unref(rootContext).changeModelValue(_ctx.value);
              } else {
                event.preventDefault();
              }
            }, ["left"])),
            onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => unref(rootContext).changeModelValue(_ctx.value), ["enter", "space"])),
            onFocus: _cache[2] || (_cache[2] = () => {
              const isAutomaticActivation = unref(rootContext).activationMode !== "manual";
              if (!isSelected.value && !_ctx.disabled && isAutomaticActivation) {
                unref(rootContext).changeModelValue(_ctx.value);
              }
            })
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
        ]),
        _: 3
      }, 8, ["focusable", "active"]);
    };
  }
});
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
// @__NO_SIDE_EFFECTS__
function createSharedComposable(composable) {
  let subscribers = 0;
  let state2;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state2 = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!scope) {
      scope = effectScope(true);
      state2 = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state2;
  };
}
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(_2, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value))
        objectRef.value[p2].value = value;
      else
        objectRef.value[p2] = value;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function reactiveComputed(fn) {
  return toReactive(computed(fn));
}
function reactiveOmit(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k, v2]) => !predicate(toValue$2(v2), k))) : Object.fromEntries(Object.entries(toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef = (val) => typeof val !== "undefined";
const noop = () => {
};
function toRef(...args) {
  if (args.length !== 1)
    return toRef$2(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);
}
function reactivePick(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k, v2]) => predicate(toValue$2(v2), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  let lastInvoker;
  const filter = (invoke2) => {
    const duration = toValue$2(ms);
    const maxDuration = toValue$2(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = void 0;
      }
      return Promise.resolve(invoke2());
    }
    return new Promise((resolve2, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve2;
      lastInvoker = invoke2;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = void 0;
          resolve2(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = void 0;
        resolve2(invoke2());
      }, duration);
    });
  };
  return filter;
}
function getLifeCycleTarget(target) {
  return getCurrentInstance();
}
// @__NO_SIDE_EFFECTS__
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
const defaultDocument = isClient ? window.document : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue$2(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
// @__NO_SIDE_EFFECTS__
function useVModel(props, key, emit2, options = {}) {
  var _a, _b, _c;
  const {
    clone: clone2 = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone2 ? val : typeof clone2 === "function" ? clone2(val) : cloneFnJSON(val);
  const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v2) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v2);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v2) => {
        if (!isUpdating && (v2 !== props[key] || deep))
          triggerEmit(v2);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
function omit(data, keys) {
  const result = { ...data };
  for (const key of keys) {
    delete result[key];
  }
  return result;
}
function get(object, path, defaultValue) {
  if (typeof path === "string") {
    path = path.split(".").map((key) => {
      const numKey = Number(key);
      return Number.isNaN(numKey) ? key : numKey;
    });
  }
  let result = object;
  for (const key of path) {
    if (result === void 0 || result === null) {
      return defaultValue;
    }
    result = result[key];
  }
  return result !== void 0 ? result : defaultValue;
}
function looseToNumber(val) {
  const n = Number.parseFloat(val);
  return Number.isNaN(n) ? val : n;
}
function mergeClasses(appConfigClass, propClass) {
  if (!appConfigClass && !propClass) {
    return "";
  }
  return [
    ...Array.isArray(appConfigClass) ? appConfigClass : [appConfigClass],
    propClass
  ].filter(Boolean);
}
const portalTargetInjectionKey = Symbol("nuxt-ui.portal-target");
function usePortal(portal) {
  const portalTarget = inject(portalTargetInjectionKey, void 0);
  const to = computed(() => {
    if (typeof portal.value === "boolean" || portal.value === void 0) {
      return portalTarget?.value ?? "body";
    }
    return portal.value;
  });
  const disabled = computed(() => typeof portal.value === "boolean" ? !portal.value : false);
  provide(portalTargetInjectionKey, computed(() => to.value));
  return computed(() => ({
    to: to.value,
    disabled: disabled.value
  }));
}
function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}
class Hookable {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index2 = this._hooks[name].indexOf(function_);
      if (index2 !== -1) {
        this._hooks[name].splice(index2, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index2 = this._before.indexOf(function_);
        if (index2 !== -1) {
          this._before.splice(index2, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index2 = this._after.indexOf(function_);
        if (index2 !== -1) {
          this._after.splice(index2, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}
const appConfig = { "ui": { "colors": { "primary": "green", "secondary": "blue", "success": "green", "info": "blue", "warning": "yellow", "error": "red", "neutral": "slate" }, "icons": { "arrowLeft": "i-lucide-arrow-left", "arrowRight": "i-lucide-arrow-right", "check": "i-lucide-check", "chevronDoubleLeft": "i-lucide-chevrons-left", "chevronDoubleRight": "i-lucide-chevrons-right", "chevronDown": "i-lucide-chevron-down", "chevronLeft": "i-lucide-chevron-left", "chevronRight": "i-lucide-chevron-right", "chevronUp": "i-lucide-chevron-up", "close": "i-lucide-x", "ellipsis": "i-lucide-ellipsis", "external": "i-lucide-arrow-up-right", "file": "i-lucide-file", "folder": "i-lucide-folder", "folderOpen": "i-lucide-folder-open", "loading": "i-lucide-loader-circle", "minus": "i-lucide-minus", "plus": "i-lucide-plus", "search": "i-lucide-search", "upload": "i-lucide-upload" } }, "colorMode": true };
const _appConfig = reactive(appConfig);
const useAppConfig = () => _appConfig;
const state$1 = {};
const useState = (key, init) => {
  if (state$1[key]) {
    return state$1[key];
  }
  const value = ref(init());
  state$1[key] = value;
  return value;
};
createHooks();
var l = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, u = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, x$1 = (e, o) => JSON.stringify(e) === JSON.stringify(o);
function i(e, o) {
  e.forEach(function(r) {
    Array.isArray(r) ? i(r, o) : o.push(r);
  });
}
function y(e) {
  let o = [];
  return i(e, o), o;
}
var a = (...e) => y(e).filter(Boolean), p = (e, o) => {
  let r = {}, c2 = Object.keys(e), f = Object.keys(o);
  for (let t of c2) if (f.includes(t)) {
    let s = e[t], n = o[t];
    Array.isArray(s) || Array.isArray(n) ? r[t] = a(n, s) : typeof s == "object" && typeof n == "object" ? r[t] = p(s, n) : r[t] = n + " " + s;
  } else r[t] = e[t];
  for (let t of f) c2.includes(t) || (r[t] = o[t]);
  return r;
}, g = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme: theme2,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme2);
  }
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme2) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme2), classPartObject, classGroupId, theme2);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme2);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const MODIFIER_SEPARATOR = ":";
const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
const createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
const stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
const createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme2) => theme2[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value) => fractionRegex.test(value);
const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const isAny = () => true;
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, isNever, isShadow);
const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
const getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
const isLabelPosition = (label) => label === "position";
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isLabelImage = (label) => imageLabels.has(label);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isLabelSize = (label) => sizeLabels.has(label);
const isLabelLength = (label) => label === "length";
const isLabelNumber = (label) => label === "number";
const isLabelFamilyName = (label) => label === "family-name";
const isLabelShadow = (label) => label === "shadow";
const getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleOrigin = () => ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryVariable, isArbitraryValue];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...scalePosition(), isArbitraryValue, isArbitraryVariable]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "space", "round"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [themeColor]
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", isArbitraryVariable, isArbitraryValue, themeInsetShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scaleOrigin()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scaleOrigin()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["before", "after", "placeholder", "file", "marker", "selection", "first-line", "first-letter", "backdrop", "*", "**"]
  };
};
const mergeConfigs = (baseConfig, {
  cacheSize,
  prefix,
  experimentalParseClassName,
  extend: extend2 = {},
  override = {}
}) => {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
  overrideConfigProperties(baseConfig.theme, override.theme);
  overrideConfigProperties(baseConfig.classGroups, override.classGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
  overrideProperty(baseConfig, "orderSensitiveModifiers", override.orderSensitiveModifiers);
  mergeConfigProperties(baseConfig.theme, extend2.theme);
  mergeConfigProperties(baseConfig.classGroups, extend2.classGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroups, extend2.conflictingClassGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend2.conflictingClassGroupModifiers);
  mergeArrayProperties(baseConfig, extend2, "orderSensitiveModifiers");
  return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue) => {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
};
const overrideConfigProperties = (baseObject, overrideObject) => {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
};
const mergeConfigProperties = (baseObject, mergeObject) => {
  if (mergeObject) {
    for (const key in mergeObject) {
      mergeArrayProperties(baseObject, mergeObject, key);
    }
  }
};
const mergeArrayProperties = (baseObject, mergeObject, key) => {
  const mergeValue = mergeObject[key];
  if (mergeValue !== void 0) {
    baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
  }
};
const extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
var ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false }, x = (s) => s || void 0, N = (...s) => x(y(s).filter(Boolean).join(" ")), R = null, v = {}, q = false, M = (...s) => (b$1) => b$1.twMerge ? ((!R || q) && (q = false, R = u(v) ? twMerge : extendTailwindMerge({ ...v, extend: { theme: v.theme, classGroups: v.classGroups, conflictingClassGroupModifiers: v.conflictingClassGroupModifiers, conflictingClassGroups: v.conflictingClassGroups, ...v.extend } })), x(R(N(s)))) : N(s), _ = (s, b) => {
  for (let e in b) s.hasOwnProperty(e) ? s[e] = N(s[e], b[e]) : s[e] = b[e];
  return s;
}, ce = (s, b$1) => {
  let { extend: e = null, slots: O = {}, variants: U = {}, compoundVariants: W = [], compoundSlots: C = [], defaultVariants: z = {} } = s, m = { ...ie, ...b$1 }, k = e != null && e.base ? N(e.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1 = e != null && e.variants && !u(e.variants) ? p(U, e.variants) : U, w = e != null && e.defaultVariants && !u(e.defaultVariants) ? { ...e.defaultVariants, ...z } : z;
  !u(m.twMergeConfig) && !x$1(m.twMergeConfig, v) && (q = true, v = m.twMergeConfig);
  let S = u(e == null ? void 0 : e.slots), T = u(O) ? {} : { base: N(s == null ? void 0 : s.base, S && (e == null ? void 0 : e.base)), ...O }, j = S ? T : _({ ...e == null ? void 0 : e.slots }, u(T) ? { base: s == null ? void 0 : s.base } : T), h$1 = u(e == null ? void 0 : e.compoundVariants) ? W : a(e == null ? void 0 : e.compoundVariants, W), V = (l$1) => {
    if (u(g$1) && u(O) && S) return M(k, l$1 == null ? void 0 : l$1.class, l$1 == null ? void 0 : l$1.className)(m);
    if (h$1 && !Array.isArray(h$1)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
    if (C && !Array.isArray(C)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);
    let P = (a2, n, t = [], i2) => {
      let r = t;
      if (typeof n == "string") r = r.concat(g(n).split(" ").map((o) => `${a2}:${o}`));
      else if (Array.isArray(n)) r = r.concat(n.reduce((o, c2) => o.concat(`${a2}:${c2}`), []));
      else if (typeof n == "object" && typeof i2 == "string") {
        for (let o in n) if (n.hasOwnProperty(o) && o === i2) {
          let c2 = n[o];
          if (c2 && typeof c2 == "string") {
            let u2 = g(c2);
            r[i2] ? r[i2] = r[i2].concat(u2.split(" ").map((f) => `${a2}:${f}`)) : r[i2] = u2.split(" ").map((f) => `${a2}:${f}`);
          } else Array.isArray(c2) && c2.length > 0 && (r[i2] = c2.reduce((u2, f) => u2.concat(`${a2}:${f}`), []));
        }
      }
      return r;
    }, D = (a$1, n = g$1, t = null, i2 = null) => {
      var L;
      let r = n[a$1];
      if (!r || u(r)) return null;
      let o = (L = i2 == null ? void 0 : i2[a$1]) != null ? L : l$1 == null ? void 0 : l$1[a$1];
      if (o === null) return null;
      let c2 = l(o), u$1 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, f = w == null ? void 0 : w[a$1], d = [];
      if (typeof c2 == "object" && u$1) for (let [E, Q] of Object.entries(c2)) {
        let ne = r[Q];
        if (E === "initial") {
          f = Q;
          continue;
        }
        Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(E) || (d = P(E, ne, d, t));
      }
      let $ = c2 != null && typeof c2 != "object" ? c2 : l(f), A = r[$ || "false"];
      return typeof d == "object" && typeof t == "string" && d[t] ? _(d, A) : d.length > 0 ? (d.push(A), t === "base" ? d.join(" ") : d) : A;
    }, p2 = () => g$1 ? Object.keys(g$1).map((a2) => D(a2, g$1)) : null, ee = (a2, n) => {
      if (!g$1 || typeof g$1 != "object") return null;
      let t = new Array();
      for (let i2 in g$1) {
        let r = D(i2, g$1, a2, n), o = a2 === "base" && typeof r == "string" ? r : r && r[a2];
        o && (t[t.length] = o);
      }
      return t;
    }, H = {};
    for (let a2 in l$1) l$1[a2] !== void 0 && (H[a2] = l$1[a2]);
    let I = (a2, n) => {
      var i2;
      let t = typeof (l$1 == null ? void 0 : l$1[a2]) == "object" ? { [a2]: (i2 = l$1[a2]) == null ? void 0 : i2.initial } : {};
      return { ...w, ...H, ...t, ...n };
    }, J = (a2 = [], n) => {
      let t = [];
      for (let { class: i2, className: r, ...o } of a2) {
        let c2 = true;
        for (let [u2, f] of Object.entries(o)) {
          let d = I(u2, n)[u2];
          if (Array.isArray(f)) {
            if (!f.includes(d)) {
              c2 = false;
              break;
            }
          } else {
            let $ = (A) => A == null || A === false;
            if ($(f) && $(d)) continue;
            if (d !== f) {
              c2 = false;
              break;
            }
          }
        }
        c2 && (i2 && t.push(i2), r && t.push(r));
      }
      return t;
    }, te = (a2) => {
      let n = J(h$1, a2);
      if (!Array.isArray(n)) return n;
      let t = {};
      for (let i2 of n) if (typeof i2 == "string" && (t.base = M(t.base, i2)(m)), typeof i2 == "object") for (let [r, o] of Object.entries(i2)) t[r] = M(t[r], o)(m);
      return t;
    }, ae = (a2) => {
      if (C.length < 1) return null;
      let n = {};
      for (let { slots: t = [], class: i2, className: r, ...o } of C) {
        if (!u(o)) {
          let c2 = true;
          for (let u2 of Object.keys(o)) {
            let f = I(u2, a2)[u2];
            if (f === void 0 || (Array.isArray(o[u2]) ? !o[u2].includes(f) : o[u2] !== f)) {
              c2 = false;
              break;
            }
          }
          if (!c2) continue;
        }
        for (let c2 of t) n[c2] = n[c2] || [], n[c2].push([i2, r]);
      }
      return n;
    };
    if (!u(O) || !S) {
      let a2 = {};
      if (typeof j == "object" && !u(j)) for (let n of Object.keys(j)) a2[n] = (t) => {
        var i2, r;
        return M(j[n], ee(n, t), ((i2 = te(t)) != null ? i2 : [])[n], ((r = ae(t)) != null ? r : [])[n], t == null ? void 0 : t.class, t == null ? void 0 : t.className)(m);
      };
      return a2;
    }
    return M(k, p2(), J(h$1), l$1 == null ? void 0 : l$1.class, l$1 == null ? void 0 : l$1.className)(m);
  }, K = () => {
    if (!(!g$1 || typeof g$1 != "object")) return Object.keys(g$1);
  };
  return V.variantKeys = K(), V.extend = e, V.base = k, V.slots = j, V.variants = g$1, V.defaultVariants = w, V.compoundSlots = C, V.compoundVariants = h$1, V;
}, fe = (s) => (b, e) => ce(b, e ? p(s, e) : s);
const appConfigTv = appConfig;
const tv = /* @__PURE__ */ fe(appConfigTv.ui?.tv);
const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
  // Check name: cannot be empty
  ((allowSimpleName && icon.prefix === "" || !!icon.prefix) && !!icon.name);
};
const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});
function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}
function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}
function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve2(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve2(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve2);
  return resolved;
}
function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}
function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item = tree[name];
    if (item) {
      callback(name, internalGetIconData(data, name, item));
      names.push(name);
    }
  }
  return names;
}
const optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item, defaults2) {
  for (const prop in defaults2) {
    if (prop in item && typeof item[prop] !== typeof defaults2[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (
      // Name cannot be empty
      !name || // Must have body
      typeof icon.body !== "string" || // Check other props
      !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )
    ) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (
      // Name cannot be empty
      !name || // Parent must be set and point to existing icon
      typeof parent !== "string" || !icons[parent] && !aliases[parent] || // Check other props
      !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )
    ) {
      return null;
    }
  }
  return data;
}
const dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage2, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing.add(name);
    }
  });
}
function addIconToStorage(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage2 = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
  }
}
function addIcon(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  if (data) {
    return addIconToStorage(storage2, icon.name, data);
  } else {
    storage2.missing.add(icon.name);
    return true;
  }
}
function addCollection(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (addIcon(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage(provider, prefix);
  return !!addIconSet(storage2, data);
}
const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});
const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size2, ratio, precision) {
  if (ratio === 1) {
    return size2;
  }
  precision = precision || 100;
  if (typeof size2 === "number") {
    return Math.ceil(size2 * ratio * precision) / precision;
  }
  if (typeof size2 !== "string") {
    return size2;
  }
  const oldParts = size2.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size2;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber2 = unitsTest.test(code);
  while (true) {
    if (isNumber2) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber2 = !isNumber2;
  }
}
function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index2 = content.indexOf("<" + tag);
  while (index2 >= 0) {
    const start = content.indexOf(">", index2);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index2).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}
const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}
const regex = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id) => {
    const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
    const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}
const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
let fetchModule = detectFetch();
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index2) => {
    length += name.length + 1;
    if (length >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a2, b) => {
    if (a2.provider !== b.provider) {
      return a2.provider.localeCompare(b.provider);
    }
    if (a2.prefix !== b.prefix) {
      return a2.prefix.localeCompare(b.prefix);
    }
    return a2.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}
function removeCallback(storages, id) {
  storages.forEach((storage2) => {
    const items = storage2.loaderCallbacks;
    if (items) {
      storage2.loaderCallbacks = items.filter((row) => row.id !== id);
    }
  });
}
function updateCallbacks(storage2) {
  if (!storage2.pendingCallbacksFlag) {
    storage2.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage2.pendingCallbacksFlag = false;
      const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage2.provider;
      const prefix = storage2.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage2], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage2) => {
    (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
  });
  return abort;
}
function listToIcons(list, validate = true, simpleNames2 = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames2) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue2 = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue2.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue2 = queue2.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue2.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index2 = config.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config.index) {
        config.index = index2;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue2.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue2.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find2(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find: find2,
    setIndex: (index2) => {
      config.index = index2;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send2;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
function emptyCallback() {
}
function loadedNewIcons(storage2) {
  if (!storage2.iconsLoaderFlag) {
    storage2.iconsLoaderFlag = true;
    setTimeout(() => {
      storage2.iconsLoaderFlag = false;
      updateCallbacks(storage2);
    });
  }
}
function checkIconNamesForAPI(icons) {
  const valid = [];
  const invalid = [];
  icons.forEach((name) => {
    (name.match(matchIconName) ? valid : invalid).push(name);
  });
  return {
    valid,
    invalid
  };
}
function parseLoaderResponse(storage2, icons, data) {
  function checkMissing() {
    const pending = storage2.pendingIcons;
    icons.forEach((name) => {
      if (pending) {
        pending.delete(name);
      }
      if (!storage2.icons[name]) {
        storage2.missing.add(name);
      }
    });
  }
  if (data && typeof data === "object") {
    try {
      const parsed = addIconSet(storage2, data);
      if (!parsed.length) {
        checkMissing();
        return;
      }
    } catch (err) {
      console.error(err);
    }
  }
  checkMissing();
  loadedNewIcons(storage2);
}
function parsePossiblyAsyncResponse(response, callback) {
  if (response instanceof Promise) {
    response.then((data) => {
      callback(data);
    }).catch(() => {
      callback(null);
    });
  } else {
    callback(response);
  }
}
function loadNewIcons(storage2, icons) {
  if (!storage2.iconsToLoad) {
    storage2.iconsToLoad = icons;
  } else {
    storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
  }
  if (!storage2.iconsQueueFlag) {
    storage2.iconsQueueFlag = true;
    setTimeout(() => {
      storage2.iconsQueueFlag = false;
      const { provider, prefix } = storage2;
      const icons2 = storage2.iconsToLoad;
      delete storage2.iconsToLoad;
      if (!icons2 || !icons2.length) {
        return;
      }
      const customIconLoader = storage2.loadIcon;
      if (storage2.loadIcons && (icons2.length > 1 || !customIconLoader)) {
        parsePossiblyAsyncResponse(
          storage2.loadIcons(icons2, prefix, provider),
          (data) => {
            parseLoaderResponse(storage2, icons2, data);
          }
        );
        return;
      }
      if (customIconLoader) {
        icons2.forEach((name) => {
          const response = customIconLoader(name, prefix, provider);
          parsePossiblyAsyncResponse(response, (data) => {
            const iconSet = data ? {
              prefix,
              icons: {
                [name]: data
              }
            } : null;
            parseLoaderResponse(storage2, [name], iconSet);
          });
        });
        return;
      }
      const { valid, invalid } = checkIconNamesForAPI(icons2);
      if (invalid.length) {
        parseLoaderResponse(storage2, invalid, null);
      }
      if (!valid.length) {
        return;
      }
      const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;
      if (!api) {
        parseLoaderResponse(storage2, valid, null);
        return;
      }
      const params = api.prepare(provider, prefix, valid);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          parseLoaderResponse(storage2, item.icons, data);
        });
      });
    });
  }
}
const loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage2 = getStorage(provider, prefix);
    const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage2) => {
    const list = newIcons[storage2.provider][storage2.prefix];
    if (list.length) {
      loadNewIcons(storage2, list);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
function mergeCustomisations(defaults2, item) {
  const result = {
    ...defaults2
  };
  for (const key in item) {
    const value = item[key];
    const valueType = typeof value;
    if (key in defaultIconSizeCustomisations) {
      if (value === null || value && (valueType === "string" || valueType === "number")) {
        result[key] = value;
      }
    } else if (valueType === typeof result[key]) {
      result[key] = key === "rotate" ? value % 4 : value;
    }
  }
  return result;
}
const separator = /[\s,]+/;
function flipFromString(custom, flip2) {
  flip2.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}
function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}
const defaultExtendedIconCustomisations = {
  ...defaultIconCustomisations,
  inline: false
};
const svgDefaults = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img"
};
const commonProps = {
  display: "inline-block"
};
const monotoneProps = {
  backgroundColor: "currentColor"
};
const coloredProps = {
  backgroundColor: "transparent"
};
const propsToAdd = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
const propsToAddTo = {
  webkitMask: monotoneProps,
  mask: monotoneProps,
  background: coloredProps
};
for (const prefix in propsToAddTo) {
  const list = propsToAddTo[prefix];
  for (const prop in propsToAdd) {
    list[prefix + prop] = propsToAdd[prop];
  }
}
const customisationAliases = {};
["horizontal", "vertical"].forEach((prefix) => {
  const attr = prefix.slice(0, 1) + "Flip";
  customisationAliases[prefix + "-flip"] = attr;
  customisationAliases[prefix.slice(0, 1) + "-flip"] = attr;
  customisationAliases[prefix + "Flip"] = attr;
});
function fixSize(value) {
  return value + (value.match(/^[-0-9.]+$/) ? "px" : "");
}
const render = (icon, props) => {
  const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
  const componentProps = { ...svgDefaults };
  const mode = props.mode || "svg";
  const style = {};
  const propsStyle = props.style;
  const customStyle = typeof propsStyle === "object" && !(propsStyle instanceof Array) ? propsStyle : {};
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      // Properties to ignore
      case "icon":
      case "style":
      case "onLoad":
      case "mode":
      case "ssr":
        break;
      // Boolean attributes
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      // Flip as string: 'horizontal,vertical'
      case "flip":
        if (typeof value === "string") {
          flipFromString(customisations, value);
        }
        break;
      // Color: override style
      case "color":
        style.color = value;
        break;
      // Rotation as string
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      // Remove aria-hidden
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default: {
        const alias = customisationAliases[key];
        if (alias) {
          if (value === true || value === "true" || value === 1) {
            customisations[alias] = true;
          }
        } else if (defaultExtendedIconCustomisations[key] === void 0) {
          componentProps[key] = value;
        }
      }
    }
  }
  const item = iconToSVG(icon, customisations);
  const renderAttribs = item.attributes;
  if (customisations.inline) {
    style.verticalAlign = "-0.125em";
  }
  if (mode === "svg") {
    componentProps.style = {
      ...style,
      ...customStyle
    };
    Object.assign(componentProps, renderAttribs);
    let localCounter = 0;
    let id = props.id;
    if (typeof id === "string") {
      id = id.replace(/-/g, "_");
    }
    componentProps["innerHTML"] = replaceIDs(item.body, id ? () => id + "ID" + localCounter++ : "iconifyVue");
    return h("svg", componentProps);
  }
  const { body, width, height } = icon;
  const useMask = mode === "mask" || (mode === "bg" ? false : body.indexOf("currentColor") !== -1);
  const html = iconToHTML(body, {
    ...renderAttribs,
    width: width + "",
    height: height + ""
  });
  componentProps.style = {
    ...style,
    "--svg": svgToURL(html),
    "width": fixSize(renderAttribs.width),
    "height": fixSize(renderAttribs.height),
    ...commonProps,
    ...useMask ? monotoneProps : coloredProps,
    ...customStyle
  };
  return h("span", componentProps);
};
allowSimpleNames(true);
setAPIModule("", fetchAPIModule);
if (typeof document !== "undefined" && typeof window !== "undefined") {
  const _window = window;
  if (_window.IconifyPreload !== void 0) {
    const preload = _window.IconifyPreload;
    const err = "Invalid IconifyPreload syntax.";
    if (typeof preload === "object" && preload !== null) {
      (preload instanceof Array ? preload : [preload]).forEach((item) => {
        try {
          if (
            // Check if item is an object and not null/array
            typeof item !== "object" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'
            typeof item.icons !== "object" || typeof item.prefix !== "string" || // Add icon set
            !addCollection(item)
          ) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      });
    }
  }
  if (_window.IconifyProviders !== void 0) {
    const providers = _window.IconifyProviders;
    if (typeof providers === "object" && providers !== null) {
      for (let key in providers) {
        const err = "IconifyProviders[" + key + "] is invalid.";
        try {
          const value = providers[key];
          if (typeof value !== "object" || !value || value.resources === void 0) {
            continue;
          }
          if (!addAPIProvider(key, value)) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      }
    }
  }
}
const emptyIcon = {
  ...defaultIconProps,
  body: ""
};
const Icon = /* @__PURE__ */ defineComponent((props, { emit: emit2 }) => {
  const loader = ref(null);
  function abortLoading() {
    if (loader.value) {
      loader.value.abort?.();
      loader.value = null;
    }
  }
  const rendering = ref(!!props.ssr);
  const lastRenderedIconName = ref("");
  const iconData = shallowRef(null);
  function getIcon2() {
    const icon = props.icon;
    if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
      lastRenderedIconName.value = "";
      return {
        data: icon
      };
    }
    let iconName;
    if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
      return null;
    }
    let data = getIconData(iconName);
    if (!data) {
      const oldState = loader.value;
      if (!oldState || oldState.name !== icon) {
        if (data === null) {
          loader.value = {
            name: icon
          };
        } else {
          loader.value = {
            name: icon,
            abort: loadIcons([iconName], updateIconData)
          };
        }
      }
      return null;
    }
    abortLoading();
    if (lastRenderedIconName.value !== icon) {
      lastRenderedIconName.value = icon;
      nextTick(() => {
        emit2("load", icon);
      });
    }
    const customise = props.customise;
    if (customise) {
      data = Object.assign({}, data);
      const customised = customise(data.body, iconName.name, iconName.prefix, iconName.provider);
      if (typeof customised === "string") {
        data.body = customised;
      }
    }
    const classes = ["iconify"];
    if (iconName.prefix !== "") {
      classes.push("iconify--" + iconName.prefix);
    }
    if (iconName.provider !== "") {
      classes.push("iconify--" + iconName.provider);
    }
    return { data, classes };
  }
  function updateIconData() {
    const icon = getIcon2();
    if (!icon) {
      iconData.value = null;
    } else if (icon.data !== iconData.value?.data) {
      iconData.value = icon;
    }
  }
  if (rendering.value) {
    updateIconData();
  } else {
    onMounted(() => {
      rendering.value = true;
      updateIconData();
    });
  }
  watch(() => props.icon, updateIconData);
  onUnmounted(abortLoading);
  return () => {
    const icon = iconData.value;
    if (!icon) {
      return render(emptyIcon, props);
    }
    let newProps = props;
    if (icon.classes) {
      newProps = {
        ...props,
        class: icon.classes.join(" ")
      };
    }
    return render({
      ...defaultIconProps,
      ...icon.data
    }, newProps);
  };
}, {
  props: [
    // Icon and render mode
    "icon",
    "mode",
    "ssr",
    // Layout and style
    "width",
    "height",
    "style",
    "color",
    "inline",
    // Transformations
    "rotate",
    "hFlip",
    "horizontalFlip",
    "vFlip",
    "verticalFlip",
    "flip",
    // Misc
    "id",
    "ariaHidden",
    "customise",
    "title"
  ],
  emits: ["load"]
});
const _sfc_main$l = {
  __name: "Icon",
  props: {
    name: { type: String, required: true }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Icon), {
        icon: __props.name.replace(/^i-/, "")
      }, null, 8, ["icon"]);
    };
  }
};
const ImageComponent = "img";
const avatarGroupInjectionKey = Symbol("nuxt-ui.avatar-group");
function useAvatarGroup(props) {
  const avatarGroup = inject(avatarGroupInjectionKey, void 0);
  const size2 = computed(() => props.size ?? avatarGroup?.value.size);
  provide(avatarGroupInjectionKey, computed(() => ({ size: size2.value })));
  return {
    size: size2
  };
}
const theme$6 = {
  "slots": {
    "root": "relative inline-flex items-center justify-center shrink-0",
    "base": "rounded-full ring ring-bg flex items-center justify-center text-inverted font-medium whitespace-nowrap"
  },
  "variants": {
    "color": {
      "primary": "bg-primary",
      "secondary": "bg-secondary",
      "success": "bg-success",
      "info": "bg-info",
      "warning": "bg-warning",
      "error": "bg-error",
      "neutral": "bg-inverted"
    },
    "size": {
      "3xs": "h-[4px] min-w-[4px] text-[4px]",
      "2xs": "h-[5px] min-w-[5px] text-[5px]",
      "xs": "h-[6px] min-w-[6px] text-[6px]",
      "sm": "h-[7px] min-w-[7px] text-[7px]",
      "md": "h-[8px] min-w-[8px] text-[8px]",
      "lg": "h-[9px] min-w-[9px] text-[9px]",
      "xl": "h-[10px] min-w-[10px] text-[10px]",
      "2xl": "h-[11px] min-w-[11px] text-[11px]",
      "3xl": "h-[12px] min-w-[12px] text-[12px]"
    },
    "position": {
      "top-right": "top-0 right-0",
      "bottom-right": "bottom-0 right-0",
      "top-left": "top-0 left-0",
      "bottom-left": "bottom-0 left-0"
    },
    "inset": {
      "false": ""
    },
    "standalone": {
      "false": "absolute"
    }
  },
  "compoundVariants": [
    {
      "position": "top-right",
      "inset": false,
      "class": "-translate-y-1/2 translate-x-1/2 transform"
    },
    {
      "position": "bottom-right",
      "inset": false,
      "class": "translate-y-1/2 translate-x-1/2 transform"
    },
    {
      "position": "top-left",
      "inset": false,
      "class": "-translate-y-1/2 -translate-x-1/2 transform"
    },
    {
      "position": "bottom-left",
      "inset": false,
      "class": "translate-y-1/2 -translate-x-1/2 transform"
    }
  ],
  "defaultVariants": {
    "size": "md",
    "color": "primary",
    "position": "top-right"
  }
};
const _sfc_main$k = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "Chip",
  props: /* @__PURE__ */ mergeModels({
    as: { type: null, required: false },
    text: { type: [String, Number], required: false },
    color: { type: null, required: false },
    size: { type: null, required: false },
    position: { type: null, required: false },
    inset: { type: Boolean, required: false, default: false },
    standalone: { type: Boolean, required: false, default: false },
    class: { type: null, required: false },
    ui: { type: null, required: false }
  }, {
    "show": { type: Boolean, ...{ default: true } },
    "showModifiers": {}
  }),
  emits: ["update:show"],
  setup(__props) {
    const props = __props;
    const show = useModel(__props, "show", { type: Boolean, ...{ default: true } });
    const { size: size2 } = useAvatarGroup(props);
    const appConfig2 = useAppConfig();
    const ui = computed(() => tv({ extend: tv(theme$6), ...appConfig2.ui?.chip || {} })({
      color: props.color,
      size: size2.value,
      position: props.position,
      inset: props.inset,
      standalone: props.standalone
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: __props.as,
        class: normalizeClass(ui.value.root({ class: [props.ui?.root, props.class] }))
      }, {
        default: withCtx(() => [
          createVNode(unref(Slot), normalizeProps(guardReactiveProps(_ctx.$attrs)), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16),
          show.value ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(ui.value.base({ class: props.ui?.base }))
          }, [
            renderSlot(_ctx.$slots, "content", {}, () => [
              createTextVNode(toDisplayString(__props.text), 1)
            ])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["as", "class"]);
    };
  }
});
const theme$5 = {
  "slots": {
    "root": "inline-flex items-center justify-center shrink-0 select-none rounded-full align-middle bg-elevated",
    "image": "h-full w-full rounded-[inherit] object-cover",
    "fallback": "font-medium leading-none text-muted truncate",
    "icon": "text-muted shrink-0"
  },
  "variants": {
    "size": {
      "3xs": {
        "root": "size-4 text-[8px]"
      },
      "2xs": {
        "root": "size-5 text-[10px]"
      },
      "xs": {
        "root": "size-6 text-xs"
      },
      "sm": {
        "root": "size-7 text-sm"
      },
      "md": {
        "root": "size-8 text-base"
      },
      "lg": {
        "root": "size-9 text-lg"
      },
      "xl": {
        "root": "size-10 text-xl"
      },
      "2xl": {
        "root": "size-11 text-[22px]"
      },
      "3xl": {
        "root": "size-12 text-2xl"
      }
    }
  },
  "defaultVariants": {
    "size": "md"
  }
};
const _sfc_main$j = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "Avatar",
  props: {
    as: { type: null, required: false, default: "span" },
    src: { type: String, required: false },
    alt: { type: String, required: false },
    icon: { type: String, required: false },
    text: { type: String, required: false },
    size: { type: null, required: false },
    chip: { type: [Boolean, Object], required: false },
    class: { type: null, required: false },
    style: { type: null, required: false },
    ui: { type: null, required: false }
  },
  setup(__props) {
    const props = __props;
    const fallback = computed(() => props.text || (props.alt || "").split(" ").map((word) => word.charAt(0)).join("").substring(0, 2));
    const appConfig2 = useAppConfig();
    const { size: size2 } = useAvatarGroup(props);
    const ui = computed(() => tv({ extend: tv(theme$5), ...appConfig2.ui?.avatar || {} })({
      size: size2.value
    }));
    const sizePx = computed(() => ({
      "3xs": 16,
      "2xs": 20,
      "xs": 24,
      "sm": 28,
      "md": 32,
      "lg": 36,
      "xl": 40,
      "2xl": 44,
      "3xl": 48
    })[props.size || "md"]);
    const error = ref(false);
    watch(() => props.src, () => {
      if (error.value) {
        error.value = false;
      }
    });
    function onError() {
      error.value = true;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(props.chip ? _sfc_main$k : unref(Primitive)), mergeProps({ as: __props.as }, props.chip ? typeof props.chip === "object" ? { inset: true, ...props.chip } : { inset: true } : {}, {
        class: ui.value.root({ class: [props.ui?.root, props.class] }),
        style: props.style
      }), {
        default: withCtx(() => [
          __props.src && !error.value ? (openBlock(), createBlock(resolveDynamicComponent(unref(ImageComponent)), mergeProps({
            key: 0,
            role: "img",
            src: __props.src,
            alt: __props.alt,
            width: sizePx.value,
            height: sizePx.value
          }, _ctx.$attrs, {
            class: ui.value.image({ class: props.ui?.image }),
            onError
          }), null, 16, ["src", "alt", "width", "height", "class"])) : (openBlock(), createBlock(unref(Slot), normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, () => [
                __props.icon ? (openBlock(), createBlock(_sfc_main$l, {
                  key: 0,
                  name: __props.icon,
                  class: normalizeClass(ui.value.icon({ class: props.ui?.icon }))
                }, null, 8, ["name", "class"])) : (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(ui.value.fallback({ class: props.ui?.fallback }))
                }, toDisplayString(fallback.value || ""), 3))
              ])
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 16, ["as", "class", "style"]);
    };
  }
});
function useComponentIcons(componentProps) {
  const appConfig2 = useAppConfig();
  const props = computed(() => toValue$2(componentProps));
  const isLeading = computed(() => props.value.icon && props.value.leading || props.value.icon && !props.value.trailing || props.value.loading && !props.value.trailing || !!props.value.leadingIcon);
  const isTrailing = computed(() => props.value.icon && props.value.trailing || props.value.loading && props.value.trailing || !!props.value.trailingIcon);
  const leadingIconName = computed(() => {
    if (props.value.loading) {
      return props.value.loadingIcon || appConfig2.ui.icons.loading;
    }
    return props.value.leadingIcon || props.value.icon;
  });
  const trailingIconName = computed(() => {
    if (props.value.loading && !isLeading.value) {
      return props.value.loadingIcon || appConfig2.ui.icons.loading;
    }
    return props.value.trailingIcon || props.value.icon;
  });
  return {
    isLeading,
    isTrailing,
    leadingIconName,
    trailingIconName
  };
}
const buttonGroupInjectionKey = Symbol("nuxt-ui.button-group");
function useButtonGroup(props) {
  const buttonGroup = inject(buttonGroupInjectionKey, void 0);
  return {
    orientation: computed(() => buttonGroup?.value.orientation),
    size: computed(() => props?.size ?? buttonGroup?.value.size)
  };
}
const formOptionsInjectionKey = Symbol("nuxt-ui.form-options");
const formBusInjectionKey = Symbol("nuxt-ui.form-events");
const formFieldInjectionKey = Symbol("nuxt-ui.form-field");
const inputIdInjectionKey = Symbol("nuxt-ui.input-id");
const formInputsInjectionKey = Symbol("nuxt-ui.form-inputs");
const formLoadingInjectionKey = Symbol("nuxt-ui.form-loading");
function useFormField(props, opts) {
  const formOptions = inject(formOptionsInjectionKey, void 0);
  const formBus = inject(formBusInjectionKey, void 0);
  const formField = inject(formFieldInjectionKey, void 0);
  const formInputs = inject(formInputsInjectionKey, void 0);
  const inputId = inject(inputIdInjectionKey, void 0);
  provide(formFieldInjectionKey, void 0);
  if (formField && inputId) {
    if (opts?.bind === false) {
      inputId.value = void 0;
    } else if (props?.id) {
      inputId.value = props?.id;
    }
    if (formInputs && formField.value.name && inputId.value) {
      formInputs.value[formField.value.name] = { id: inputId.value, pattern: formField.value.errorPattern };
    }
  }
  function emitFormEvent(type, name, eager) {
    if (formBus && formField && name) {
      formBus.emit({ type, name, eager });
    }
  }
  function emitFormBlur() {
    emitFormEvent("blur", formField?.value.name);
  }
  function emitFormFocus() {
    emitFormEvent("focus", formField?.value.name);
  }
  function emitFormChange() {
    emitFormEvent("change", formField?.value.name);
  }
  const emitFormInput = /* @__PURE__ */ useDebounceFn(
    () => {
      emitFormEvent("input", formField?.value.name, formField?.value.eagerValidation);
    },
    formField?.value.validateOnInputDelay ?? formOptions?.value.validateOnInputDelay ?? 0
  );
  return {
    id: computed(() => props?.id ?? inputId?.value),
    name: computed(() => props?.name ?? formField?.value.name),
    size: computed(() => props?.size ?? formField?.value.size),
    color: computed(() => formField?.value.error ? "error" : props?.color),
    highlight: computed(() => formField?.value.error ? true : props?.highlight),
    disabled: computed(() => formOptions?.value.disabled || props?.disabled),
    emitFormBlur,
    emitFormInput,
    emitFormChange,
    emitFormFocus,
    ariaAttrs: computed(() => {
      if (!formField?.value) return;
      const descriptiveAttrs = ["error", "hint", "description", "help"].filter((type) => formField?.value?.[type]).map((type) => `${formField?.value.ariaId}-${type}`) || [];
      const attrs = {
        "aria-invalid": !!formField?.value.error
      };
      if (descriptiveAttrs.length > 0) {
        attrs["aria-describedby"] = descriptiveAttrs.join(" ");
      }
      return attrs;
    })
  };
}
function useSanitizeURL(url) {
  try {
    const parsed = new URL(url, window.location.origin);
    const isSafeProtocol = ["http:", "https:"].includes(parsed.protocol);
    if (!isSafeProtocol) {
      return "#";
    }
    return parsed.href;
  } catch {
    return "#";
  }
}
const _hoisted_1$d = ["href", "target"];
const _hoisted_2$6 = ["src"];
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderBrand",
  props: {
    brand: { type: Object }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("a", {
        href: unref(useSanitizeURL)(_ctx.brand.link),
        target: _ctx.brand.newTab ? "_blank" : "_self",
        class: "px-4"
      }, [
        createBaseVNode("img", {
          src: _ctx.brand.logo,
          alt: "logo",
          class: "max-w-[75px] max-h-[32px]"
        }, null, 8, _hoisted_2$6)
      ], 8, _hoisted_1$d);
    };
  }
});
const HoverCard = {
  Root: _sfc_main$v,
  Trigger: _sfc_main$r,
  Portal: _sfc_main$s,
  Content: _sfc_main$t,
  Arrow: _sfc_main$w
};
const Popover = {
  Root: _sfc_main$G,
  Trigger: _sfc_main$x,
  Portal: _sfc_main$C,
  Content: _sfc_main$y,
  Arrow: _sfc_main$E,
  Close: _sfc_main$D,
  Anchor: _sfc_main$F
};
const theme$4 = {
  "slots": {
    "content": "bg-default shadow-lg rounded-md ring ring-default data-[state=open]:animate-[scale-in_100ms_ease-out] data-[state=closed]:animate-[scale-out_100ms_ease-in] origin-(--reka-popover-content-transform-origin) focus:outline-none pointer-events-auto",
    "arrow": "fill-default"
  }
};
const _sfc_main$h = {
  __name: "Popover",
  props: {
    mode: { type: String, required: false, default: "click" },
    content: { type: Object, required: false },
    arrow: { type: [Boolean, Object], required: false },
    portal: { type: [Boolean, String], required: false, skipCheck: true, default: true },
    reference: { type: null, required: false },
    dismissible: { type: Boolean, required: false, default: true },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    defaultOpen: { type: Boolean, required: false },
    open: { type: Boolean, required: false },
    modal: { type: Boolean, required: false },
    openDelay: { type: Number, required: false, default: 0 },
    closeDelay: { type: Number, required: false, default: 0 }
  },
  emits: ["close:prevent", "update:open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const pick = props.mode === "hover" ? reactivePick(props, "defaultOpen", "open", "openDelay", "closeDelay") : reactivePick(props, "defaultOpen", "open", "modal");
    const rootProps = useForwardPropsEmits(pick, emits);
    const portalProps = usePortal(toRef$2(() => props.portal));
    const contentProps = toRef$2(() => defu(props.content, { side: "bottom", sideOffset: 8, collisionPadding: 8 }));
    const contentEvents = computed(() => {
      if (!props.dismissible) {
        const events = ["pointerDownOutside", "interactOutside", "escapeKeyDown"];
        return events.reduce((acc, curr) => {
          acc[curr] = (e) => {
            e.preventDefault();
            emits("close:prevent");
          };
          return acc;
        }, {});
      }
      return {};
    });
    const arrowProps = toRef$2(() => props.arrow);
    const ui = computed(() => tv({ extend: tv(theme$4), ...appConfig2.ui?.popover || {} })({
      side: contentProps.value.side
    }));
    const Component = computed(() => props.mode === "hover" ? HoverCard : Popover);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Component).Root, normalizeProps(guardReactiveProps(unref(rootProps))), {
        default: withCtx(({ open }) => [
          !!slots.default || !!__props.reference ? (openBlock(), createBlock(unref(Component).Trigger, {
            key: 0,
            "as-child": "",
            reference: __props.reference,
            class: normalizeClass(props.class)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", { open })
            ]),
            _: 2
          }, 1032, ["reference", "class"])) : createCommentVNode("", true),
          "Anchor" in Component.value && !!slots.anchor ? (openBlock(), createBlock(unref(Component).Anchor, {
            key: 1,
            "as-child": ""
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "anchor")
            ]),
            _: 3
          })) : createCommentVNode("", true),
          createVNode(unref(Component).Portal, normalizeProps(guardReactiveProps(unref(portalProps))), {
            default: withCtx(() => [
              createVNode(unref(Component).Content, mergeProps(contentProps.value, {
                class: ui.value.content({ class: [!slots.default && props.class, props.ui?.content] })
              }, toHandlers(contentEvents.value)), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "content"),
                  !!__props.arrow ? (openBlock(), createBlock(unref(Component).Arrow, mergeProps({ key: 0 }, arrowProps.value, {
                    class: ui.value.arrow({ class: props.ui?.arrow })
                  }), null, 16, ["class"])) : createCommentVNode("", true)
                ]),
                _: 3
              }, 16, ["class"])
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 16);
    };
  }
};
const theme$3 = {
  "slots": {
    "base": "font-medium inline-flex items-center",
    "label": "truncate",
    "leadingIcon": "shrink-0",
    "leadingAvatar": "shrink-0",
    "leadingAvatarSize": "",
    "trailingIcon": "shrink-0"
  },
  "variants": {
    "buttonGroup": {
      "horizontal": "not-only:first:rounded-e-none not-only:last:rounded-s-none not-last:not-first:rounded-none focus-visible:z-[1]",
      "vertical": "not-only:first:rounded-b-none not-only:last:rounded-t-none not-last:not-first:rounded-none focus-visible:z-[1]"
    },
    "color": {
      "primary": "",
      "secondary": "",
      "success": "",
      "info": "",
      "warning": "",
      "error": "",
      "neutral": ""
    },
    "variant": {
      "solid": "",
      "outline": "",
      "soft": "",
      "subtle": ""
    },
    "size": {
      "xs": {
        "base": "text-[8px]/3 px-1 py-0.5 gap-1 rounded-sm",
        "leadingIcon": "size-3",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-3"
      },
      "sm": {
        "base": "text-[10px]/3 px-1.5 py-1 gap-1 rounded-sm",
        "leadingIcon": "size-3",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-3"
      },
      "md": {
        "base": "text-xs px-2 py-1 gap-1 rounded-md",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "lg": {
        "base": "text-sm px-2 py-1 gap-1.5 rounded-md",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "xl": {
        "base": "text-base px-2.5 py-1 gap-1.5 rounded-md",
        "leadingIcon": "size-6",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-6"
      }
    },
    "square": {
      "true": ""
    }
  },
  "compoundVariants": [
    {
      "color": "primary",
      "variant": "solid",
      "class": "bg-primary text-inverted"
    },
    {
      "color": "secondary",
      "variant": "solid",
      "class": "bg-secondary text-inverted"
    },
    {
      "color": "success",
      "variant": "solid",
      "class": "bg-success text-inverted"
    },
    {
      "color": "info",
      "variant": "solid",
      "class": "bg-info text-inverted"
    },
    {
      "color": "warning",
      "variant": "solid",
      "class": "bg-warning text-inverted"
    },
    {
      "color": "error",
      "variant": "solid",
      "class": "bg-error text-inverted"
    },
    {
      "color": "primary",
      "variant": "outline",
      "class": "text-primary ring ring-inset ring-primary/50"
    },
    {
      "color": "secondary",
      "variant": "outline",
      "class": "text-secondary ring ring-inset ring-secondary/50"
    },
    {
      "color": "success",
      "variant": "outline",
      "class": "text-success ring ring-inset ring-success/50"
    },
    {
      "color": "info",
      "variant": "outline",
      "class": "text-info ring ring-inset ring-info/50"
    },
    {
      "color": "warning",
      "variant": "outline",
      "class": "text-warning ring ring-inset ring-warning/50"
    },
    {
      "color": "error",
      "variant": "outline",
      "class": "text-error ring ring-inset ring-error/50"
    },
    {
      "color": "primary",
      "variant": "soft",
      "class": "bg-primary/10 text-primary"
    },
    {
      "color": "secondary",
      "variant": "soft",
      "class": "bg-secondary/10 text-secondary"
    },
    {
      "color": "success",
      "variant": "soft",
      "class": "bg-success/10 text-success"
    },
    {
      "color": "info",
      "variant": "soft",
      "class": "bg-info/10 text-info"
    },
    {
      "color": "warning",
      "variant": "soft",
      "class": "bg-warning/10 text-warning"
    },
    {
      "color": "error",
      "variant": "soft",
      "class": "bg-error/10 text-error"
    },
    {
      "color": "primary",
      "variant": "subtle",
      "class": "bg-primary/10 text-primary ring ring-inset ring-primary/25"
    },
    {
      "color": "secondary",
      "variant": "subtle",
      "class": "bg-secondary/10 text-secondary ring ring-inset ring-secondary/25"
    },
    {
      "color": "success",
      "variant": "subtle",
      "class": "bg-success/10 text-success ring ring-inset ring-success/25"
    },
    {
      "color": "info",
      "variant": "subtle",
      "class": "bg-info/10 text-info ring ring-inset ring-info/25"
    },
    {
      "color": "warning",
      "variant": "subtle",
      "class": "bg-warning/10 text-warning ring ring-inset ring-warning/25"
    },
    {
      "color": "error",
      "variant": "subtle",
      "class": "bg-error/10 text-error ring ring-inset ring-error/25"
    },
    {
      "color": "neutral",
      "variant": "solid",
      "class": "text-inverted bg-inverted"
    },
    {
      "color": "neutral",
      "variant": "outline",
      "class": "ring ring-inset ring-accented text-default bg-default"
    },
    {
      "color": "neutral",
      "variant": "soft",
      "class": "text-default bg-elevated"
    },
    {
      "color": "neutral",
      "variant": "subtle",
      "class": "ring ring-inset ring-accented text-default bg-elevated"
    },
    {
      "size": "xs",
      "square": true,
      "class": "p-0.5"
    },
    {
      "size": "sm",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "md",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "lg",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "xl",
      "square": true,
      "class": "p-1"
    }
  ],
  "defaultVariants": {
    "color": "primary",
    "variant": "solid",
    "size": "md"
  }
};
const _sfc_main$g = {
  __name: "Badge",
  props: {
    as: { type: null, required: false, default: "span" },
    label: { type: [String, Number], required: false },
    color: { type: null, required: false },
    variant: { type: null, required: false },
    size: { type: null, required: false },
    square: { type: Boolean, required: false },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    icon: { type: String, required: false },
    avatar: { type: Object, required: false },
    leading: { type: Boolean, required: false },
    leadingIcon: { type: String, required: false },
    trailing: { type: Boolean, required: false },
    trailingIcon: { type: String, required: false }
  },
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const { orientation, size: buttonGroupSize } = useButtonGroup(props);
    const { isLeading, isTrailing, leadingIconName, trailingIconName } = useComponentIcons(props);
    const ui = computed(() => tv({ extend: tv(theme$3), ...appConfig2.ui?.badge || {} })({
      color: props.color,
      variant: props.variant,
      size: buttonGroupSize.value || props.size,
      square: props.square || !slots.default && !props.label,
      buttonGroup: orientation.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: __props.as,
        class: normalizeClass(ui.value.base({ class: [props.ui?.base, props.class] }))
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "leading", {}, () => [
            unref(isLeading) && unref(leadingIconName) ? (openBlock(), createBlock(_sfc_main$l, {
              key: 0,
              name: unref(leadingIconName),
              class: normalizeClass(ui.value.leadingIcon({ class: props.ui?.leadingIcon }))
            }, null, 8, ["name", "class"])) : !!__props.avatar ? (openBlock(), createBlock(_sfc_main$j, mergeProps({
              key: 1,
              size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
            }, __props.avatar, {
              class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar })
            }), null, 16, ["size", "class"])) : createCommentVNode("", true)
          ]),
          renderSlot(_ctx.$slots, "default", {}, () => [
            __props.label !== void 0 && __props.label !== null ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(ui.value.label({ class: props.ui?.label }))
            }, toDisplayString(__props.label), 3)) : createCommentVNode("", true)
          ]),
          renderSlot(_ctx.$slots, "trailing", {}, () => [
            unref(isTrailing) && unref(trailingIconName) ? (openBlock(), createBlock(_sfc_main$l, {
              key: 0,
              name: unref(trailingIconName),
              class: normalizeClass(ui.value.trailingIcon({ class: props.ui?.trailingIcon }))
            }, null, 8, ["name", "class"])) : createCommentVNode("", true)
          ])
        ]),
        _: 3
      }, 8, ["as", "class"]);
    };
  }
};
const theme$2 = {
  "slots": {
    "root": "flex items-center gap-2",
    "list": "relative flex p-1 group",
    "indicator": "absolute transition-[translate,width] duration-200",
    "trigger": [
      "group relative inline-flex items-center min-w-0 data-[state=inactive]:text-muted hover:data-[state=inactive]:not-disabled:text-default font-medium rounded-md disabled:cursor-not-allowed disabled:opacity-75",
      "transition-colors"
    ],
    "leadingIcon": "shrink-0",
    "leadingAvatar": "shrink-0",
    "leadingAvatarSize": "",
    "label": "truncate",
    "trailingBadge": "shrink-0",
    "trailingBadgeSize": "sm",
    "content": "focus:outline-none w-full"
  },
  "variants": {
    "color": {
      "primary": "",
      "secondary": "",
      "success": "",
      "info": "",
      "warning": "",
      "error": "",
      "neutral": ""
    },
    "variant": {
      "pill": {
        "list": "bg-elevated rounded-lg",
        "trigger": "grow",
        "indicator": "rounded-md shadow-xs"
      },
      "link": {
        "list": "border-default",
        "indicator": "rounded-full",
        "trigger": "focus:outline-none"
      }
    },
    "orientation": {
      "horizontal": {
        "root": "flex-col",
        "list": "w-full",
        "indicator": "left-0 w-(--reka-tabs-indicator-size) translate-x-(--reka-tabs-indicator-position)",
        "trigger": "justify-center"
      },
      "vertical": {
        "list": "flex-col",
        "indicator": "top-0 h-(--reka-tabs-indicator-size) translate-y-(--reka-tabs-indicator-position)"
      }
    },
    "size": {
      "xs": {
        "trigger": "px-2 py-1 text-xs gap-1",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs"
      },
      "sm": {
        "trigger": "px-2.5 py-1.5 text-xs gap-1.5",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs"
      },
      "md": {
        "trigger": "px-3 py-1.5 text-sm gap-1.5",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs"
      },
      "lg": {
        "trigger": "px-3 py-2 text-sm gap-2",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs"
      },
      "xl": {
        "trigger": "px-3 py-2 text-base gap-2",
        "leadingIcon": "size-6",
        "leadingAvatarSize": "xs"
      }
    }
  },
  "compoundVariants": [
    {
      "orientation": "horizontal",
      "variant": "pill",
      "class": {
        "indicator": "inset-y-1"
      }
    },
    {
      "orientation": "horizontal",
      "variant": "link",
      "class": {
        "list": "border-b -mb-px",
        "indicator": "-bottom-px h-px"
      }
    },
    {
      "orientation": "vertical",
      "variant": "pill",
      "class": {
        "indicator": "inset-x-1",
        "list": "items-center"
      }
    },
    {
      "orientation": "vertical",
      "variant": "link",
      "class": {
        "list": "border-s -ms-px",
        "indicator": "-start-px w-px"
      }
    },
    {
      "color": "primary",
      "variant": "pill",
      "class": {
        "indicator": "bg-primary",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary"
      }
    },
    {
      "color": "secondary",
      "variant": "pill",
      "class": {
        "indicator": "bg-secondary",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-secondary"
      }
    },
    {
      "color": "success",
      "variant": "pill",
      "class": {
        "indicator": "bg-success",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-success"
      }
    },
    {
      "color": "info",
      "variant": "pill",
      "class": {
        "indicator": "bg-info",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-info"
      }
    },
    {
      "color": "warning",
      "variant": "pill",
      "class": {
        "indicator": "bg-warning",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-warning"
      }
    },
    {
      "color": "error",
      "variant": "pill",
      "class": {
        "indicator": "bg-error",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-error"
      }
    },
    {
      "color": "neutral",
      "variant": "pill",
      "class": {
        "indicator": "bg-inverted",
        "trigger": "data-[state=active]:text-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-inverted"
      }
    },
    {
      "color": "primary",
      "variant": "link",
      "class": {
        "indicator": "bg-primary",
        "trigger": "data-[state=active]:text-primary focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-primary"
      }
    },
    {
      "color": "secondary",
      "variant": "link",
      "class": {
        "indicator": "bg-secondary",
        "trigger": "data-[state=active]:text-secondary focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-secondary"
      }
    },
    {
      "color": "success",
      "variant": "link",
      "class": {
        "indicator": "bg-success",
        "trigger": "data-[state=active]:text-success focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-success"
      }
    },
    {
      "color": "info",
      "variant": "link",
      "class": {
        "indicator": "bg-info",
        "trigger": "data-[state=active]:text-info focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-info"
      }
    },
    {
      "color": "warning",
      "variant": "link",
      "class": {
        "indicator": "bg-warning",
        "trigger": "data-[state=active]:text-warning focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-warning"
      }
    },
    {
      "color": "error",
      "variant": "link",
      "class": {
        "indicator": "bg-error",
        "trigger": "data-[state=active]:text-error focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-error"
      }
    },
    {
      "color": "neutral",
      "variant": "link",
      "class": {
        "indicator": "bg-inverted",
        "trigger": "data-[state=active]:text-highlighted focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-inverted"
      }
    }
  ],
  "defaultVariants": {
    "color": "primary",
    "variant": "pill",
    "size": "md"
  }
};
const _sfc_main$f = {
  __name: "Tabs",
  props: {
    as: { type: null, required: false },
    items: { type: Array, required: false },
    color: { type: null, required: false },
    variant: { type: null, required: false },
    size: { type: null, required: false },
    orientation: { type: null, required: false, default: "horizontal" },
    content: { type: Boolean, required: false, default: true },
    labelKey: { type: String, required: false, default: "label" },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    defaultValue: { type: null, required: false, default: "0" },
    modelValue: { type: null, required: false },
    activationMode: { type: String, required: false },
    unmountOnHide: { type: Boolean, required: false, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const rootProps = useForwardPropsEmits(reactivePick(props, "as", "modelValue", "defaultValue", "orientation", "activationMode", "unmountOnHide"), emits);
    const ui = computed(() => tv({ extend: tv(theme$2), ...appConfig2.ui?.tabs || {} })({
      color: props.color,
      variant: props.variant,
      size: props.size,
      orientation: props.orientation
    }));
    const triggersRef = ref([]);
    __expose({
      triggersRef
    });
    return (_ctx, _cache) => {
      const _component_UBadge = _sfc_main$g;
      return openBlock(), createBlock(unref(_sfc_main$q), mergeProps(unref(rootProps), {
        class: ui.value.root({ class: [props.ui?.root, props.class] })
      }), {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$n), {
            class: normalizeClass(ui.value.list({ class: props.ui?.list }))
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$o), {
                class: normalizeClass(ui.value.indicator({ class: props.ui?.indicator }))
              }, null, 8, ["class"]),
              renderSlot(_ctx.$slots, "list-leading"),
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.items, (item, index2) => {
                return openBlock(), createBlock(unref(_sfc_main$m), {
                  key: index2,
                  ref_for: true,
                  ref: (el) => triggersRef.value[index2] = el,
                  value: item.value || String(index2),
                  disabled: item.disabled,
                  class: normalizeClass(ui.value.trigger({ class: [props.ui?.trigger, item.ui?.trigger] }))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "leading", {
                      item,
                      index: index2
                    }, () => [
                      item.icon ? (openBlock(), createBlock(_sfc_main$l, {
                        key: 0,
                        name: item.icon,
                        class: normalizeClass(ui.value.leadingIcon({ class: [props.ui?.leadingIcon, item.ui?.leadingIcon] }))
                      }, null, 8, ["name", "class"])) : item.avatar ? (openBlock(), createBlock(_sfc_main$j, mergeProps({
                        key: 1,
                        size: item.ui?.leadingAvatarSize || props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                      }, { ref_for: true }, item.avatar, {
                        class: ui.value.leadingAvatar({ class: [props.ui?.leadingAvatar, item.ui?.leadingAvatar] })
                      }), null, 16, ["size", "class"])) : createCommentVNode("", true)
                    ]),
                    unref(get)(item, props.labelKey) || !!slots.default ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass(ui.value.label({ class: [props.ui?.label, item.ui?.label] }))
                    }, [
                      renderSlot(_ctx.$slots, "default", {
                        item,
                        index: index2
                      }, () => [
                        createTextVNode(toDisplayString(unref(get)(item, props.labelKey)), 1)
                      ])
                    ], 2)) : createCommentVNode("", true),
                    renderSlot(_ctx.$slots, "trailing", {
                      item,
                      index: index2
                    }, () => [
                      item.badge !== void 0 ? (openBlock(), createBlock(_component_UBadge, mergeProps({
                        key: 0,
                        color: "neutral",
                        variant: "outline",
                        size: item.ui?.trailingBadgeSize || props.ui?.trailingBadgeSize || ui.value.trailingBadgeSize()
                      }, { ref_for: true }, typeof item.badge === "string" || typeof item.badge === "number" ? { label: item.badge } : item.badge, {
                        class: ui.value.trailingBadge({ class: [props.ui?.trailingBadge, item.ui?.trailingBadge] })
                      }), null, 16, ["size", "class"])) : createCommentVNode("", true)
                    ])
                  ]),
                  _: 2
                }, 1032, ["value", "disabled", "class"]);
              }), 128)),
              renderSlot(_ctx.$slots, "list-trailing")
            ]),
            _: 3
          }, 8, ["class"]),
          !!__props.content ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.items, (item, index2) => {
            return openBlock(), createBlock(unref(_sfc_main$p), {
              key: index2,
              value: item.value || String(index2),
              class: normalizeClass(ui.value.content({ class: [props.ui?.content, item.ui?.content, item.class] }))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, item.slot || "content", {
                  item,
                  index: index2
                }, () => [
                  createTextVNode(toDisplayString(item.content), 1)
                ])
              ]),
              _: 2
            }, 1032, ["value", "class"]);
          }), 128)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
};
const theme$1 = {
  "slots": {
    "root": "w-full",
    "item": "border-b border-default last:border-b-0",
    "header": "flex",
    "trigger": "group flex-1 flex items-center gap-1.5 font-medium text-sm py-3.5 focus-visible:outline-primary min-w-0",
    "content": "data-[state=open]:animate-[accordion-down_200ms_ease-out] data-[state=closed]:animate-[accordion-up_200ms_ease-out] overflow-hidden focus:outline-none",
    "body": "text-sm pb-3.5",
    "leadingIcon": "shrink-0 size-5",
    "trailingIcon": "shrink-0 size-5 ms-auto group-data-[state=open]:rotate-180 transition-transform duration-200",
    "label": "text-start break-words"
  },
  "variants": {
    "disabled": {
      "true": {
        "trigger": "cursor-not-allowed opacity-75"
      }
    }
  }
};
const _sfc_main$e = {
  __name: "Accordion",
  props: {
    as: { type: null, required: false },
    items: { type: Array, required: false },
    trailingIcon: { type: String, required: false },
    labelKey: { type: String, required: false, default: "label" },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    collapsible: { type: Boolean, required: false, default: true },
    defaultValue: { type: null, required: false },
    modelValue: { type: null, required: false },
    type: { type: String, required: false, default: "single" },
    disabled: { type: Boolean, required: false },
    unmountOnHide: { type: Boolean, required: false, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const rootProps = useForwardPropsEmits(reactivePick(props, "as", "collapsible", "defaultValue", "disabled", "modelValue", "type", "unmountOnHide"), emits);
    const ui = computed(() => tv({ extend: tv(theme$1), ...appConfig2.ui?.accordion || {} })({
      disabled: props.disabled
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$Y), mergeProps(unref(rootProps), {
        class: ui.value.root({ class: [props.ui?.root, props.class] })
      }), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(props.items, (item, index2) => {
            return openBlock(), createBlock(unref(_sfc_main$W), {
              key: index2,
              value: item.value || String(index2),
              disabled: item.disabled,
              class: normalizeClass(ui.value.item({ class: [props.ui?.item, item.ui?.item, item.class] }))
            }, {
              default: withCtx(({ open }) => [
                createVNode(unref(_sfc_main$T), {
                  as: "div",
                  class: normalizeClass(ui.value.header({ class: [props.ui?.header, item.ui?.header] }))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$R), {
                      class: normalizeClass(ui.value.trigger({ class: [props.ui?.trigger, item.ui?.trigger], disabled: item.disabled }))
                    }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "leading", {
                          item,
                          index: index2,
                          open
                        }, () => [
                          item.icon ? (openBlock(), createBlock(_sfc_main$l, {
                            key: 0,
                            name: item.icon,
                            class: normalizeClass(ui.value.leadingIcon({ class: [props.ui?.leadingIcon, item?.ui?.leadingIcon] }))
                          }, null, 8, ["name", "class"])) : createCommentVNode("", true)
                        ]),
                        unref(get)(item, props.labelKey) || !!slots.default ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(ui.value.label({ class: [props.ui?.label, item.ui?.label] }))
                        }, [
                          renderSlot(_ctx.$slots, "default", {
                            item,
                            index: index2,
                            open
                          }, () => [
                            createTextVNode(toDisplayString(unref(get)(item, props.labelKey)), 1)
                          ])
                        ], 2)) : createCommentVNode("", true),
                        renderSlot(_ctx.$slots, "trailing", {
                          item,
                          index: index2,
                          open
                        }, () => [
                          createVNode(_sfc_main$l, {
                            name: item.trailingIcon || __props.trailingIcon || unref(appConfig2).ui.icons.chevronDown,
                            class: normalizeClass(ui.value.trailingIcon({ class: [props.ui?.trailingIcon, item.ui?.trailingIcon] }))
                          }, null, 8, ["name", "class"])
                        ])
                      ]),
                      _: 2
                    }, 1032, ["class"])
                  ]),
                  _: 2
                }, 1032, ["class"]),
                item.content || !!slots.content || item.slot && !!slots[item.slot] || !!slots.body || item.slot && !!slots[`${item.slot}-body`] ? (openBlock(), createBlock(unref(_sfc_main$U), {
                  key: 0,
                  class: normalizeClass(ui.value.content({ class: [props.ui?.content, item.ui?.content] }))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, item.slot || "content", {
                      item,
                      index: index2,
                      open
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(ui.value.body({ class: [props.ui?.body, item.ui?.body] }))
                      }, [
                        renderSlot(_ctx.$slots, item.slot ? `${item.slot}-body` : "body", {
                          item,
                          index: index2,
                          open
                        }, () => [
                          createTextVNode(toDisplayString(item.content), 1)
                        ])
                      ], 2)
                    ])
                  ]),
                  _: 2
                }, 1032, ["class"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["value", "disabled", "class"]);
          }), 128))
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
};
const theme = {
  "slots": {
    "root": "relative inline-flex items-center",
    "base": [
      "w-full rounded-md border-0 placeholder:text-dimmed focus:outline-none disabled:cursor-not-allowed disabled:opacity-75",
      "transition-colors"
    ],
    "leading": "absolute inset-y-0 start-0 flex items-center",
    "leadingIcon": "shrink-0 text-dimmed",
    "leadingAvatar": "shrink-0",
    "leadingAvatarSize": "",
    "trailing": "absolute inset-y-0 end-0 flex items-center",
    "trailingIcon": "shrink-0 text-dimmed"
  },
  "variants": {
    "buttonGroup": {
      "horizontal": {
        "root": "group has-focus-visible:z-[1]",
        "base": "group-not-only:group-first:rounded-e-none group-not-only:group-last:rounded-s-none group-not-last:group-not-first:rounded-none"
      },
      "vertical": {
        "root": "group has-focus-visible:z-[1]",
        "base": "group-not-only:group-first:rounded-b-none group-not-only:group-last:rounded-t-none group-not-last:group-not-first:rounded-none"
      }
    },
    "size": {
      "xs": {
        "base": "px-2 py-1 text-xs gap-1",
        "leading": "ps-2",
        "trailing": "pe-2",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "sm": {
        "base": "px-2.5 py-1.5 text-xs gap-1.5",
        "leading": "ps-2.5",
        "trailing": "pe-2.5",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "md": {
        "base": "px-2.5 py-1.5 text-sm gap-1.5",
        "leading": "ps-2.5",
        "trailing": "pe-2.5",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "lg": {
        "base": "px-3 py-2 text-sm gap-2",
        "leading": "ps-3",
        "trailing": "pe-3",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "xl": {
        "base": "px-3 py-2 text-base gap-2",
        "leading": "ps-3",
        "trailing": "pe-3",
        "leadingIcon": "size-6",
        "leadingAvatarSize": "xs",
        "trailingIcon": "size-6"
      }
    },
    "variant": {
      "outline": "text-highlighted bg-default ring ring-inset ring-accented",
      "soft": "text-highlighted bg-elevated/50 hover:bg-elevated focus:bg-elevated disabled:bg-elevated/50",
      "subtle": "text-highlighted bg-elevated ring ring-inset ring-accented",
      "ghost": "text-highlighted bg-transparent hover:bg-elevated focus:bg-elevated disabled:bg-transparent dark:disabled:bg-transparent",
      "none": "text-highlighted bg-transparent"
    },
    "color": {
      "primary": "",
      "secondary": "",
      "success": "",
      "info": "",
      "warning": "",
      "error": "",
      "neutral": ""
    },
    "leading": {
      "true": ""
    },
    "trailing": {
      "true": ""
    },
    "loading": {
      "true": ""
    },
    "highlight": {
      "true": ""
    },
    "type": {
      "file": "file:me-1.5 file:font-medium file:text-muted file:outline-none"
    }
  },
  "compoundVariants": [
    {
      "color": "primary",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-primary"
    },
    {
      "color": "secondary",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-secondary"
    },
    {
      "color": "success",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-success"
    },
    {
      "color": "info",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-info"
    },
    {
      "color": "warning",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-warning"
    },
    {
      "color": "error",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-error"
    },
    {
      "color": "primary",
      "highlight": true,
      "class": "ring ring-inset ring-primary"
    },
    {
      "color": "secondary",
      "highlight": true,
      "class": "ring ring-inset ring-secondary"
    },
    {
      "color": "success",
      "highlight": true,
      "class": "ring ring-inset ring-success"
    },
    {
      "color": "info",
      "highlight": true,
      "class": "ring ring-inset ring-info"
    },
    {
      "color": "warning",
      "highlight": true,
      "class": "ring ring-inset ring-warning"
    },
    {
      "color": "error",
      "highlight": true,
      "class": "ring ring-inset ring-error"
    },
    {
      "color": "neutral",
      "variant": [
        "outline",
        "subtle"
      ],
      "class": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-inverted"
    },
    {
      "color": "neutral",
      "highlight": true,
      "class": "ring ring-inset ring-inverted"
    },
    {
      "leading": true,
      "size": "xs",
      "class": "ps-7"
    },
    {
      "leading": true,
      "size": "sm",
      "class": "ps-8"
    },
    {
      "leading": true,
      "size": "md",
      "class": "ps-9"
    },
    {
      "leading": true,
      "size": "lg",
      "class": "ps-10"
    },
    {
      "leading": true,
      "size": "xl",
      "class": "ps-11"
    },
    {
      "trailing": true,
      "size": "xs",
      "class": "pe-7"
    },
    {
      "trailing": true,
      "size": "sm",
      "class": "pe-8"
    },
    {
      "trailing": true,
      "size": "md",
      "class": "pe-9"
    },
    {
      "trailing": true,
      "size": "lg",
      "class": "pe-10"
    },
    {
      "trailing": true,
      "size": "xl",
      "class": "pe-11"
    },
    {
      "loading": true,
      "leading": true,
      "class": {
        "leadingIcon": "animate-spin"
      }
    },
    {
      "loading": true,
      "leading": false,
      "trailing": true,
      "class": {
        "trailingIcon": "animate-spin"
      }
    }
  ],
  "defaultVariants": {
    "size": "md",
    "color": "primary",
    "variant": "outline"
  }
};
const _hoisted_1$c = ["id", "type", "value", "name", "placeholder", "disabled", "required", "autocomplete"];
const _sfc_main$d = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "Input",
  props: {
    as: { type: null, required: false },
    id: { type: String, required: false },
    name: { type: String, required: false },
    type: { type: null, required: false, default: "text" },
    placeholder: { type: String, required: false },
    color: { type: null, required: false },
    variant: { type: null, required: false },
    size: { type: null, required: false },
    required: { type: Boolean, required: false },
    autocomplete: { type: null, required: false, default: "off" },
    autofocus: { type: Boolean, required: false },
    autofocusDelay: { type: Number, required: false, default: 0 },
    disabled: { type: Boolean, required: false },
    highlight: { type: Boolean, required: false },
    modelValue: { type: null, required: false },
    defaultValue: { type: null, required: false },
    modelModifiers: { type: Object, required: false },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    icon: { type: String, required: false },
    avatar: { type: Object, required: false },
    leading: { type: Boolean, required: false },
    leadingIcon: { type: String, required: false },
    trailing: { type: Boolean, required: false },
    trailingIcon: { type: String, required: false },
    loading: { type: Boolean, required: false },
    loadingIcon: { type: String, required: false }
  },
  emits: ["update:modelValue", "blur", "change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const modelValue = /* @__PURE__ */ useVModel(props, "modelValue", emits, { defaultValue: props.defaultValue });
    const appConfig2 = useAppConfig();
    const { emitFormBlur, emitFormInput, emitFormChange, size: formGroupSize, color, id, name, highlight, disabled, emitFormFocus, ariaAttrs } = useFormField(props, {});
    const { orientation, size: buttonGroupSize } = useButtonGroup(props);
    const { isLeading, isTrailing, leadingIconName, trailingIconName } = useComponentIcons(props);
    const inputSize = computed(() => buttonGroupSize.value || formGroupSize.value);
    const ui = computed(() => tv({ extend: tv(theme), ...appConfig2.ui?.input || {} })({
      type: props.type,
      color: color.value,
      variant: props.variant,
      size: inputSize?.value,
      loading: props.loading,
      highlight: highlight.value,
      leading: isLeading.value || !!props.avatar || !!slots.leading,
      trailing: isTrailing.value || !!slots.trailing,
      buttonGroup: orientation.value
    }));
    const inputRef = ref(null);
    function updateInput(value) {
      if (props.modelModifiers?.trim) {
        value = value?.trim() ?? null;
      }
      if (props.modelModifiers?.number || props.type === "number") {
        value = looseToNumber(value);
      }
      if (props.modelModifiers?.nullify) {
        value ||= null;
      }
      modelValue.value = value;
      emitFormInput();
    }
    function onInput(event) {
      if (!props.modelModifiers?.lazy) {
        updateInput(event.target.value);
      }
    }
    function onChange(event) {
      const value = event.target.value;
      if (props.modelModifiers?.lazy) {
        updateInput(value);
      }
      if (props.modelModifiers?.trim) {
        event.target.value = value.trim();
      }
      emitFormChange();
      emits("change", event);
    }
    function onBlur(event) {
      emitFormBlur();
      emits("blur", event);
    }
    function autoFocus() {
      if (props.autofocus) {
        inputRef.value?.focus();
      }
    }
    onMounted(() => {
      setTimeout(() => {
        autoFocus();
      }, props.autofocusDelay);
    });
    __expose({
      inputRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: __props.as,
        class: normalizeClass(ui.value.root({ class: [props.ui?.root, props.class] }))
      }, {
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            id: unref(id),
            ref_key: "inputRef",
            ref: inputRef,
            type: __props.type,
            value: unref(modelValue),
            name: unref(name),
            placeholder: __props.placeholder,
            class: ui.value.base({ class: props.ui?.base }),
            disabled: unref(disabled),
            required: __props.required,
            autocomplete: __props.autocomplete
          }, { ..._ctx.$attrs, ...unref(ariaAttrs) }, {
            onInput,
            onBlur,
            onChange,
            onFocus: _cache[0] || (_cache[0] = (...args) => unref(emitFormFocus) && unref(emitFormFocus)(...args))
          }), null, 16, _hoisted_1$c),
          renderSlot(_ctx.$slots, "default"),
          unref(isLeading) || !!__props.avatar || !!slots.leading ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(ui.value.leading({ class: props.ui?.leading }))
          }, [
            renderSlot(_ctx.$slots, "leading", {}, () => [
              unref(isLeading) && unref(leadingIconName) ? (openBlock(), createBlock(_sfc_main$l, {
                key: 0,
                name: unref(leadingIconName),
                class: normalizeClass(ui.value.leadingIcon({ class: props.ui?.leadingIcon }))
              }, null, 8, ["name", "class"])) : !!__props.avatar ? (openBlock(), createBlock(_sfc_main$j, mergeProps({
                key: 1,
                size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
              }, __props.avatar, {
                class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar })
              }), null, 16, ["size", "class"])) : createCommentVNode("", true)
            ])
          ], 2)) : createCommentVNode("", true),
          unref(isTrailing) || !!slots.trailing ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(ui.value.trailing({ class: props.ui?.trailing }))
          }, [
            renderSlot(_ctx.$slots, "trailing", {}, () => [
              unref(trailingIconName) ? (openBlock(), createBlock(_sfc_main$l, {
                key: 0,
                name: unref(trailingIconName),
                class: normalizeClass(ui.value.trailingIcon({ class: props.ui?.trailingIcon }))
              }, null, 8, ["name", "class"])) : createCommentVNode("", true)
            ])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["as", "class"]);
    };
  }
});
const _hoisted_1$b = ["aria-label"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "MeIcon",
  props: {
    color: { default: "", type: String },
    hoverColor: { default: "", type: String },
    hoverIcon: { default: "", type: String },
    icon: { default: "", type: String },
    name: { default: "", type: String },
    type: { default: "regular", type: String },
    variant: { default: "", type: String },
    size: { default: "", type: [Number, String] },
    customSize: { default: void 0, type: Number },
    ariaLabel: { default: void 0, type: String }
  },
  setup(__props) {
    const iconTypes = {
      regular: "me-icon",
      solid: "me-icon-s",
      light: "me-icon-l",
      thin: "me-icon-t"
    };
    const variants = ["primary", "success", "danger", "warning"];
    const props = __props;
    const isHover = ref(false);
    const iconStyle = computed(() => {
      const styles = {};
      const baseColor = props.color;
      const hoverColor = props.hoverColor;
      const color = isHover.value ? hoverColor || baseColor : baseColor;
      if (color) styles.color = color;
      if (props.customSize) {
        const size2 = `${props.customSize}px`;
        Object.assign(styles, { width: size2, height: size2, fontSize: size2 });
      } else if (props.size) {
        styles.fontSize = typeof props.size === "number" ? `${props.size}px` : props.size;
      }
      return styles;
    });
    const variantClass = computed(() => {
      return props.variant && variants.includes(props.variant) ? `icon-${props.variant}` : "";
    });
    const variantClasses = computed(() => {
      if (!props.variant) return "";
      const variantMap = {
        primary: "text-blue-600",
        success: "text-green-600",
        warning: "text-yellow-600",
        danger: "text-red-600"
      };
      return variantMap[props.variant] || "";
    });
    const hoverClasses = computed(() => {
      if (!isHover.value) return "";
      if (props.hoverIcon) {
        return "transition-all duration-200";
      }
      if (props.hoverColor) {
        return "transition-colors duration-200";
      }
      return "";
    });
    const currentIcon = computed(() => {
      if (isHover.value && props.hoverIcon) {
        return props.hoverIcon;
      }
      if (props.icon) {
        return props.icon;
      }
      if (props.name) {
        return [iconTypes[props.type], `icon-${props.name}`];
      }
      return [];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", {
        class: normalizeClass([
          currentIcon.value,
          variantClass.value,
          "inline-flex items-center justify-center",
          variantClasses.value,
          hoverClasses.value
        ]),
        style: normalizeStyle(iconStyle.value),
        "aria-label": _ctx.ariaLabel,
        role: "img",
        "data-cy": "icon-element",
        onMouseenter: _cache[0] || (_cache[0] = ($event) => isHover.value = true),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => isHover.value = false)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_1$b);
    };
  }
});
const state = reactive({
  navigationItems: [],
  customNavigationItems: [],
  siteMapItems: []
});
function isSeparator(item) {
  return "separator" in item && item.separator === true;
}
function setNavigationItems(items) {
  state.navigationItems = items;
  state.customNavigationItems = items.filter(
    (item) => !isSeparator(item)
  );
}
function setCustomNavigationItems(items) {
  const updatedItems = [];
  let i2 = 0;
  for (const item of state.navigationItems) {
    updatedItems.push(isSeparator(item) ? item : items[i2++] ?? item);
  }
  state.customNavigationItems = items;
  state.navigationItems = updatedItems;
}
function setSiteMapItems(items) {
  state.siteMapItems = items;
}
function findNavigationItemById(id) {
  const foundItem = state.navigationItems.find(
    (navItem) => !isSeparator(navItem) && navItem.id === id
  );
  return foundItem;
}
function updateNavigationItemsVisible(item, visible) {
  const targetItem = findNavigationItemById(item.id);
  if (targetItem) {
    targetItem.visible = visible;
    state.navigationItems = [...state.navigationItems];
  }
}
function useNavigationStore() {
  return {
    ...toRefs(state),
    setNavigationItems,
    setCustomNavigationItems,
    setSiteMapItems,
    isSeparator,
    updateNavigationItemsVisible
  };
}
function isExternalUrl(url) {
  return /^https?:\/\//i.test(url);
}
const _hoisted_1$a = { class: "max-h-[280px] overflow-y-auto" };
const _hoisted_2$5 = { class: "space-y-2" };
const _hoisted_3$3 = ["href", "target"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderTabsSiteMapItems",
  setup(__props) {
    const { siteMapItems } = useNavigationStore();
    const searchTerm = ref("");
    const normalize = (text) => text.trim().toLowerCase();
    const matchesSearch = (item, term) => {
      if (!term) return true;
      return normalize(item.description).includes(term) || item.children?.some((child) => matchesSearch(child, term)) || false;
    };
    const filterSiteMap = (items, term) => items.map((section) => {
      const matchingChildren = section.children.filter(
        (child) => matchesSearch(child, term)
      );
      if (matchingChildren.length) {
        return { ...section, children: matchingChildren };
      }
      return matchesSearch(section, term) ? section : null;
    }).filter((section) => section !== null);
    const filteredSiteMap = computed(() => {
      if (!siteMapItems.value) return [];
      const term = normalize(searchTerm.value);
      return term ? filterSiteMap(siteMapItems.value, term) : siteMapItems.value;
    });
    const accordionItems = computed(
      () => filteredSiteMap.value.map((section, index2) => ({
        label: section.description,
        value: `section-${index2}`,
        children: section.children
      }))
    );
    const getTarget = (url) => isExternalUrl(url) ? "_blank" : "_self";
    return (_ctx, _cache) => {
      const _component_UInput = _sfc_main$d;
      const _component_UAccordion = _sfc_main$e;
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_UInput, {
          modelValue: searchTerm.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => searchTerm.value = $event),
          icon: "i-lucide-search",
          size: "md",
          variant: "outline",
          placeholder: "Buscar",
          class: "mb-3 w-full"
        }, createSlots({ _: 2 }, [
          searchTerm.value ? {
            name: "trailing",
            fn: withCtx(() => [
              createBaseVNode("button", {
                type: "button",
                class: "inline-flex size-8 items-center justify-center rounded-md text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:pointer-events-none disabled:opacity-50",
                onClick: _cache[0] || (_cache[0] = ($event) => searchTerm.value = "")
              }, [
                createVNode(_sfc_main$c, { icon: "me-icon-l icon-xmark" })
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["modelValue"]),
        createBaseVNode("div", _hoisted_1$a, [
          createVNode(_component_UAccordion, {
            type: "multiple",
            items: accordionItems.value,
            class: "w-full pr-2",
            ui: {
              item: "border-none",
              header: "border-none",
              trigger: "border-none"
            }
          }, {
            content: withCtx(({ item }) => [
              createBaseVNode("div", _hoisted_2$5, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(item.children, (child, idx) => {
                  return openBlock(), createElementBlock("a", {
                    key: idx,
                    href: child.url || "#",
                    target: child.url ? getTarget(child.url) : void 0,
                    class: "block cursor-pointer rounded-md p-2 text-sm text-gray-600 no-underline transition-colors hover:bg-gray-100 hover:text-gray-800"
                  }, toDisplayString(child.description), 9, _hoisted_3$3);
                }), 128))
              ])
            ]),
            _: 1
          }, 8, ["items"])
        ])
      ]);
    };
  }
});
/**!
 * Sortable 1.15.6
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.6";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector) return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state2) {
  if (el && name) {
    if (el.classList) {
      el.classList[state2 ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state2 ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator2) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n = list.length;
    if (iterator2) {
      for (; i2 < n; i2++) {
        iterator2(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    {
      visible = elSideVal >= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i2 = 0, children = el.children;
  while (i2 < children.length) {
    if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key]) return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state2) {
      animationStates.push(state2);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function") callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state2) {
        var time = 0, target = state2.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function") callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function") callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2)) continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function") return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable) return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event[i2] = evt[i2];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable) return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, "pointerup", _this._onDrop);
        !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
      } else {
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
      }
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._disableDelayedDrag);
          on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
        } else {
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        }
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "pointerup", this._disableDelayedDrag);
    off(ownerDocument, "pointercancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "pointercancel", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray2() {
    var order = [], el, children = this.el.children, i2 = 0, n = children.length, options = this.options;
    for (; i2 < n; i2++) {
      el = children[i2];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted2(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll) return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function useSortable(el, list, options = {}) {
  let sortable;
  const { document: document2 = defaultDocument, ...resetOptions } = options;
  const defaultOptions = {
    onUpdate: (e) => {
      moveArrayElement(list, e.oldIndex, e.newIndex, e);
    }
  };
  const start = () => {
    const target = typeof el === "string" ? document2 == null ? void 0 : document2.querySelector(el) : unrefElement(el);
    if (!target || sortable !== void 0)
      return;
    sortable = new Sortable(target, { ...defaultOptions, ...resetOptions });
  };
  const stop2 = () => {
    sortable == null ? void 0 : sortable.destroy();
    sortable = void 0;
  };
  const option2 = (name, value) => {
    if (value !== void 0)
      sortable == null ? void 0 : sortable.option(name, value);
    else
      return sortable == null ? void 0 : sortable.option(name);
  };
  tryOnMounted(start);
  tryOnScopeDispose(stop2);
  return {
    stop: stop2,
    start,
    option: option2
  };
}
function insertNodeAt(parentElement, element, index2) {
  const refElement = parentElement.children[index2];
  parentElement.insertBefore(element, refElement);
}
function removeNode(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
}
function moveArrayElement(list, from, to, e = null) {
  if (e != null) {
    removeNode(e.item);
    insertNodeAt(e.from, e.item, from);
  }
  const _valueIsRef = isRef(list);
  const array = _valueIsRef ? [...toValue$2(list)] : toValue$2(list);
  if (to >= 0 && to < array.length) {
    const element = array.splice(from, 1)[0];
    nextTick(() => {
      array.splice(to, 0, element);
      if (_valueIsRef)
        list.value = array;
    });
  }
}
const _hoisted_1$9 = { class: "flex flex-col" };
const _hoisted_2$4 = { class: "text-sm text-primary py-2 px-6 bg-[var(--color-blue-50)] rounded-lg mb-2 flex justify-between font-medium" };
const _hoisted_3$2 = { class: "flex items-center gap-2 text-[var(--color-neutral-400)] h-12 pl-2" };
const _hoisted_4$1 = { class: "icon-container" };
const _hoisted_5$1 = ["href", "target"];
const _hoisted_6$1 = {
  key: 1,
  class: "text-label text-sm flex-1"
};
const _hoisted_7 = ["onClick"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderTabsNavigationItems",
  setup(__props) {
    const {
      customNavigationItems,
      setCustomNavigationItems: setCustomNavigationItems2,
      updateNavigationItemsVisible: updateNavigationItemsVisible2
    } = useNavigationStore();
    const el = useTemplateRef("el");
    const list = shallowRef(customNavigationItems.value || []);
    const getCountNavigationItems = computed(() => {
      const total = customNavigationItems.value?.length;
      const actives = customNavigationItems.value?.filter((i2) => i2.visible).length;
      return `${actives}/${total}`;
    });
    const getTarget = (url) => {
      return isExternalUrl(url) ? "_blank" : "_self";
    };
    function addDragClasses(item) {
      item.classList.add(
        "border",
        "border-[var(--ui-primary)]",
        "text-[var(--ui-primary)]",
        "rounded-lg"
      );
      const textLabel = item.querySelector(".text-label");
      if (textLabel) {
        textLabel.classList.add("text-[var(--ui-primary)]");
      }
      const iconContainer = item.querySelector(".icon-container");
      if (iconContainer) {
        iconContainer.classList.add("text-[var(--ui-primary)]");
      }
      const buttonIcon = item.querySelector(".button-icon");
      if (buttonIcon) {
        buttonIcon.classList.add("text-[var(--ui-primary)]");
      }
    }
    function removeDragClasses(item) {
      item.classList.remove(
        "border",
        "border-[var(--ui-primary)]",
        "text-[var(--ui-primary)]",
        "rounded-lg"
      );
      const textLabel = item.querySelector(".text-label");
      if (textLabel) {
        textLabel.classList.remove("text-[var(--ui-primary)]");
      }
      const iconContainer = item.querySelector(".icon-container");
      if (iconContainer) {
        iconContainer.classList.remove("text-[var(--ui-primary)]");
      }
      const buttonIcon = item.querySelector(".button-icon");
      if (buttonIcon) {
        buttonIcon.classList.remove("text-[var(--ui-primary)]");
      }
    }
    useSortable(el, list, {
      animation: 150,
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      onStart: (evt) => addDragClasses(evt.item),
      onEnd: (evt) => removeDragClasses(evt.item),
      onChange: () => {
      }
    });
    watch(list, (newList) => setCustomNavigationItems2(toRaw(newList)));
    function handleClick(item) {
      const currentVisibility = item.visible ?? false;
      updateNavigationItemsVisible2(item, !currentVisibility);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$4, [
          _cache[1] || (_cache[1] = createBaseVNode("p", null, "Apps fixados no header:", -1)),
          createBaseVNode("span", null, toDisplayString(getCountNavigationItems.value), 1)
        ]),
        createBaseVNode("div", {
          ref_key: "el",
          ref: el,
          class: "overflow-y-auto max-h-[280px]"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(list.value, (item, index2) => {
            return openBlock(), createElementBlock("div", {
              key: index2,
              class: "hover:bg-gray-500/10 transition-colors cursor-pointer border-b border-[var(--color-neutral-100)] mr-2"
            }, [
              createBaseVNode("div", _hoisted_3$2, [
                createBaseVNode("div", _hoisted_4$1, [
                  createVNode(_sfc_main$c, {
                    icon: "me-icon-s icon-grid-horizontal",
                    class: "text-inherit",
                    "custom-size": 12
                  })
                ]),
                item.url ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  href: item.url,
                  target: getTarget(item.url),
                  class: "text-label text-sm no-underline flex-1",
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, toDisplayString(item.label), 9, _hoisted_5$1)) : (openBlock(), createElementBlock("span", _hoisted_6$1, toDisplayString(item.label), 1)),
                !item?.siteMap ? (openBlock(), createElementBlock("button", {
                  key: 2,
                  class: "ml-auto size-12",
                  onClick: withModifiers(() => handleClick(item), ["stop"])
                }, [
                  createVNode(_sfc_main$c, {
                    icon: "me-icon-l icon-eye-slash",
                    class: "button-icon",
                    "custom-size": 14,
                    color: item.visible ? "var(--ui-primary)" : "var(--color-neutral-200)"
                  }, null, 8, ["color"])
                ], 8, _hoisted_7)) : createCommentVNode("", true)
              ])
            ]);
          }), 128))
        ], 512)
      ]);
    };
  }
});
const _hoisted_1$8 = { class: "p-4 w-[384px]" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderTabs",
  setup(__props) {
    const items = ref([
      {
        label: "Apps",
        slot: "navigationItems"
      },
      {
        label: "Outras funcionalidades",
        slot: "siteMapItems"
      }
    ]);
    return (_ctx, _cache) => {
      const _component_UTabs = _sfc_main$f;
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createVNode(_component_UTabs, {
          items: items.value,
          class: "w-full",
          size: "xs",
          variant: "pill",
          color: "neutral",
          ui: {
            list: "grid grid-cols-2 w-full",
            trigger: "flex-1 text-center cursor-pointer data-[state=active]:bg-white data-[state=active]:text-gray-900 focus:outline-none focus-visible:outline-none",
            indicator: "bg-white"
          }
        }, {
          navigationItems: withCtx(() => [
            createBaseVNode("keep-alive", null, [
              (openBlock(), createBlock(Suspense, null, {
                fallback: withCtx(() => _cache[0] || (_cache[0] = [
                  createBaseVNode("div", { class: "p-4 text-center text-gray-500" }, "Carregando...", -1)
                ])),
                default: withCtx(() => [
                  createVNode(_sfc_main$a)
                ]),
                _: 1
              }))
            ])
          ]),
          siteMapItems: withCtx(() => [
            createBaseVNode("keep-alive", null, [
              (openBlock(), createBlock(Suspense, null, {
                fallback: withCtx(() => _cache[1] || (_cache[1] = [
                  createBaseVNode("div", { class: "p-4 text-center text-gray-500" }, "Carregando...", -1)
                ])),
                default: withCtx(() => [
                  createVNode(_sfc_main$b)
                ]),
                _: 1
              }))
            ])
          ]),
          _: 1
        }, 8, ["items"])
      ]);
    };
  }
});
const _hoisted_1$7 = { class: "relative flex items-center justify-center" };
const _hoisted_2$3 = { class: "text-xs py-[6px] text-[var(--header-icon-color)]" };
const activeClass = "after:content-[''] after:bg-[var(--header-icon-color)] after:h-1 after:rounded-full after:absolute after:block after:w-[80%] after:bottom-0 after:left-1/2 after:-translate-x-1/2";
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderNavigationItemContent",
  props: {
    iconColor: { type: String },
    id: { type: String },
    icon: { type: [String, null] },
    label: { type: [String, null] },
    active: { type: Boolean },
    click: { type: Function },
    siteMap: { type: [Boolean, null] },
    linkName: { type: [String, null] },
    url: { type: [String, null] },
    target: { type: [String, null] },
    badgeTotalUrl: { type: [String, null] },
    badgeEvent: { type: [String, null] },
    badge: { type: [Object, null] },
    visible: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const isLink = computed(() => Boolean(props.url));
    function handleClick() {
      props.click?.(props);
    }
    return (_ctx, _cache) => {
      const _component_UChip = _sfc_main$k;
      return openBlock(), createBlock(resolveDynamicComponent(isLink.value ? "a" : "button"), {
        href: isLink.value ? _ctx.url : void 0,
        target: isLink.value ? _ctx.target ?? "_self" : void 0,
        type: !isLink.value ? "button" : void 0,
        class: normalizeClass(["grid place-items-center gap-1 px-2 py-1 cursor-pointer relative transition-colors duration-200 hover:bg-[rgba(0,0,0,0.1)] text-[var(--color-neutral-300)] text-center", [
          isLink.value ? "no-underline" : "border-0 bg-transparent",
          _ctx.active && activeClass
        ]]),
        style: normalizeStyle({ "--header-icon-color": _ctx.iconColor }),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.click && handleClick)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$7, [
            createVNode(_sfc_main$c, {
              icon: _ctx.icon || "",
              "custom-size": 24,
              color: _ctx.iconColor
            }, null, 8, ["icon", "color"]),
            _ctx.badge?.text ? (openBlock(), createBlock(_component_UChip, {
              key: 0,
              text: _ctx.badge.text,
              color: "error",
              size: "3xl",
              position: "top-right",
              inset: false,
              ui: {
                base: "px-2 py-3 ring-0 font-semibold",
                root: "translate-x-2"
              }
            }, null, 8, ["text"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("p", _hoisted_2$3, toDisplayString(_ctx.label), 1)
        ]),
        _: 1
      }, 8, ["href", "target", "type", "class", "style"]);
    };
  }
});
const _hoisted_1$6 = {
  key: 0,
  class: "relative"
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderNavigationItem",
  props: {
    iconColor: { type: String },
    id: { type: String },
    icon: { type: [String, null] },
    label: { type: [String, null] },
    active: { type: Boolean },
    click: { type: Function },
    siteMap: { type: [Boolean, null] },
    linkName: { type: [String, null] },
    url: { type: [String, null] },
    target: { type: [String, null] },
    badgeTotalUrl: { type: [String, null] },
    badgeEvent: { type: [String, null] },
    badge: { type: [Object, null] },
    visible: { type: Boolean }
  },
  setup(__props) {
    const isOpen = ref(false);
    const headerBackdrop = inject("headerBackdrop");
    function handlePopoverUpdate(open) {
      isOpen.value = open;
      if (open) {
        headerBackdrop?.show(9999);
      } else {
        headerBackdrop?.close();
      }
    }
    watch(isOpen, (newValue) => {
      if (!newValue) {
        headerBackdrop?.close();
      }
    });
    return (_ctx, _cache) => {
      const _component_TheHeaderTabs = _sfc_main$9;
      const _component_UPopover = _sfc_main$h;
      return _ctx.siteMap ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
        createVNode(_component_UPopover, {
          open: isOpen.value,
          ui: {
            content: "z-[10001]",
            arrow: "z-[10001]"
          },
          mode: "click",
          arrow: "",
          "onUpdate:open": handlePopoverUpdate
        }, {
          content: withCtx(() => [
            createVNode(_component_TheHeaderTabs)
          ]),
          default: withCtx(() => [
            createVNode(_sfc_main$8, {
              icon: _ctx.icon,
              label: _ctx.label,
              iconColor: _ctx.iconColor,
              active: _ctx.active,
              click: _ctx.click
            }, null, 8, ["icon", "label", "iconColor", "active", "click"])
          ]),
          _: 1
        }, 8, ["open"])
      ])) : (openBlock(), createBlock(_sfc_main$8, {
        key: 1,
        icon: _ctx.icon,
        label: _ctx.label,
        iconColor: _ctx.iconColor,
        active: _ctx.active,
        click: _ctx.click
      }, null, 8, ["icon", "label", "iconColor", "active", "click"]));
    };
  }
});
const _hoisted_1$5 = { class: "ml-auto flex justify-center gap-6" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderNavigation",
  props: {
    iconColor: { type: String }
  },
  setup(__props) {
    const { navigationItems, isSeparator: isSeparator2 } = useNavigationStore();
    const filteredNavigationItems = computed(() => {
      const filtered = [];
      let lastWasSeparator = false;
      for (const item of navigationItems.value) {
        if (isSeparator2(item)) {
          if (lastWasSeparator) continue;
          filtered.push(item);
          lastWasSeparator = true;
        } else if (item.visible !== false) {
          filtered.push(item);
          lastWasSeparator = false;
        }
      }
      return filtered;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(filteredNavigationItems.value, (item, index2) => {
          return openBlock(), createElementBlock(Fragment, {
            key: unref(isSeparator2)(item) ? `separator-${index2}` : item.label
          }, [
            unref(isSeparator2)(item) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "my-2 border-l",
              style: normalizeStyle({ borderColor: _ctx.iconColor })
            }, null, 4)) : item.visible ?? false ? (openBlock(), createBlock(_sfc_main$7, mergeProps({
              key: 1,
              ref_for: true
            }, item, { iconColor: _ctx.iconColor }), null, 16, ["iconColor"])) : createCommentVNode("", true)
          ], 64);
        }), 128))
      ]);
    };
  }
});
const _hoisted_1$4 = { class: "cursor-pointer overflow-hidden rounded-bl-lg" };
const _hoisted_2$2 = ["href", "onClick"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderAvatarMenuItem",
  props: {
    profileItems: { type: Array },
    setVisibleToFalse: { type: Function },
    nested: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    function accordionItems(item) {
      const { icon, ...rest } = item;
      return [
        {
          ...rest,
          label: icon ? `${icon.class} ${item.label || ""}` : item.label || "",
          children: item.children || []
        }
      ];
    }
    function handleClick(item) {
      const { url, click } = item;
      const target = item.target ?? "_blank";
      if (url) {
        if (isExternalUrl(url)) {
          window.open(url, target, "noopener,noreferrer");
        } else {
          window.location.href = url;
        }
        props.setVisibleToFalse();
        return;
      }
      if (click) {
        click();
        props.setVisibleToFalse();
      }
    }
    return (_ctx, _cache) => {
      const _component_TheHeaderAvatarMenuItem = resolveComponent("TheHeaderAvatarMenuItem", true);
      const _component_UAccordion = _sfc_main$e;
      return openBlock(), createElementBlock("ul", _hoisted_1$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.profileItems, (item, index2) => {
          return openBlock(), createElementBlock("li", { key: index2 }, [
            item.children ? (openBlock(), createBlock(_component_UAccordion, {
              key: 0,
              items: accordionItems(item),
              ui: {
                body: "p-0",
                trigger: `py-2 px-4 hover:bg-blue-100 hover:text-primary flex navigationItems-center gap-2 cursor-pointer font-normal ${item.active ? "text-primary" : ""}`
              }
            }, {
              body: withCtx(({ item: accordionItem }) => [
                createVNode(_component_TheHeaderAvatarMenuItem, {
                  "profile-items": accordionItem.children || [],
                  "set-visible-to-false": _ctx.setVisibleToFalse,
                  nested: ""
                }, null, 8, ["profile-items", "set-visible-to-false"])
              ]),
              _: 2
            }, 1032, ["items", "ui"])) : (openBlock(), createElementBlock("a", {
              key: 1,
              class: "flex h-10 cursor-pointer items-center gap-2 px-4 py-2 group hover:text-primary hover:bg-blue-100",
              href: item.url || "#",
              onClick: withModifiers(() => handleClick(item), ["prevent"])
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["text-gray-500 group-hover:text-primary", {
                  "text-[var(--color-neutral-400)] font-semibold": props.nested && !item.active
                }])
              }, toDisplayString(item.label), 3),
              createBaseVNode("span", null, [
                item.icon ? (openBlock(), createBlock(_sfc_main$c, {
                  key: 0,
                  icon: item.icon.class,
                  "custom-size": 16,
                  color: item.icon.color,
                  class: "leading-none"
                }, null, 8, ["icon", "color"])) : createCommentVNode("", true)
              ])
            ], 8, _hoisted_2$2))
          ]);
        }), 128))
      ]);
    };
  }
});
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderAvatarChip",
  props: {
    user: { type: Object }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      const _component_MeIcon = _sfc_main$c;
      const _component_UChip = _sfc_main$k;
      return _ctx.user.badge.icon ? (openBlock(), createBlock(_component_UChip, {
        key: 0,
        color: "error",
        size: "3xl",
        position: "bottom-right",
        inset: false,
        ui: {
          base: "p-2 ring-0 font-semibold",
          root: "translate-x-1 translate-y-3"
        }
      }, {
        content: withCtx(() => [
          createVNode(_component_MeIcon, {
            icon: props.user.badge.icon,
            color: props.user.badge.variant || "danger"
          }, null, 8, ["icon", "color"])
        ]),
        _: 1
      })) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$3 = { class: "relative flex select-none flex-col items-end" };
const _hoisted_2$1 = { class: "flex justify-between gap-4 px-4 py-2 align-center" };
const _hoisted_3$1 = { class: "grid w-[168px]" };
const _hoisted_4 = { class: "mb-0 truncate text-gray-500" };
const _hoisted_5 = { class: "block truncate text-xs text-gray-400" };
const _hoisted_6 = { class: "text-2xl font-normal no-underline" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderAvatarMenu",
  props: {
    user: { type: Object },
    profileItems: { type: Array },
    setVisibleToFalse: { type: Function }
  },
  setup(__props) {
    const menuAvatar = useTemplateRef("menuAvatar");
    const avatar = useTemplateRef("avatar");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", {
          ref_key: "menuAvatar",
          ref: menuAvatar,
          class: "absolute rounded-bl-lg bg-white text-sm top-[-1px] right-[-8px]"
        }, [
          createBaseVNode("div", _hoisted_2$1, [
            createBaseVNode("div", _hoisted_3$1, [
              createBaseVNode("p", _hoisted_4, toDisplayString(_ctx.user.name), 1),
              createBaseVNode("small", _hoisted_5, toDisplayString(_ctx.user.role || _ctx.user.email || ""), 1)
            ]),
            createBaseVNode("div", {
              ref_key: "avatar",
              ref: avatar,
              class: "flex cursor-pointer items-center justify-center rounded-full text-white size-12 bg-primary"
            }, [
              createBaseVNode("span", _hoisted_6, toDisplayString(_ctx.user.acronym), 1),
              createVNode(_sfc_main$4, { user: _ctx.user }, null, 8, ["user"])
            ], 512)
          ]),
          createVNode(_sfc_main$5, {
            profileItems: _ctx.profileItems,
            "set-visible-to-false": _ctx.setVisibleToFalse
          }, null, 8, ["profileItems", "set-visible-to-false"])
        ], 512)
      ]);
    };
  }
});
const _hoisted_1$2 = { class: "group py-2 px-4 hover:bg-[rgba(0,0,0,0.1)] cursor-pointer" };
const _hoisted_2 = { class: "flex items-center justify-center size-12 rounded-full bg-[rgba(0,0,0,0.4)] mx-auto border-transparent border group-hover:border-white group-hover:border-2" };
const _hoisted_3 = { class: "text-2xl uppercase" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "TheHeaderAvatar",
  props: {
    user: { type: Object },
    profileItems: { type: Array }
  },
  setup(__props) {
    const props = __props;
    const visibleMenu = ref(false);
    const headerBackdrop = inject("headerBackdrop");
    function handlePopoverUpdate(open) {
      if (open) {
        headerBackdrop?.show(9999);
      } else {
        headerBackdrop?.close();
      }
    }
    function setVisibleToFalse() {
      visibleMenu.value = false;
      headerBackdrop?.close();
    }
    watch(visibleMenu, (newValue) => {
      if (!newValue) {
        headerBackdrop?.close();
      }
    });
    onBeforeUnmount(() => {
      setVisibleToFalse();
    });
    return (_ctx, _cache) => {
      const _component_UPopover = _sfc_main$h;
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_UPopover, {
          open: visibleMenu.value,
          "onUpdate:open": [
            _cache[0] || (_cache[0] = ($event) => visibleMenu.value = $event),
            handlePopoverUpdate
          ],
          content: {
            align: "end",
            side: "bottom",
            sideOffset: -63
          },
          ui: {
            content: "z-[10003]"
          },
          mode: "click"
        }, {
          content: withCtx(() => [
            createVNode(_sfc_main$3, {
              user: props.user,
              profileItems: props.profileItems,
              "set-visible-to-false": setVisibleToFalse
            }, null, 8, ["user", "profileItems"])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$2, [
              createBaseVNode("div", _hoisted_2, [
                createBaseVNode("span", _hoisted_3, toDisplayString(props.user.acronym), 1),
                createVNode(_sfc_main$4, {
                  user: props.user
                }, null, 8, ["user"])
              ])
            ])
          ]),
          _: 1
        }, 8, ["open"])
      ]);
    };
  }
});
const _hoisted_1$1 = { class: "size-full" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "AppBackdrop",
  props: {
    teleportTo: { default: "body", type: String },
    class: { type: String },
    zIndex: { default: 1e4, type: Number }
  },
  emits: ["click"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: _ctx.teleportTo }, [
        createBaseVNode("div", {
          class: normalizeClass([
            "size-full fixed top-0 left-0 right-0 bottom-0 bg-[rgba(0,0,0,0.4)]",
            __props.class
          ]),
          style: normalizeStyle({ zIndex: _ctx.zIndex })
        }, [
          createBaseVNode("div", _hoisted_1$1, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 6)
      ], 8, ["to"]);
    };
  }
});
const _hoisted_1 = { class: "flex items-center justify-between" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "TheHeader.ce",
  setup(__props) {
    const navigationStore = useNavigationStore();
    const backdropState = ref({
      visible: false,
      zIndex: 9999
    });
    function showBackdrop(zIndex = 9999) {
      backdropState.value = {
        visible: true,
        zIndex
      };
    }
    function closeBackdrop() {
      backdropState.value.visible = false;
    }
    provide("headerBackdrop", {
      show: showBackdrop,
      close: closeBackdrop,
      state: backdropState
    });
    const brand = ref({
      logo: "https://eletrods.me.com.br/logo.svg",
      link: "https://me.com.br",
      newTab: true,
      background: {
        // primaryColor: '#343434',
        // secondaryColor: '#009900',
        // iconColor: 'peachPuff'
        // repeatImage: 'https://conteudo.imguol.com.br/c/home/46/2020/03/02/balaio-do-kotscho-150-1583157444753_100x100.jpg.webp',
        // mainImage: 'https://conteudo.imguol.com.br/c/noticias/90/2019/04/01/leonardo-sakamoto-1554157201028_v2_100x100.jpg.webp',
      }
    });
    const user = ref({
      name: "Renato Dias",
      role: "Developer",
      acronym: "RD",
      badge: {
        variant: "danger",
        icon: "me-icon-l icon-exclamation"
      }
    });
    const profileItems = ref([
      {
        $id: "15",
        label: "Perfil",
        url: "/user/details/606660",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      },
      {
        $id: "16",
        label: "Configuraes Gerais",
        url: "/preferences",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      },
      {
        $id: "17",
        label: "Substituir Usurio",
        url: "/do/ChangeUser.mvc",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      },
      {
        $id: "18",
        label: "Substituio de Workflow",
        url: "/do/Usuario.mvc/SubstituirWorkflow",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      },
      {
        $id: "19",
        label: "Substituio temporria",
        url: "/do/Substituicao.mvc",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      },
      {
        $id: "20",
        label: "Novidades e Atualizaes",
        url: "https://guide.me.com.br",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: "_blank"
      },
      {
        $id: "21",
        label: "Portugus BR",
        url: null,
        active: true,
        name: "locale",
        icon: null,
        children: [
          {
            $id: "22",
            label: "Ingls",
            url: "javascript:jQuery.MELocaleChange('en-US');",
            active: false,
            name: "2",
            icon: null,
            children: null,
            target: null
          },
          {
            $id: "23",
            label: "Espanhol",
            url: "javascript:jQuery.MELocaleChange('es-ES');",
            active: false,
            name: "3",
            icon: null,
            children: null,
            target: null
          },
          {
            $id: "24",
            label: "Portugus PT",
            url: "javascript:jQuery.MELocaleChange('pt-PT');",
            active: false,
            name: "4",
            icon: null,
            children: null,
            target: null
          },
          {
            $id: "25",
            label: "Espanhol MX",
            url: "javascript:jQuery.MELocaleChange('es-MX');",
            active: false,
            name: "7",
            icon: null,
            children: null,
            target: null
          },
          {
            $id: "26",
            label: "Francs",
            url: "javascript:jQuery.MELocaleChange('fr-FR');",
            active: false,
            name: "8",
            icon: null,
            children: null,
            target: null
          }
        ],
        target: null
      },
      {
        $id: "27",
        label: "Logoff",
        url: "/FimSecao.asp",
        active: false,
        name: null,
        icon: null,
        children: null,
        target: null
      }
    ]);
    navigationStore.setNavigationItems([
      {
        id: "5",
        linkName: "DASHBOARD",
        visible: true,
        label: "Dashboard",
        icon: "me-icon-l icon-objects-column",
        url: "/dashboard/",
        target: null,
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "6",
        linkName: null,
        visible: true,
        label: null,
        icon: null,
        url: null,
        target: null,
        active: false,
        siteMap: false,
        separator: true,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "7",
        linkName: "HOME",
        visible: true,
        label: "Transaes",
        icon: "me-icon-l icon-file-import",
        url: "/home",
        target: null,
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null,
        badge: {
          text: "9999"
        }
      },
      {
        id: "8",
        linkName: "SUPPLIER",
        visible: true,
        label: "Fornecedores",
        icon: "me-icon-l icon-store",
        url: "/supplier/search",
        target: null,
        active: true,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null,
        click: () => console.log("Fornecedores"),
        badge: {
          text: "76"
        }
      },
      {
        id: "9",
        linkName: "PRODUCT",
        visible: true,
        label: "Catlogos",
        icon: "me-icon-l icon-shopping-bag",
        url: "/product/",
        target: null,
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "10",
        linkName: "USER",
        visible: false,
        label: "Usurios",
        icon: "me-icon-l icon-users",
        url: "/user/",
        target: null,
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "11",
        linkName: "MORE",
        visible: true,
        label: "Mais",
        icon: "me-icon-l icon-ellipsis-stroke",
        url: null,
        target: null,
        active: false,
        siteMap: true,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "12",
        linkName: null,
        visible: true,
        label: null,
        icon: null,
        url: null,
        target: null,
        active: false,
        siteMap: false,
        separator: true,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "13",
        linkName: "BOOST",
        visible: true,
        label: "ME Boost",
        icon: "me-icon-l icon-chart-mixed",
        url: "https://analytics.meboost.com.br/_/boost/jbs/app/kibana#/dashboards?_g=()",
        target: "_blank",
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: null,
        badgeEvent: null
      },
      {
        id: "14",
        linkName: "MESSAGES",
        visible: false,
        label: "Mensagens",
        icon: "me-icon-l icon-comments",
        url: "/chat",
        target: null,
        active: false,
        siteMap: false,
        separator: false,
        badgeTotalUrl: "https://trunk.api.web.mercadoe.com/chat-api-bff/v1/messages/unread",
        badgeEvent: null
      }
    ]);
    navigationStore.setSiteMapItems([
      {
        id: "2",
        name: "1",
        description: "Painel de Controle",
        url: "",
        children: [
          {
            id: "3",
            name: "1_1",
            description: "Compras",
            url: "/Mercado.asp",
            children: []
          },
          {
            id: "4",
            name: "1_2",
            description: "Vendas",
            url: "/MeuMercadoVendas.asp",
            children: []
          },
          {
            id: "5",
            name: "1_5",
            description: "Vendas (Projetos)",
            url: "/ME/PainelControleVendasProjetos.aspx",
            children: []
          }
        ]
      },
      {
        id: "6",
        name: "2",
        description: "Usurios",
        url: "",
        children: [
          {
            id: "7",
            name: "2_0",
            description: "Usurios",
            url: "/user/",
            children: []
          },
          {
            id: "8",
            name: "2_1",
            description: "Perfis",
            url: "/ME/Perfil.aspx",
            children: []
          },
          {
            id: "9",
            name: "2_8",
            description: "Perfis Planeamento",
            url: "/ME/PerfilPlaneamento.aspx",
            children: []
          },
          {
            id: "10",
            name: "2_3",
            description: "Grupos De Usurios",
            url: "/ME/ListaGruposUsuariosWF.aspx",
            children: []
          },
          {
            id: "11",
            name: "2_6",
            description: "Monitoramento de Usurios",
            url: "/ME/MonitoraUsuariosWF.aspx",
            children: []
          },
          {
            id: "12",
            name: "2_7",
            description: "Histrico de Substituio",
            url: "/do/HistoricoSubstituicaoPerfil.mvc",
            children: []
          }
        ]
      },
      {
        id: "13",
        name: "3",
        description: "Produtos",
        url: "",
        children: [
          {
            id: "14",
            name: "3_0",
            description: "Meus Produtos",
            url: "/ListaTodosProdutosIE.asp",
            children: []
          },
          {
            id: "15",
            name: "3_1",
            description: "Grupos de Produtos",
            url: "/ListaGruposProd.asp",
            children: []
          },
          {
            id: "16",
            name: "3_7",
            description: "Flows de Produtos",
            url: "/ME/ListaFlows.aspx",
            children: []
          },
          {
            id: "17",
            name: "3_3",
            description: "Catlogo de Compras",
            url: "/ListaProdutos.asp",
            children: []
          },
          {
            id: "18",
            name: "3_5",
            description: "Catlogos Fornecedores",
            url: "/do/Suppliers.mvc/Catalogo",
            children: []
          },
          {
            id: "19",
            name: "3_10",
            description: "Templates de Cotao",
            url: "/CotacaoTemplate.asp",
            children: []
          },
          {
            id: "20",
            name: "3_11",
            description: "Gerenciamento de Contratos",
            url: "/ME/GerenciamentoContrato.aspx",
            children: []
          },
          {
            id: "21",
            name: "3_23",
            description: "Categorias de Contratos",
            url: "/do/CategoriaContrato.mvc",
            children: []
          },
          {
            id: "22",
            name: "3_22",
            description: "Grupo de Workflow",
            url: "/ME/GrupoWorkflow.aspx",
            children: []
          },
          {
            id: "23",
            name: "3_12",
            description: "Templates de Requisio",
            url: "/ME/TemplateReq.aspx",
            children: []
          },
          {
            id: "24",
            name: "3_16",
            description: "Taxas de ICMS",
            url: "/ME/TaxaICMS.aspx",
            children: []
          },
          {
            id: "25",
            name: "3_14",
            description: "Excees de ICMS",
            url: "/ME/ExcecaoICMS.aspx",
            children: []
          },
          {
            id: "26",
            name: "3_15",
            description: "Excees de IPI",
            url: "/ME/ExcecaoIPI.aspx",
            children: []
          },
          {
            id: "27",
            name: "3_17",
            description: "Controle de NBM",
            url: "/do/NBM.mvc",
            children: []
          },
          {
            id: "28",
            name: "3_18",
            description: "Fator de Converso de Unidade",
            url: "/ME/ConversaoUnidadeSimples.aspx",
            children: []
          },
          {
            id: "29",
            name: "3_19",
            description: "Atributos Produtos",
            url: "/Produtos.asp?action=listaAtributosProduto",
            children: []
          },
          {
            id: "30",
            name: "3_20",
            description: "Abreviaturas",
            url: "/Produtos.asp?action=listaAbreviaturas",
            children: []
          },
          {
            id: "31",
            name: "3_21",
            description: "Sinnimos",
            url: "/Produtos.asp?action=listaSinonimos",
            children: []
          },
          {
            id: "32",
            name: "3_25",
            description: "Templates de Carrinho",
            url: "/ME/TemplateCarrinho.aspx",
            children: []
          },
          {
            id: "33",
            name: "3_28",
            description: "Associao Produto X Fornecedor X Fabricante",
            url: "/do/FornecedorFabricanteProduto.mvc",
            children: []
          },
          {
            id: "34",
            name: "3_29",
            description: "Situao de Estoque e Previso de Demanda",
            url: "/do/SituacaoEstoque.mvc",
            children: []
          },
          {
            id: "35",
            name: "3_30",
            description: "Associao Fornecedor X Previso Demanda",
            url: "/do/AssociacaoFornecedorPrevisaoDemanda.mvc",
            children: []
          },
          {
            id: "36",
            name: "3_31",
            description: "Tipos de Documento",
            url: "/DO/TipoDocumento.mvc/",
            children: []
          },
          {
            id: "37",
            name: "3_32",
            description: "Reajustes Automticos de Contrato",
            url: "/DO/Reajuste.mvc//Index/false",
            children: []
          }
        ]
      },
      {
        id: "38",
        name: "4",
        description: "Fornecedores",
        url: "",
        children: [
          {
            id: "39",
            name: "4_3",
            description: "Atributos de Fornecedores",
            url: "/ME/AtributosMeusFornecedores.aspx",
            children: []
          },
          {
            id: "40",
            name: "4_8",
            description: "Grupos de Fornecedores",
            url: "/do/GrupoFornecedor.mvc",
            children: []
          },
          {
            id: "41",
            name: "4_5",
            description: "Fornecedores do Workflow de Documentos",
            url: "/DO/WFD/FornecedorWFD.mvc",
            children: []
          },
          {
            id: "42",
            name: "4_6",
            description: "Fornecedores ME",
            url: "/supplier/",
            children: []
          },
          {
            id: "43",
            name: "4_9",
            description: "Status Homologao Fornecedor",
            url: "/DO/StatusHomologacaoFornecedor.mvc",
            children: []
          }
        ]
      },
      {
        id: "44",
        name: "5",
        description: "Preferncias",
        url: "",
        children: [
          {
            id: "45",
            name: "5_1",
            description: "Locais",
            url: "/do/Locais.mvc",
            children: []
          },
          {
            id: "46",
            name: "5_7",
            description: "Cia ERP",
            url: "/do/CiaERP.mvc",
            children: []
          },
          {
            id: "47",
            name: "5_2",
            description: "Centros de Custos",
            url: "/ME/ListaCCustoWF.aspx",
            children: []
          },
          {
            id: "48",
            name: "5_3",
            description: "Conta Contbil",
            url: "/ME/ListaContaContabilWF.aspx",
            children: []
          },
          {
            id: "49",
            name: "5_6",
            description: "Conta Devedora",
            url: "/do/ContaDevedora.mvc",
            children: []
          },
          {
            id: "50",
            name: "5_5",
            description: "Referncias Devedora",
            url: "/do/ReferenciaDevedora.mvc",
            children: []
          },
          {
            id: "51",
            name: "5_9",
            description: "Nomenclatura Recusar/Cancelar",
            url: "/NomenclaturaCancelarRecusarWF.asp",
            children: []
          },
          {
            id: "52",
            name: "5_8",
            description: "FUP de Entregas",
            url: "/FUPConfiguraWF.asp",
            children: []
          },
          {
            id: "53",
            name: "5_11",
            description: "Mapa Comparativo Excel",
            url: "/MapaComparativoExcelGenericoConfigura.asp",
            children: []
          },
          {
            id: "54",
            name: "5_10",
            description: "FUP (Criticidade)",
            url: "/do/FUPCriticidade.mvc",
            children: []
          },
          {
            id: "55",
            name: "5_12",
            description: "Customizao de e-mails",
            url: "/CustomMail.asp",
            children: []
          },
          {
            id: "56",
            name: "5_23",
            description: "Nova Customizao de e-mails",
            url: "/ME/CustomMail.aspx",
            children: []
          },
          {
            id: "57",
            name: "5_19",
            description: "Manuteno de Feriados",
            url: "/do/Feriadowf.mvc",
            children: []
          },
          {
            id: "58",
            name: "5_22",
            description: "Configuraes (Fornecedor)",
            url: "/ME/PreferenciasWFF.aspx",
            children: []
          },
          {
            id: "59",
            name: "5_18",
            description: "Tipos de Tarefas",
            url: "/ME/TipoTarefa.aspx",
            children: []
          },
          {
            id: "60",
            name: "5_26",
            description: "Cesta ndice de Reajuste",
            url: "/ME/CestaIndiceReajuste.aspx",
            children: []
          },
          {
            id: "61",
            name: "5_29",
            description: "Configurao de Impostos",
            url: "/do/Imposto.mvc",
            children: []
          },
          {
            id: "62",
            name: "5_30",
            description: "Associao Centro Custo/Utilizador",
            url: "/ME/ListaCCustoUsuarioBorgWF.aspx",
            children: []
          },
          {
            id: "63",
            name: "5_31",
            description: "Justificativas de Classif. Qualitativa",
            url: "/do/RecebimentoPedidoJustificativaCQ.mvc",
            children: []
          },
          {
            id: "64",
            name: "5_34",
            description: "Personalizar elementos do Tema",
            url: "/DO/Theme.mvc",
            children: []
          },
          {
            id: "65",
            name: "5_36",
            description: "Personalizar Header (Cabealho)",
            url: "/DO/Theme.mvc/Header",
            children: []
          },
          {
            id: "66",
            name: "5_37",
            description: "Personalizar Tela de Login",
            url: "/DO/Theme.mvc/Home",
            children: []
          },
          {
            id: "67",
            name: "5_35",
            description: "Agendamento",
            url: "/DO/Scheduler.mvc",
            children: []
          }
        ]
      },
      {
        id: "68",
        name: "6",
        description: "WorkFlow",
        url: "",
        children: [
          {
            id: "69",
            name: "6_1",
            description: "Permisses",
            url: "/do/PermissaoWF.mvc",
            children: []
          },
          {
            id: "70",
            name: "6_33",
            description: "Permisso Catlogo",
            url: "/do/PermissaoCatalogo.mvc",
            children: []
          },
          {
            id: "71",
            name: "6_2",
            description: "Estados",
            url: "/VerEstadosWF.asp",
            children: []
          },
          {
            id: "72",
            name: "6_37",
            description: "Validao de Regras",
            url: "/ME/ValidadorRegras.aspx",
            children: []
          },
          {
            id: "73",
            name: "6_38",
            description: "Carga de Regras",
            url: "/ME/CargaRegras.aspx",
            children: []
          },
          {
            id: "74",
            name: "6_88",
            description: "Automao",
            url: "/automation",
            children: []
          },
          {
            id: "75",
            name: "6_77",
            description: "Importao / Exportao Cargas",
            url: "/dataload/LoadHistory",
            children: []
          },
          {
            id: "76",
            name: "6_3",
            description: "Cargos",
            url: "/ME/ListaCargosWF.aspx",
            children: []
          },
          {
            id: "77",
            name: "6_4",
            description: "Catlogo",
            url: "/ME/MarcaCatalogosWF.aspx",
            children: []
          },
          {
            id: "78",
            name: "6_5",
            description: "Atributos Requisio",
            url: "/do/AtributoRequisicao.mvc",
            children: []
          },
          {
            id: "79",
            name: "6_10",
            description: "Atributos Pr-Pedido",
            url: "/ME/ListaAtributosPrePedidoWF.aspx",
            children: []
          },
          {
            id: "80",
            name: "6_38",
            description: "Atributos Pedido",
            url: "/do/AtributoPedido.mvc",
            children: []
          },
          {
            id: "81",
            name: "6_39",
            description: "Atributos Contrato",
            url: "/do/AtributoContrato.mvc",
            children: []
          },
          {
            id: "82",
            name: "6_15",
            description: "Atributos Cotao",
            url: "/do/AtributoCotacao.mvc",
            children: []
          },
          {
            id: "83",
            name: "6_6",
            description: "Categorias Requisio",
            url: "/ME/ListaCategoriasWF.aspx",
            children: []
          },
          {
            id: "84",
            name: "6_11",
            description: "Categorias Pr-Pedido",
            url: "/ME/ListaCategoriasPrePedidoWF.aspx",
            children: []
          },
          {
            id: "85",
            name: "6_53",
            description: "Categorias de NF",
            url: "/do/CategoriaNF.mvc",
            children: []
          },
          {
            id: "86",
            name: "6_75",
            description: "Tipo de Documento de NF",
            url: "/do/TipoDocumentoNF.mvc",
            children: []
          },
          {
            id: "87",
            name: "6_14",
            description: "Categorias Cotao",
            url: "/ME/ListaCategoriasCotacao.aspx",
            children: []
          },
          {
            id: "88",
            name: "6_18",
            description: "Categorias Anexo",
            url: "/do/CategoriaAnexo.mvc",
            children: []
          },
          {
            id: "89",
            name: "6_21",
            description: "Templates Anexo",
            url: "/do/Anexo.mvc",
            children: []
          },
          {
            id: "90",
            name: "6_8",
            description: "Substituies de Usurio",
            url: "/do/Substituicao.mvc",
            children: []
          },
          {
            id: "91",
            name: "6_97",
            description: "Setor Industrial",
            url: "/DO/SetorIndustrial.mvc",
            children: []
          },
          {
            id: "92",
            name: "6_98",
            description: "Grupo de Contas",
            url: "/DO/GrupoConta.mvc",
            children: []
          },
          {
            id: "93",
            name: "6_35",
            description: "Ver Histrico de Substituio de Aprovador",
            url: "/do/HistoricoSubstituicaoAprovador.mvc",
            children: []
          },
          {
            id: "94",
            name: "6_9",
            description: "Conta Corrente",
            url: "/ME/ContaCorrenteWF.aspx",
            children: []
          },
          {
            id: "95",
            name: "6_12",
            description: "Compras / Centros De Custo",
            url: "/do/GastoCCWF.mvc",
            children: []
          },
          {
            id: "96",
            name: "6_13",
            description: "Verba",
            url: "/ME/EditaVerbasWF.aspx",
            children: []
          },
          {
            id: "97",
            name: "6_16",
            description: "Cadastrar Taxa de Converso",
            url: "/ME/EditaTaxaDolarWF.aspx",
            children: []
          },
          {
            id: "98",
            name: "6_17",
            description: "Relatrios de Workflow",
            url: "/RelatLinksRelatoriosWF.asp",
            children: []
          },
          {
            id: "99",
            name: "6_22",
            description: "Informaes de Compras",
            url: "/InformacaoCompras.asp",
            children: []
          },
          {
            id: "100",
            name: "6_24",
            description: "Material de Treinamento",
            url: "/MaterialTreinamento.asp",
            children: []
          },
          {
            id: "101",
            name: "6_25",
            description: "Unid. Req. de Cotao",
            url: "/ME/VerUnidReqCotWF.aspx",
            children: []
          },
          {
            id: "102",
            name: "6_30",
            description: "Manuteno Aplicao",
            url: "/ME/ManutencaoAplicacao.aspx",
            children: []
          },
          {
            id: "103",
            name: "6_29",
            description: "Manuteno IVA",
            url: "/ME/ManutencaoIVA.aspx",
            children: []
          },
          {
            id: "104",
            name: "6_31",
            description: "Relatrio de Verba por Ordem Interna",
            url: "/ME/RelatorioVerbasOI.aspx",
            children: []
          },
          {
            id: "105",
            name: "6_32",
            description: "Motivo da recusa",
            url: "/DO/MotivoRecusa.mvc",
            children: []
          },
          {
            id: "106",
            name: "6_40",
            description: "Monitor de Requisio",
            url: "/MonitoraReqIntegracao.asp",
            children: []
          },
          {
            id: "107",
            name: "6_41",
            description: "rea Funcional",
            url: "/ME/CadastroAreaFuncional.aspx",
            children: []
          },
          {
            id: "108",
            name: "6_48",
            description: "Cadastro de gesto de frete",
            url: "/Cadastros.asp",
            children: []
          },
          {
            id: "109",
            name: "6_99",
            description: "Cadastro de Frete",
            url: "/DO/Frete.mvc",
            children: []
          },
          {
            id: "110",
            name: "6_52",
            description: "Alertas",
            url: "/do/ManutencaoAlerta.mvc",
            children: []
          },
          {
            id: "111",
            name: "6_56",
            description: "Marketplace",
            url: "/PlanoEmpresa.asp",
            children: []
          },
          {
            id: "112",
            name: "6_55",
            description: "Critrios de Avaliao",
            url: "/do/CriterioAvaliacao.mvc",
            children: []
          },
          {
            id: "113",
            name: "6_59",
            description: "Condies de Pagamento",
            url: "/do/CondicaoPagamento.mvc",
            children: []
          },
          {
            id: "114",
            name: "6_61",
            description: "Condies de Fornecimento",
            url: "/do/CondicaoFornecimento.mvc",
            children: []
          },
          {
            id: "115",
            name: "6_63",
            description: "Categoria de Item de Requisio",
            url: "/ME/CategoriasItemWF.aspx",
            children: []
          },
          {
            id: "116",
            name: "6_64",
            description: "Categoria de Ordem",
            url: "/ME/CategoriasOrdemWF.aspx",
            children: []
          },
          {
            id: "117",
            name: "7_01",
            description: "Moedas",
            url: "/DO/Currency/Currency.mvc",
            children: []
          },
          {
            id: "118",
            name: "7_02",
            description: "Cadastro de Origem de Material",
            url: "/do/OrigemMaterial/OrigemMaterial.mvc",
            children: []
          },
          {
            id: "119",
            name: "7_03",
            description: "Cadastro de Unidades",
            url: "/DO/Unit/Unit.mvc",
            children: []
          },
          {
            id: "120",
            name: "6_67",
            description: "Tipo Conta de Consumo",
            url: "/ME/TipoContaConsumo.aspx",
            children: []
          },
          {
            id: "121",
            name: "6_70",
            description: "Cadastro de Grupo de Compras",
            url: "/ME/GrupoCompraWF.aspx",
            children: []
          },
          {
            id: "122",
            name: "6_80",
            description: "Cadastro de Roteamento",
            url: "/ME/CadastroRoteamento.aspx",
            children: []
          },
          {
            id: "123",
            name: "6_112",
            description: "Configurao Mapa Comparativo Hipster",
            url: "/comparative-panel/config",
            children: []
          },
          {
            id: "124",
            name: "6_71",
            description: "Cadastro de Categoria do Material",
            url: "/ME/CategoriaMaterial.aspx",
            children: []
          },
          {
            id: "125",
            name: "6_72",
            description: "Cadastro de Classificao do Servio",
            url: "/ME/ClassificacaoFiscalServico.aspx",
            children: []
          },
          {
            id: "126",
            name: "6_74",
            description: "Textos Genricos",
            url: "/ME/TextoGenerico.aspx",
            children: []
          },
          {
            id: "127",
            name: "6_75",
            description: "Cadastro de Elemento PEP",
            url: "/ME/ElementoPEP.aspx",
            children: []
          },
          {
            id: "128",
            name: "6_81",
            description: "Administrao de Macro reas",
            url: "/ME/MacroAreas.aspx",
            children: []
          },
          {
            id: "129",
            name: "6_86",
            description: "REIDI",
            url: "/do/Reidi.mvc",
            children: []
          },
          {
            id: "130",
            name: "6_87",
            description: "Anexo Fornecedor",
            url: "/ME/AnexoFornecedor.aspx",
            children: []
          },
          {
            id: "131",
            name: "6_90",
            description: "Regras de Follow UP (Novo Motor)",
            url: "/DO/FUP/Configuration.mvc",
            children: []
          },
          {
            id: "132",
            name: "6_91",
            description: "Cadastro de Tipo de Entidade",
            url: "/do/TipoEntidade.mvc",
            children: []
          },
          {
            id: "133",
            name: "6_93",
            description: "Cadastro de Operaes Comerciais",
            url: "/DO/OperacaoComercial.mvc",
            children: []
          },
          {
            id: "134",
            name: "6_94",
            description: "Cadastro de Diagramas de Rede",
            url: "/DO/DiagramaRede.mvc",
            children: []
          },
          {
            id: "135",
            name: "6_97",
            description: "Tipos de Fornecedor Parceiro",
            url: "/DO/TipoFornecedorParceiro.mvc/",
            children: []
          },
          {
            id: "136",
            name: "6_98",
            description: "Formas de Pagamento",
            url: "/DO/FormaPagamento.mvc/",
            children: []
          },
          {
            id: "137",
            name: "6_99",
            description: "Catlogo de Tradues",
            url: "/DO/CatalogoTraducao.mvc",
            children: []
          },
          {
            id: "138",
            name: "6_100",
            description: "Categoria FRS",
            url: "/DO/CategoriaFRS.mvc",
            children: []
          },
          {
            id: "139",
            name: "6_101",
            description: "Cadastro de Regionais",
            url: "/DO/Regional.mvc",
            children: []
          },
          {
            id: "140",
            name: "6_105",
            description: "Pacotes e Condies de Melhor Compra",
            url: "/DO/PacoteMelhorCompra.mvc",
            children: []
          },
          {
            id: "141",
            name: "6_108",
            description: "Cadastro de Tipo de Exportao",
            url: "/do/TipoExportacao.mvc",
            children: []
          },
          {
            id: "142",
            name: "6_92",
            description: "Cadastro de Comunicados",
            url: "/ME/CadastroComunicado.aspx",
            children: []
          },
          {
            id: "143",
            name: "6_93",
            description: "Gerenciar o cadastro de Determinao de IVA",
            url: "/do/DeterminacaoIVA.mvc",
            children: []
          },
          {
            id: "144",
            name: "2_8",
            description: "Cadastro de Ordem",
            url: "/do/OrdemWF.mvc",
            children: []
          }
        ]
      },
      {
        id: "145",
        name: "7",
        description: "Relatrios",
        url: "",
        children: [
          {
            id: "146",
            name: "7_1",
            description: "Ver grficos",
            url: "/Graficos.asp",
            children: []
          },
          {
            id: "147",
            name: "7_5",
            description: "Relatrio Gerencial",
            url: "/RelatorioGestaoPedidos.asp",
            children: []
          },
          {
            id: "148",
            name: "7_6",
            description: "Acompanhamento de Relatrios",
            url: "/ME/ListaExtracaoRelatorio.aspx",
            children: []
          },
          {
            id: "149",
            name: "7_7",
            description: "Extrao de Relatrio",
            url: "/ME/ExtracaoRelatorio.aspx",
            children: []
          },
          {
            id: "150",
            name: "7_2",
            description: "Relatrios de Workflow",
            url: "/RelatLinksRelatoriosWF.asp",
            children: []
          },
          {
            id: "151",
            name: "27_1",
            description: "Relatrios e-Business Intelligence",
            url: "/MERG.asp",
            children: []
          }
        ]
      },
      {
        id: "152",
        name: "9",
        description: "WorkFlow Central",
        url: "",
        children: []
      },
      {
        id: "153",
        name: "12",
        description: "Contas Pagas",
        url: "",
        children: []
      },
      {
        id: "154",
        name: "25",
        description: "Notas Fiscais",
        url: "",
        children: [
          {
            id: "155",
            name: "25_1",
            description: "Lista de Notas Fiscais",
            url: "/NF.asp?action=lista",
            children: []
          },
          {
            id: "156",
            name: "25_3",
            description: "Perodo Fiscal",
            url: "/do/PeriodoFiscal.mvc",
            children: []
          }
        ]
      },
      {
        id: "157",
        name: "14",
        description: "RoundTrip",
        url: "",
        children: [
          {
            id: "158",
            name: "14_1",
            description: "Catlogos",
            url: "/do/RoundTripWF.mvc",
            children: []
          },
          {
            id: "159",
            name: "14_2",
            description: "Usurios",
            url: "/do/RoundTripUser.mvc",
            children: []
          }
        ]
      },
      {
        id: "160",
        name: "18",
        description: "Monitor de Integrao",
        url: "",
        children: []
      },
      {
        id: "161",
        name: "19",
        description: "Amarraes",
        url: "",
        children: [
          {
            id: "162",
            name: "19_1",
            description: "Conta Razo x Ordem Interna",
            url: "/do/ContaRazaoOrdemInterna.mvc",
            children: []
          },
          {
            id: "163",
            name: "19_2",
            description: "Conta Razo x Centro de Custo",
            url: "/ME/ContaRazaoCentroCusto.aspx",
            children: []
          },
          {
            id: "164",
            name: "19_3",
            description: "Conta Razo x rea Funcional",
            url: "/ME/ContaRazaoAreaFuncional.aspx",
            children: []
          },
          {
            id: "165",
            name: "19_4",
            description: "Conta Razo x Ordem",
            url: "/do/ContaRazaoOrdem.mvc",
            children: []
          },
          {
            id: "166",
            name: "19_5",
            description: "Centro de Custo x rea Funcional",
            url: "/do/AreaFuncionalCentroCusto.mvc",
            children: []
          },
          {
            id: "167",
            name: "19_6",
            description: "Usurio x rea Funcional",
            url: "/do/AreaFuncionalUsuario.mvc",
            children: []
          }
        ]
      },
      {
        id: "168",
        name: "21",
        description: "Links Personalizados",
        url: "",
        children: []
      },
      {
        id: "169",
        name: "23",
        description: "Consulta Serasa",
        url: "",
        children: []
      },
      {
        id: "170",
        name: "29",
        description: "Motor de Regras 3",
        url: "",
        children: [
          {
            id: "171",
            name: "29_1",
            description: "Tabelas",
            url: "/ME/ConsultarTabelas.aspx",
            children: []
          },
          {
            id: "172",
            name: "29_2",
            description: "Regras",
            url: "/ME/CadastroRegras.aspx",
            children: []
          }
        ]
      },
      {
        id: "173",
        name: "32",
        description: "Integrao",
        url: "",
        children: [
          {
            id: "174",
            name: "32_1",
            description: "Enviar Arquivo",
            url: "/do/Integracao.mvc/SendFile",
            children: []
          },
          {
            id: "175",
            name: "32_2",
            description: "Viso Geral",
            url: "/do/Integracao.mvc/FilaVisao",
            children: []
          },
          {
            id: "176",
            name: "32_3",
            description: "Processos",
            url: "/do/Integracao.mvc/Fila",
            children: []
          }
        ]
      },
      {
        id: "177",
        name: "33",
        description: "Log",
        url: "",
        children: [
          {
            id: "178",
            name: "33_1",
            description: "Cadastro de Produto",
            url: "/do/Log/Produto.mvc",
            children: []
          },
          {
            id: "179",
            name: "33_2",
            description: "Flags de Preferncias",
            url: "/do/Log/Flags.mvc/Index/Workflow",
            children: []
          }
        ]
      },
      {
        id: "180",
        name: "34",
        description: "Minha Conta",
        url: "",
        children: [
          {
            id: "181",
            name: "34_1",
            description: "Meus Dados",
            url: "/RegEdit.asp",
            children: []
          },
          {
            id: "182",
            name: "34_2",
            description: "Relatrios",
            url: "/ME/ExtracaoRelatorio.aspx",
            children: []
          },
          {
            id: "183",
            name: "34_5",
            description: "Acompanhamento de Relatrios",
            url: "/ME/ListaExtracaoRelatorio.aspx",
            children: []
          },
          {
            id: "184",
            name: "34_3",
            description: "Notas / Boletos / Extratos",
            url: "/do/Fornecedor.mvc/ListaFornecedorFinanceiro",
            children: []
          }
        ]
      },
      {
        id: "185",
        name: "40",
        description: "Links teis",
        url: "",
        children: [
          {
            id: "186",
            name: "40_0",
            description: "Pedidos para Enviar",
            url: "/ListaPedidosProntosWF.asp",
            children: []
          },
          {
            id: "187",
            name: "41_1",
            description: "Meus Pr-Pedidos para Enviar",
            url: "/ListaPedidosProntosWF.asp",
            children: []
          },
          {
            id: "188",
            name: "41_2",
            description: "Pendncias de Contrato",
            url: "/DO/RFQ/Create.mvc/Contract",
            children: []
          },
          {
            id: "189",
            name: "41_3",
            description: "Pendncia de Reaproveitamento de SO",
            url: "/DO/ReaproveitamentoCotacao.mvc",
            children: []
          },
          {
            id: "190",
            name: "41_7",
            description: "Pendncias de alterao de data de entrega",
            url: "/DO/Orders/Pendency.mvc",
            children: []
          },
          {
            id: "191",
            name: "41_8",
            description: "Aprovao de Produtos PDM",
            url: "/PDM/AprovarProdutos.aspx",
            children: []
          },
          {
            id: "192",
            name: "41_9",
            description: "Aprovao de Tarefas",
            url: "/ME/ListarTarefas.aspx",
            children: []
          },
          {
            id: "193",
            name: "41_10",
            description: "Solicitaes de Oramento",
            url: "/ListaRequisicoesWF.asp?Oper=so",
            children: []
          },
          {
            id: "194",
            name: "41_11",
            description: "Requisies Emergenciais",
            url: "/ListaRequisicoesWF.asp?Emergencial=2",
            children: []
          },
          {
            id: "195",
            name: "41_12",
            description: "Mapa Comparativo",
            url: "/do/MapaComparativo.mvc/ListaMapaComparativo",
            children: []
          },
          {
            id: "196",
            name: "41_13",
            description: "Relatrio de Acompanhamento",
            url: "/RelatAcompanhamentoWF.asp",
            children: []
          },
          {
            id: "197",
            name: "41_15",
            description: "Documentos ME",
            url: "/do/RepositorioDocumentoME/Home.mvc",
            children: []
          },
          {
            id: "198",
            name: "41_17",
            description: "Gesto de Compras",
            url: "/do/ControleDeCompras.mvc/Backlog",
            children: []
          },
          {
            id: "199",
            name: "41_18",
            description: "Substituir Usurio",
            url: "/do/ChangeUser.mvc",
            children: []
          },
          {
            id: "200",
            name: "41_20",
            description: "Substituir Usurio do Mesmo Perfil",
            url: "/TrocaUsuarioPerfilWF.asp",
            children: []
          },
          {
            id: "201",
            name: "41_27",
            description: "Substituio de Workflow",
            url: "/do/Usuario.mvc/SubstituirWorkflow",
            children: []
          },
          {
            id: "202",
            name: "41_23",
            description: "Recebimento",
            url: "/ME/RecebimentoWF.aspx",
            children: []
          },
          {
            id: "203",
            name: "41_24",
            description: "Pedidos Agendados",
            url: "/PedidosAgendadosWF.asp",
            children: []
          },
          {
            id: "204",
            name: "41_26",
            description: "Evento Online",
            url: "/do/Leilao/CriarLeilao.mvc/listaEventos",
            children: []
          },
          {
            id: "205",
            name: "41_28",
            description: "Importao / Exportao Cargas",
            url: "/dataload/LoadHistory",
            children: []
          }
        ]
      }
    ]);
    const headerClasses = computed(() => {
      const baseClasses = "shadow-lg";
      return `${baseClasses} text-white`;
    });
    const headerStyles = computed(() => {
      const styles = {};
      const bg = brand.value.background || {};
      const hasMainImage = Boolean(bg.mainImage);
      const hasRepeatImage = Boolean(bg.repeatImage);
      const hasPrimaryColor = Boolean(bg.primaryColor);
      const hasSecondaryColor = Boolean(bg.secondaryColor);
      if (hasMainImage && hasRepeatImage && bg.mainImage && bg.repeatImage) {
        styles.backgroundImage = `url(${bg.mainImage}), url(${bg.repeatImage})`;
        styles.backgroundSize = "cover, auto";
        styles.backgroundPosition = "center, center";
        styles.backgroundRepeat = "no-repeat, repeat";
      } else if (hasMainImage && hasPrimaryColor && bg.mainImage && bg.primaryColor) {
        styles.backgroundColor = bg.primaryColor;
        styles.backgroundImage = `url(${bg.mainImage})`;
        styles.backgroundSize = "contain";
        styles.backgroundPosition = "center";
        styles.backgroundRepeat = "no-repeat";
      } else if (hasRepeatImage && !hasMainImage && bg.repeatImage) {
        styles.backgroundImage = `url(${bg.repeatImage})`;
        styles.backgroundSize = "auto";
        styles.backgroundPosition = "center";
        styles.backgroundRepeat = "repeat";
      } else if (hasPrimaryColor && hasSecondaryColor && !hasMainImage && !hasRepeatImage && bg.primaryColor && bg.secondaryColor) {
        styles.background = `linear-gradient(135deg, ${bg.primaryColor} 0%, ${bg.secondaryColor} 100%)`;
      } else if (hasPrimaryColor && !hasSecondaryColor && !hasMainImage && !hasRepeatImage && bg.primaryColor) {
        styles.backgroundColor = bg.primaryColor;
      } else {
        styles.backgroundColor = "var(--ui-primary)";
      }
      return styles;
    });
    const iconColor = computed(() => {
      return brand.value.background?.iconColor || "white";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("header", {
          class: normalizeClass(headerClasses.value),
          style: normalizeStyle(headerStyles.value)
        }, [
          createBaseVNode("nav", _hoisted_1, [
            createVNode(_sfc_main$i, { brand: brand.value }, null, 8, ["brand"]),
            createVNode(_sfc_main$6, { iconColor: iconColor.value }, null, 8, ["iconColor"]),
            createVNode(_sfc_main$2, {
              user: user.value,
              profileItems: profileItems.value
            }, null, 8, ["user", "profileItems"])
          ])
        ], 6),
        backdropState.value.visible ? (openBlock(), createBlock(_sfc_main$1, {
          key: 0,
          "z-index": backdropState.value.zIndex,
          onClick: closeBackdrop
        }, null, 8, ["z-index"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const tailwindStyles = `/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */
@layer properties {
  @supports (((-webkit-hyphens: none)) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color: rgb(from red r g b)))) {
    *, :before, :after, ::backdrop {
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-translate-z: 0;
      --tw-scale-x: 1;
      --tw-scale-y: 1;
      --tw-scale-z: 1;
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-pan-x: initial;
      --tw-pan-y: initial;
      --tw-pinch-zoom: initial;
      --tw-space-y-reverse: 0;
      --tw-space-x-reverse: 0;
      --tw-divide-x-reverse: 0;
      --tw-border-style: solid;
      --tw-divide-y-reverse: 0;
      --tw-leading: initial;
      --tw-font-weight: initial;
      --tw-ordinal: initial;
      --tw-slashed-zero: initial;
      --tw-numeric-figure: initial;
      --tw-numeric-spacing: initial;
      --tw-numeric-fraction: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-outline-style: solid;
      --tw-blur: initial;
      --tw-brightness: initial;
      --tw-contrast: initial;
      --tw-grayscale: initial;
      --tw-hue-rotate: initial;
      --tw-invert: initial;
      --tw-opacity: initial;
      --tw-saturate: initial;
      --tw-sepia: initial;
      --tw-drop-shadow: initial;
      --tw-drop-shadow-color: initial;
      --tw-drop-shadow-alpha: 100%;
      --tw-drop-shadow-size: initial;
      --tw-backdrop-blur: initial;
      --tw-backdrop-brightness: initial;
      --tw-backdrop-contrast: initial;
      --tw-backdrop-grayscale: initial;
      --tw-backdrop-hue-rotate: initial;
      --tw-backdrop-invert: initial;
      --tw-backdrop-opacity: initial;
      --tw-backdrop-saturate: initial;
      --tw-backdrop-sepia: initial;
      --tw-duration: initial;
      --tw-ease: initial;
      --tw-content: "";
    }
  }
}

@layer theme {
  :root, :host {
    --font-sans: "Roboto", sans-serif;
    --color-blue-50: #edf3ff;
    --color-blue-100: #d0e0ff;
    --color-blue-200: #a9c6ff;
    --color-blue-300: #7ca8ff;
    --color-blue-400: #437fff;
    --color-blue-500: #1052e0;
    --color-blue-600: #0a0a93;
    --color-blue-700: #0369a1;
    --color-blue-800: #075985;
    --color-blue-900: #05054a;
    --color-blue-950: #082f49;
    --color-neutral-50: #f1f3f5;
    --color-neutral-100: #e2e6e9;
    --color-neutral-200: #a3acb6;
    --color-neutral-300: #758493;
    --color-neutral-400: #566574;
    --color-neutral-500: #415260;
    --color-neutral-600: #303e49;
    --color-neutral-700: #262f35;
    --color-neutral-800: #075985;
    --color-old-neutral-50: oklch(98.5% 0 0);
    --color-old-neutral-100: oklch(97% 0 0);
    --color-old-neutral-200: oklch(92.2% 0 0);
    --color-old-neutral-300: oklch(87% 0 0);
    --color-old-neutral-400: oklch(70.8% 0 0);
    --color-old-neutral-500: oklch(55.6% 0 0);
    --color-old-neutral-600: oklch(43.9% 0 0);
    --color-old-neutral-700: oklch(37.1% 0 0);
    --color-old-neutral-800: oklch(26.9% 0 0);
    --color-old-neutral-900: oklch(20.5% 0 0);
    --color-old-neutral-950: oklch(14.5% 0 0);
  }
}

@layer base {
  *, :after, :before, ::backdrop {
    box-sizing: border-box;
    border: 0 solid;
    margin: 0;
    padding: 0;
  }

  ::file-selector-button {
    box-sizing: border-box;
    border: 0 solid;
    margin: 0;
    padding: 0;
  }

  html, :host {
    -webkit-text-size-adjust: 100%;
    tab-size: 4;
    line-height: 1.5;
    font-family: var(--default-font-family, var(--font-sans, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"));
    font-feature-settings: var(--default-font-feature-settings, initial);
    font-variation-settings: var(--default-font-variation-settings, initial);
    -webkit-tap-highlight-color: transparent;
  }

  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }

  abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }

  h1, h2, h3, h4, h5, h6 {
    font-size: inherit;
    font-weight: inherit;
  }

  a {
    color: inherit;
    -webkit-text-decoration: inherit;
    -webkit-text-decoration: inherit;
    -webkit-text-decoration: inherit;
    text-decoration: inherit;
  }

  b, strong {
    font-weight: bolder;
  }

  code, kbd, samp, pre {
    font-family: var(--default-mono-font-family, var(--font-mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace));
    font-feature-settings: var(--default-mono-font-feature-settings, initial);
    font-variation-settings: var(--default-mono-font-variation-settings, initial);
    font-size: 1em;
  }

  small {
    font-size: 80%;
  }

  sub, sup {
    vertical-align: baseline;
    font-size: 75%;
    line-height: 0;
    position: relative;
  }

  sub {
    bottom: -.25em;
  }

  sup {
    top: -.5em;
  }

  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }

  :-moz-focusring {
    outline: auto;
  }

  progress {
    vertical-align: baseline;
  }

  summary {
    display: list-item;
  }

  ol, ul, menu {
    list-style: none;
  }

  img, svg, video, canvas, audio, iframe, embed, object {
    vertical-align: middle;
    display: block;
  }

  img, video {
    max-width: 100%;
    height: auto;
  }

  button, input, select, optgroup, textarea {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    opacity: 1;
    background-color: #0000;
    border-radius: 0;
  }

  ::file-selector-button {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    opacity: 1;
    background-color: #0000;
    border-radius: 0;
  }

  :where(select:is([multiple], [size])) optgroup {
    font-weight: bolder;
  }

  :where(select:is([multiple], [size])) optgroup option {
    padding-inline-start: 20px;
  }

  ::file-selector-button {
    margin-inline-end: 4px;
  }

  ::placeholder {
    opacity: 1;
  }

  @supports (not ((-webkit-appearance: -apple-pay-button))) or (contain-intrinsic-size: 1px) {
    ::placeholder {
      color: currentColor;
    }

    @supports (color: color-mix(in lab, red, red)) {
      ::placeholder {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
  }

  textarea {
    resize: vertical;
  }

  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  ::-webkit-date-and-time-value {
    min-height: 1lh;
    text-align: inherit;
  }

  ::-webkit-datetime-edit {
    display: inline-flex;
  }

  ::-webkit-datetime-edit-fields-wrapper {
    padding: 0;
  }

  ::-webkit-datetime-edit {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-year-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-month-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-day-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-hour-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-minute-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-second-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-millisecond-field {
    padding-block: 0;
  }

  ::-webkit-datetime-edit-meridiem-field {
    padding-block: 0;
  }

  :-moz-ui-invalid {
    box-shadow: none;
  }

  button, input:where([type="button"], [type="reset"], [type="submit"]) {
    appearance: button;
  }

  ::file-selector-button {
    appearance: button;
  }

  ::-webkit-inner-spin-button {
    height: auto;
  }

  ::-webkit-outer-spin-button {
    height: auto;
  }

  [hidden]:where(:not([hidden="until-found"])) {
    display: none !important;
  }

  body {
    background-color: var(--ui-bg);
    color: var(--ui-text);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    color-scheme: light;
  }

  body:where(.dark, .dark *) {
    color-scheme: dark;
  }

  .light, :root {
    --ui-text-dimmed: var(--ui-color-neutral-400);
    --ui-text-muted: var(--ui-color-neutral-500);
    --ui-text-toned: var(--ui-color-neutral-600);
    --ui-text: var(--ui-color-neutral-700);
    --ui-text-highlighted: var(--ui-color-neutral-900);
    --ui-text-inverted: var(--color-white);
    --ui-bg: var(--color-white);
    --ui-bg-muted: var(--ui-color-neutral-50);
    --ui-bg-elevated: var(--ui-color-neutral-100);
    --ui-bg-accented: var(--ui-color-neutral-200);
    --ui-bg-inverted: var(--ui-color-neutral-900);
    --ui-border: var(--ui-color-neutral-200);
    --ui-border-muted: var(--ui-color-neutral-200);
    --ui-border-accented: var(--ui-color-neutral-300);
    --ui-border-inverted: var(--ui-color-neutral-900);
    --ui-radius: .25rem;
    --ui-container: var(--container-7xl);
  }

  .dark {
    --ui-text-dimmed: var(--ui-color-neutral-500);
    --ui-text-muted: var(--ui-color-neutral-400);
    --ui-text-toned: var(--ui-color-neutral-300);
    --ui-text: var(--ui-color-neutral-200);
    --ui-text-highlighted: var(--color-white);
    --ui-text-inverted: var(--ui-color-neutral-900);
    --ui-bg: var(--ui-color-neutral-900);
    --ui-bg-muted: var(--ui-color-neutral-800);
    --ui-bg-elevated: var(--ui-color-neutral-800);
    --ui-bg-accented: var(--ui-color-neutral-700);
    --ui-bg-inverted: var(--color-white);
    --ui-border: var(--ui-color-neutral-800);
    --ui-border-muted: var(--ui-color-neutral-700);
    --ui-border-accented: var(--ui-color-neutral-700);
    --ui-border-inverted: var(--color-white);
  }
}

@layer components;

@layer utilities {
  .pointer-events-auto {
    pointer-events: auto;
  }

  .pointer-events-none {
    pointer-events: none;
  }

  .collapse {
    visibility: collapse;
  }

  .invisible {
    visibility: hidden;
  }

  .visible {
    visibility: visible;
  }

  .sr-only {
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    position: absolute;
    overflow: hidden;
  }

  .not-sr-only {
    clip: auto;
    white-space: normal;
    width: auto;
    height: auto;
    margin: 0;
    padding: 0;
    position: static;
    overflow: visible;
  }

  .absolute {
    position: absolute;
  }

  .fixed {
    position: fixed;
  }

  .relative {
    position: relative;
  }

  .static {
    position: static;
  }

  .sticky {
    position: sticky;
  }

  .inset-0 {
    inset: calc(var(--spacing, .25rem) * 0);
  }

  .inset-x-0 {
    inset-inline: calc(var(--spacing, .25rem) * 0);
  }

  .inset-x-1 {
    inset-inline: calc(var(--spacing, .25rem) * 1);
  }

  .inset-x-4 {
    inset-inline: calc(var(--spacing, .25rem) * 4);
  }

  .inset-y-0 {
    inset-block: calc(var(--spacing, .25rem) * 0);
  }

  .inset-y-1 {
    inset-block: calc(var(--spacing, .25rem) * 1);
  }

  .inset-y-1\\.5 {
    inset-block: calc(var(--spacing, .25rem) * 1.5);
  }

  .inset-y-2 {
    inset-block: calc(var(--spacing, .25rem) * 2);
  }

  .inset-y-4 {
    inset-block: calc(var(--spacing, .25rem) * 4);
  }

  .-start-px {
    inset-inline-start: -1px;
  }

  .start-0 {
    inset-inline-start: calc(var(--spacing, .25rem) * 0);
  }

  .start-4 {
    inset-inline-start: calc(var(--spacing, .25rem) * 4);
  }

  .start-\\[calc\\(50\\%\\+16px\\)\\] {
    inset-inline-start: calc(50% + 16px);
  }

  .start-\\[calc\\(50\\%\\+20px\\)\\] {
    inset-inline-start: calc(50% + 20px);
  }

  .start-\\[calc\\(50\\%\\+28px\\)\\] {
    inset-inline-start: calc(50% + 28px);
  }

  .start-\\[calc\\(50\\%\\+32px\\)\\] {
    inset-inline-start: calc(50% + 32px);
  }

  .start-\\[calc\\(50\\%\\+36px\\)\\] {
    inset-inline-start: calc(50% + 36px);
  }

  .start-\\[calc\\(50\\%-1px\\)\\] {
    inset-inline-start: calc(50% - 1px);
  }

  .-end-1 {
    inset-inline-end: calc(var(--spacing, .25rem) * -1);
  }

  .-end-1\\.5 {
    inset-inline-end: calc(var(--spacing, .25rem) * -1.5);
  }

  .end-0 {
    inset-inline-end: calc(var(--spacing, .25rem) * 0);
  }

  .end-4 {
    inset-inline-end: calc(var(--spacing, .25rem) * 4);
  }

  .end-\\[calc\\(-50\\%\\+16px\\)\\] {
    inset-inline-end: calc(16px - 50%);
  }

  .end-\\[calc\\(-50\\%\\+20px\\)\\] {
    inset-inline-end: calc(20px - 50%);
  }

  .end-\\[calc\\(-50\\%\\+28px\\)\\] {
    inset-inline-end: calc(28px - 50%);
  }

  .end-\\[calc\\(-50\\%\\+32px\\)\\] {
    inset-inline-end: calc(32px - 50%);
  }

  .end-\\[calc\\(-50\\%\\+36px\\)\\] {
    inset-inline-end: calc(36px - 50%);
  }

  .-top-1 {
    top: calc(var(--spacing, .25rem) * -1);
  }

  .-top-1\\.5 {
    top: calc(var(--spacing, .25rem) * -1.5);
  }

  .top-0 {
    top: calc(var(--spacing, .25rem) * 0);
  }

  .top-1 {
    top: calc(var(--spacing, .25rem) * 1);
  }

  .top-1\\/2 {
    top: 50%;
  }

  .top-4 {
    top: calc(var(--spacing, .25rem) * 4);
  }

  .top-\\[-1px\\] {
    top: -1px;
  }

  .top-\\[30px\\] {
    top: 30px;
  }

  .top-\\[38px\\] {
    top: 38px;
  }

  .top-\\[46px\\] {
    top: 46px;
  }

  .top-\\[50\\%\\] {
    top: 50%;
  }

  .top-\\[54px\\] {
    top: 54px;
  }

  .top-\\[62px\\] {
    top: 62px;
  }

  .top-\\[calc\\(50\\%-2px\\)\\] {
    top: calc(50% - 2px);
  }

  .top-full {
    top: 100%;
  }

  .right-0 {
    right: calc(var(--spacing, .25rem) * 0);
  }

  .right-4 {
    right: calc(var(--spacing, .25rem) * 4);
  }

  .right-\\[-8px\\] {
    right: -8px;
  }

  .-bottom-7 {
    bottom: calc(var(--spacing, .25rem) * -7);
  }

  .-bottom-\\[10px\\] {
    bottom: -10px;
  }

  .-bottom-px {
    bottom: -1px;
  }

  .bottom-0 {
    bottom: calc(var(--spacing, .25rem) * 0);
  }

  .bottom-4 {
    bottom: calc(var(--spacing, .25rem) * 4);
  }

  .left-\\(--reka-navigation-menu-viewport-left\\) {
    left: var(--reka-navigation-menu-viewport-left);
  }

  .left-0 {
    left: calc(var(--spacing, .25rem) * 0);
  }

  .left-1 {
    left: calc(var(--spacing, .25rem) * 1);
  }

  .left-1\\/2 {
    left: 50%;
  }

  .left-4 {
    left: calc(var(--spacing, .25rem) * 4);
  }

  .isolate {
    isolation: isolate;
  }

  .isolation-auto {
    isolation: auto;
  }

  .z-\\(--index\\) {
    z-index: var(--index);
  }

  .z-10000 {
    z-index: 10000;
  }

  .z-\\[1\\] {
    z-index: 1;
  }

  .z-\\[2\\] {
    z-index: 2;
  }

  .z-\\[100\\] {
    z-index: 100;
  }

  .z-\\[10001\\] {
    z-index: 10001;
  }

  .z-\\[10003\\] {
    z-index: 10003;
  }

  .col-start-1 {
    grid-column-start: 1;
  }

  .row-start-1 {
    grid-row-start: 1;
  }

  .container {
    width: 100%;
  }

  @media (min-width: 40rem) {
    .container {
      max-width: 40rem;
    }
  }

  @media (min-width: 48rem) {
    .container {
      max-width: 48rem;
    }
  }

  @media (min-width: 64rem) {
    .container {
      max-width: 64rem;
    }
  }

  @media (min-width: 80rem) {
    .container {
      max-width: 80rem;
    }
  }

  @media (min-width: 96rem) {
    .container {
      max-width: 96rem;
    }
  }

  .m-0 {
    margin: calc(var(--spacing, .25rem) * 0);
  }

  .m-0\\.5 {
    margin: calc(var(--spacing, .25rem) * .5);
  }

  .-mx-1 {
    margin-inline: calc(var(--spacing, .25rem) * -1);
  }

  .mx-3 {
    margin-inline: calc(var(--spacing, .25rem) * 3);
  }

  .mx-auto {
    margin-inline: auto;
  }

  .my-1 {
    margin-block: calc(var(--spacing, .25rem) * 1);
  }

  .my-2 {
    margin-block: calc(var(--spacing, .25rem) * 2);
  }

  .-ms-4 {
    margin-inline-start: calc(var(--spacing, .25rem) * -4);
  }

  .-ms-px {
    margin-inline-start: -1px;
  }

  .ms-2 {
    margin-inline-start: calc(var(--spacing, .25rem) * 2);
  }

  .ms-4 {
    margin-inline-start: calc(var(--spacing, .25rem) * 4);
  }

  .ms-4\\.5 {
    margin-inline-start: calc(var(--spacing, .25rem) * 4.5);
  }

  .ms-5 {
    margin-inline-start: calc(var(--spacing, .25rem) * 5);
  }

  .ms-auto {
    margin-inline-start: auto;
  }

  .-me-0 {
    margin-inline-end: calc(var(--spacing, .25rem) * 0);
  }

  .-me-0\\.5 {
    margin-inline-end: calc(var(--spacing, .25rem) * -.5);
  }

  .-me-1 {
    margin-inline-end: calc(var(--spacing, .25rem) * -1);
  }

  .-me-1\\.5 {
    margin-inline-end: calc(var(--spacing, .25rem) * -1.5);
  }

  .-me-2 {
    margin-inline-end: calc(var(--spacing, .25rem) * -2);
  }

  .me-2 {
    margin-inline-end: calc(var(--spacing, .25rem) * 2);
  }

  .-mt-0 {
    margin-top: calc(var(--spacing, .25rem) * 0);
  }

  .-mt-0\\.5 {
    margin-top: calc(var(--spacing, .25rem) * -.5);
  }

  .-mt-4 {
    margin-top: calc(var(--spacing, .25rem) * -4);
  }

  .mt-0 {
    margin-top: calc(var(--spacing, .25rem) * 0);
  }

  .mt-0\\.5 {
    margin-top: calc(var(--spacing, .25rem) * .5);
  }

  .mt-1 {
    margin-top: calc(var(--spacing, .25rem) * 1);
  }

  .mt-1\\.5 {
    margin-top: calc(var(--spacing, .25rem) * 1.5);
  }

  .mt-2 {
    margin-top: calc(var(--spacing, .25rem) * 2);
  }

  .mt-2\\.5 {
    margin-top: calc(var(--spacing, .25rem) * 2.5);
  }

  .mt-3 {
    margin-top: calc(var(--spacing, .25rem) * 3);
  }

  .mt-3\\.5 {
    margin-top: calc(var(--spacing, .25rem) * 3.5);
  }

  .mt-4 {
    margin-top: calc(var(--spacing, .25rem) * 4);
  }

  .mt-24 {
    margin-top: calc(var(--spacing, .25rem) * 24);
  }

  .mt-auto {
    margin-top: auto;
  }

  .\\!mr-4 {
    margin-right: calc(var(--spacing, .25rem) * 4) !important;
  }

  .mr-2 {
    margin-right: calc(var(--spacing, .25rem) * 2);
  }

  .-mb-px {
    margin-bottom: -1px;
  }

  .mb-0 {
    margin-bottom: calc(var(--spacing, .25rem) * 0);
  }

  .mb-1 {
    margin-bottom: calc(var(--spacing, .25rem) * 1);
  }

  .mb-2 {
    margin-bottom: calc(var(--spacing, .25rem) * 2);
  }

  .mb-3 {
    margin-bottom: calc(var(--spacing, .25rem) * 3);
  }

  .mb-4 {
    margin-bottom: calc(var(--spacing, .25rem) * 4);
  }

  .mb-24 {
    margin-bottom: calc(var(--spacing, .25rem) * 24);
  }

  .mb-auto {
    margin-bottom: auto;
  }

  .\\!ml-4 {
    margin-left: calc(var(--spacing, .25rem) * 4) !important;
  }

  .ml-auto {
    margin-left: auto;
  }

  .block {
    display: block;
  }

  .contents {
    display: contents;
  }

  .flex {
    display: flex;
  }

  .flow-root {
    display: flow-root;
  }

  .grid {
    display: grid;
  }

  .hidden {
    display: none;
  }

  .inline {
    display: inline;
  }

  .inline-block {
    display: inline-block;
  }

  .inline-flex {
    display: inline-flex;
  }

  .inline-grid {
    display: inline-grid;
  }

  .inline-table {
    display: inline-table;
  }

  .list-item {
    display: list-item;
  }

  .table {
    display: table;
  }

  .table-caption {
    display: table-caption;
  }

  .table-cell {
    display: table-cell;
  }

  .table-column {
    display: table-column;
  }

  .table-column-group {
    display: table-column-group;
  }

  .table-footer-group {
    display: table-footer-group;
  }

  .table-header-group {
    display: table-header-group;
  }

  .table-row {
    display: table-row;
  }

  .table-row-group {
    display: table-row-group;
  }

  .aspect-square {
    aspect-ratio: 1;
  }

  .size-2 {
    width: calc(var(--spacing, .25rem) * 2);
    height: calc(var(--spacing, .25rem) * 2);
  }

  .size-2\\.5 {
    width: calc(var(--spacing, .25rem) * 2.5);
    height: calc(var(--spacing, .25rem) * 2.5);
  }

  .size-3 {
    width: calc(var(--spacing, .25rem) * 3);
    height: calc(var(--spacing, .25rem) * 3);
  }

  .size-3\\.5 {
    width: calc(var(--spacing, .25rem) * 3.5);
    height: calc(var(--spacing, .25rem) * 3.5);
  }

  .size-4 {
    width: calc(var(--spacing, .25rem) * 4);
    height: calc(var(--spacing, .25rem) * 4);
  }

  .size-4\\.5 {
    width: calc(var(--spacing, .25rem) * 4.5);
    height: calc(var(--spacing, .25rem) * 4.5);
  }

  .size-5 {
    width: calc(var(--spacing, .25rem) * 5);
    height: calc(var(--spacing, .25rem) * 5);
  }

  .size-6 {
    width: calc(var(--spacing, .25rem) * 6);
    height: calc(var(--spacing, .25rem) * 6);
  }

  .size-7 {
    width: calc(var(--spacing, .25rem) * 7);
    height: calc(var(--spacing, .25rem) * 7);
  }

  .size-8 {
    width: calc(var(--spacing, .25rem) * 8);
    height: calc(var(--spacing, .25rem) * 8);
  }

  .size-9 {
    width: calc(var(--spacing, .25rem) * 9);
    height: calc(var(--spacing, .25rem) * 9);
  }

  .size-10 {
    width: calc(var(--spacing, .25rem) * 10);
    height: calc(var(--spacing, .25rem) * 10);
  }

  .size-10\\/12 {
    width: 83.3333%;
    height: 83.3333%;
  }

  .size-11 {
    width: calc(var(--spacing, .25rem) * 11);
    height: calc(var(--spacing, .25rem) * 11);
  }

  .size-12 {
    width: calc(var(--spacing, .25rem) * 12);
    height: calc(var(--spacing, .25rem) * 12);
  }

  .size-14 {
    width: calc(var(--spacing, .25rem) * 14);
    height: calc(var(--spacing, .25rem) * 14);
  }

  .size-full {
    width: 100%;
    height: 100%;
  }

  .\\!h-1\\.5 {
    height: calc(var(--spacing, .25rem) * 1.5) !important;
  }

  .\\!h-12 {
    height: calc(var(--spacing, .25rem) * 12) !important;
  }

  .h-\\(--reka-navigation-menu-viewport-height\\) {
    height: var(--reka-navigation-menu-viewport-height);
  }

  .h-\\(--reka-tabs-indicator-size\\) {
    height: var(--reka-tabs-indicator-size);
  }

  .h-0 {
    height: calc(var(--spacing, .25rem) * 0);
  }

  .h-0\\.5 {
    height: calc(var(--spacing, .25rem) * .5);
  }

  .h-1 {
    height: calc(var(--spacing, .25rem) * 1);
  }

  .h-2 {
    height: calc(var(--spacing, .25rem) * 2);
  }

  .h-2\\.5 {
    height: calc(var(--spacing, .25rem) * 2.5);
  }

  .h-3 {
    height: calc(var(--spacing, .25rem) * 3);
  }

  .h-4 {
    height: calc(var(--spacing, .25rem) * 4);
  }

  .h-5 {
    height: calc(var(--spacing, .25rem) * 5);
  }

  .h-6 {
    height: calc(var(--spacing, .25rem) * 6);
  }

  .h-8 {
    height: calc(var(--spacing, .25rem) * 8);
  }

  .h-10 {
    height: calc(var(--spacing, .25rem) * 10);
  }

  .h-12 {
    height: calc(var(--spacing, .25rem) * 12);
  }

  .h-20 {
    height: calc(var(--spacing, .25rem) * 20);
  }

  .h-38 {
    height: calc(var(--spacing, .25rem) * 38);
  }

  .h-40 {
    height: calc(var(--spacing, .25rem) * 40);
  }

  .h-42 {
    height: calc(var(--spacing, .25rem) * 42);
  }

  .h-44 {
    height: calc(var(--spacing, .25rem) * 44);
  }

  .h-46 {
    height: calc(var(--spacing, .25rem) * 46);
  }

  .h-\\[4px\\] {
    height: 4px;
  }

  .h-\\[5px\\] {
    height: 5px;
  }

  .h-\\[6px\\] {
    height: 6px;
  }

  .h-\\[7px\\] {
    height: 7px;
  }

  .h-\\[8px\\] {
    height: 8px;
  }

  .h-\\[9px\\] {
    height: 9px;
  }

  .h-\\[10px\\] {
    height: 10px;
  }

  .h-\\[11px\\] {
    height: 11px;
  }

  .h-\\[12px\\] {
    height: 12px;
  }

  .h-auto {
    height: auto;
  }

  .h-full {
    height: 100%;
  }

  .h-px {
    height: 1px;
  }

  .max-h-60 {
    max-height: calc(var(--spacing, .25rem) * 60);
  }

  .max-h-\\[32px\\] {
    max-height: 32px;
  }

  .max-h-\\[70vh\\] {
    max-height: 70vh;
  }

  .max-h-\\[96\\%\\] {
    max-height: 96%;
  }

  .max-h-\\[280px\\] {
    max-height: 280px;
  }

  .max-h-\\[calc\\(100dvh-2rem\\)\\] {
    max-height: calc(100dvh - 2rem);
  }

  .max-h-full {
    max-height: 100%;
  }

  .min-h-0 {
    min-height: calc(var(--spacing, .25rem) * 0);
  }

  .min-h-6 {
    min-height: calc(var(--spacing, .25rem) * 6);
  }

  .min-h-16 {
    min-height: calc(var(--spacing, .25rem) * 16);
  }

  .\\!w-1\\.5 {
    width: calc(var(--spacing, .25rem) * 1.5) !important;
  }

  .\\!w-12 {
    width: calc(var(--spacing, .25rem) * 12) !important;
  }

  .w-\\(--reka-combobox-trigger-width\\) {
    width: var(--reka-combobox-trigger-width);
  }

  .w-\\(--reka-navigation-menu-indicator-size\\) {
    width: var(--reka-navigation-menu-indicator-size);
  }

  .w-\\(--reka-select-trigger-width\\) {
    width: var(--reka-select-trigger-width);
  }

  .w-\\(--reka-tabs-indicator-size\\) {
    width: var(--reka-tabs-indicator-size);
  }

  .w-0 {
    width: calc(var(--spacing, .25rem) * 0);
  }

  .w-0\\.5 {
    width: calc(var(--spacing, .25rem) * .5);
  }

  .w-1 {
    width: calc(var(--spacing, .25rem) * 1);
  }

  .w-2 {
    width: calc(var(--spacing, .25rem) * 2);
  }

  .w-3 {
    width: calc(var(--spacing, .25rem) * 3);
  }

  .w-4 {
    width: calc(var(--spacing, .25rem) * 4);
  }

  .w-5 {
    width: calc(var(--spacing, .25rem) * 5);
  }

  .w-6 {
    width: calc(var(--spacing, .25rem) * 6);
  }

  .w-7 {
    width: calc(var(--spacing, .25rem) * 7);
  }

  .w-8 {
    width: calc(var(--spacing, .25rem) * 8);
  }

  .w-9 {
    width: calc(var(--spacing, .25rem) * 9);
  }

  .w-10 {
    width: calc(var(--spacing, .25rem) * 10);
  }

  .w-11 {
    width: calc(var(--spacing, .25rem) * 11);
  }

  .w-38 {
    width: calc(var(--spacing, .25rem) * 38);
  }

  .w-40 {
    width: calc(var(--spacing, .25rem) * 40);
  }

  .w-42 {
    width: calc(var(--spacing, .25rem) * 42);
  }

  .w-44 {
    width: calc(var(--spacing, .25rem) * 44);
  }

  .w-46 {
    width: calc(var(--spacing, .25rem) * 46);
  }

  .w-60 {
    width: calc(var(--spacing, .25rem) * 60);
  }

  .w-\\[6px\\] {
    width: 6px;
  }

  .w-\\[7px\\] {
    width: 7px;
  }

  .w-\\[8px\\] {
    width: 8px;
  }

  .w-\\[9px\\] {
    width: 9px;
  }

  .w-\\[10px\\] {
    width: 10px;
  }

  .w-\\[168px\\] {
    width: 168px;
  }

  .w-\\[384px\\] {
    width: 384px;
  }

  .w-\\[calc\\(100\\%-2rem\\)\\] {
    width: calc(100% - 2rem);
  }

  .w-\\[calc\\(100vw-2rem\\)\\] {
    width: calc(100vw - 2rem);
  }

  .w-auto {
    width: auto;
  }

  .w-full {
    width: 100%;
  }

  .w-px {
    width: 1px;
  }

  .max-w-\\(--ui-container\\) {
    max-width: var(--ui-container);
  }

  .max-w-\\[75px\\] {
    max-width: 75px;
  }

  .max-w-\\[calc\\(100\\%-2rem\\)\\] {
    max-width: calc(100% - 2rem);
  }

  .max-w-lg {
    max-width: var(--container-lg, 32rem);
  }

  .max-w-md {
    max-width: var(--container-md, 28rem);
  }

  .max-w-sm {
    max-width: var(--container-sm, 24rem);
  }

  .min-w-0 {
    min-width: calc(var(--spacing, .25rem) * 0);
  }

  .min-w-5 {
    min-width: calc(var(--spacing, .25rem) * 5);
  }

  .min-w-32 {
    min-width: calc(var(--spacing, .25rem) * 32);
  }

  .min-w-\\[4px\\] {
    min-width: 4px;
  }

  .min-w-\\[5px\\] {
    min-width: 5px;
  }

  .min-w-\\[6px\\] {
    min-width: 6px;
  }

  .min-w-\\[7px\\] {
    min-width: 7px;
  }

  .min-w-\\[8px\\] {
    min-width: 8px;
  }

  .min-w-\\[9px\\] {
    min-width: 9px;
  }

  .min-w-\\[10px\\] {
    min-width: 10px;
  }

  .min-w-\\[11px\\] {
    min-width: 11px;
  }

  .min-w-\\[12px\\] {
    min-width: 12px;
  }

  .min-w-\\[16px\\] {
    min-width: 16px;
  }

  .min-w-\\[20px\\] {
    min-width: 20px;
  }

  .min-w-\\[24px\\] {
    min-width: 24px;
  }

  .min-w-full {
    min-width: 100%;
  }

  .flex-1 {
    flex: 1;
  }

  .flex-shrink, .shrink {
    flex-shrink: 1;
  }

  .shrink-0 {
    flex-shrink: 0;
  }

  .flex-grow, .grow {
    flex-grow: 1;
  }

  .basis-full {
    flex-basis: 100%;
  }

  .border-collapse {
    border-collapse: collapse;
  }

  .origin-\\(--reka-combobox-content-transform-origin\\) {
    transform-origin: var(--reka-combobox-content-transform-origin);
  }

  .origin-\\(--reka-context-menu-content-transform-origin\\) {
    transform-origin: var(--reka-context-menu-content-transform-origin);
  }

  .origin-\\(--reka-dropdown-menu-content-transform-origin\\) {
    transform-origin: var(--reka-dropdown-menu-content-transform-origin);
  }

  .origin-\\(--reka-popover-content-transform-origin\\) {
    transform-origin: var(--reka-popover-content-transform-origin);
  }

  .origin-\\(--reka-select-content-transform-origin\\) {
    transform-origin: var(--reka-select-content-transform-origin);
  }

  .origin-\\(--reka-tooltip-content-transform-origin\\) {
    transform-origin: var(--reka-tooltip-content-transform-origin);
  }

  .origin-\\[top_center\\] {
    transform-origin: top;
  }

  .-translate-x-1 {
    --tw-translate-x: calc(var(--spacing, .25rem) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .-translate-x-1\\/2 {
    --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .-translate-x-\\[4px\\] {
    --tw-translate-x: calc(4px * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-x-\\(--reka-navigation-menu-indicator-position\\) {
    --tw-translate-x: var(--reka-navigation-menu-indicator-position);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-x-\\(--reka-tabs-indicator-position\\) {
    --tw-translate-x: var(--reka-tabs-indicator-position);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-x-1 {
    --tw-translate-x: calc(var(--spacing, .25rem) * 1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-x-1\\/2 {
    --tw-translate-x: calc(1 / 2 * 100%);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-x-2 {
    --tw-translate-x: calc(var(--spacing, .25rem) * 2);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .-translate-y-1 {
    --tw-translate-y: calc(var(--spacing, .25rem) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .-translate-y-1\\/2 {
    --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-y-\\(--reka-tabs-indicator-position\\) {
    --tw-translate-y: var(--reka-tabs-indicator-position);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-y-1 {
    --tw-translate-y: calc(var(--spacing, .25rem) * 1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-y-1\\/2 {
    --tw-translate-y: calc(1 / 2 * 100%);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-y-3 {
    --tw-translate-y: calc(var(--spacing, .25rem) * 3);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .translate-none {
    translate: none;
  }

  .scale-80 {
    --tw-scale-x: 80%;
    --tw-scale-y: 80%;
    --tw-scale-z: 80%;
    scale: var(--tw-scale-x) var(--tw-scale-y);
  }

  .scale-3d {
    scale: var(--tw-scale-x) var(--tw-scale-y) var(--tw-scale-z);
  }

  .rotate-45 {
    rotate: 45deg;
  }

  .rotate-90 {
    rotate: 90deg;
  }

  .transform {
    transform: var(--tw-rotate-x, ) var(--tw-rotate-y, ) var(--tw-rotate-z, ) var(--tw-skew-x, ) var(--tw-skew-y, );
  }

  .transform-\\(--transform\\) {
    transform: var(--transform);
  }

  .animate-pulse {
    animation: var(--animate-pulse, pulse 2s cubic-bezier(.4, 0, .6, 1) infinite);
  }

  .animate-spin {
    animation: var(--animate-spin, spin 1s linear infinite);
  }

  .cursor-move {
    cursor: move;
  }

  .cursor-not-allowed {
    cursor: not-allowed;
  }

  .cursor-pointer {
    cursor: pointer;
  }

  .touch-pinch-zoom {
    --tw-pinch-zoom: pinch-zoom;
    touch-action: var(--tw-pan-x, ) var(--tw-pan-y, ) var(--tw-pinch-zoom, );
  }

  .touch-none {
    touch-action: none;
  }

  .resize {
    resize: both;
  }

  .resize-none {
    resize: none;
  }

  .scroll-py-1 {
    scroll-padding-block: calc(var(--spacing, .25rem) * 1);
  }

  .columns-3 {
    columns: 3;
  }

  .grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .grid-cols-7 {
    grid-template-columns: repeat(7, minmax(0, 1fr));
  }

  .flex-col {
    flex-direction: column;
  }

  .flex-col-reverse {
    flex-direction: column-reverse;
  }

  .flex-row {
    flex-direction: row;
  }

  .flex-row-reverse {
    flex-direction: row-reverse;
  }

  .flex-wrap {
    flex-wrap: wrap;
  }

  .place-items-center {
    place-items: center;
  }

  .content-center {
    align-content: center;
  }

  .items-center {
    align-items: center;
  }

  .items-end {
    align-items: flex-end;
  }

  .items-start {
    align-items: flex-start;
  }

  .items-stretch {
    align-items: stretch;
  }

  .justify-between {
    justify-content: space-between;
  }

  .justify-center {
    justify-content: center;
  }

  .justify-end {
    justify-content: flex-end;
  }

  .gap-0 {
    gap: calc(var(--spacing, .25rem) * 0);
  }

  .gap-0\\.5 {
    gap: calc(var(--spacing, .25rem) * .5);
  }

  .gap-1 {
    gap: calc(var(--spacing, .25rem) * 1);
  }

  .gap-1\\.5 {
    gap: calc(var(--spacing, .25rem) * 1.5);
  }

  .gap-2 {
    gap: calc(var(--spacing, .25rem) * 2);
  }

  .gap-2\\.5 {
    gap: calc(var(--spacing, .25rem) * 2.5);
  }

  .gap-3 {
    gap: calc(var(--spacing, .25rem) * 3);
  }

  .gap-3\\.5 {
    gap: calc(var(--spacing, .25rem) * 3.5);
  }

  .gap-4 {
    gap: calc(var(--spacing, .25rem) * 4);
  }

  .gap-6 {
    gap: calc(var(--spacing, .25rem) * 6);
  }

  .gap-7 {
    gap: calc(var(--spacing, .25rem) * 7);
  }

  :where(.-space-y-px > :not(:last-child)) {
    --tw-space-y-reverse: 0;
    margin-block-start: calc(-1px * var(--tw-space-y-reverse));
    margin-block-end: calc(-1px * calc(1 - var(--tw-space-y-reverse)));
  }

  :where(.space-y-1 > :not(:last-child)) {
    --tw-space-y-reverse: 0;
    margin-block-start: calc(calc(var(--spacing, .25rem) * 1) * var(--tw-space-y-reverse));
    margin-block-end: calc(calc(var(--spacing, .25rem) * 1) * calc(1 - var(--tw-space-y-reverse)));
  }

  :where(.space-y-2 > :not(:last-child)) {
    --tw-space-y-reverse: 0;
    margin-block-start: calc(calc(var(--spacing, .25rem) * 2) * var(--tw-space-y-reverse));
    margin-block-end: calc(calc(var(--spacing, .25rem) * 2) * calc(1 - var(--tw-space-y-reverse)));
  }

  :where(.space-y-3 > :not(:last-child)) {
    --tw-space-y-reverse: 0;
    margin-block-start: calc(calc(var(--spacing, .25rem) * 3) * var(--tw-space-y-reverse));
    margin-block-end: calc(calc(var(--spacing, .25rem) * 3) * calc(1 - var(--tw-space-y-reverse)));
  }

  :where(.space-y-4 > :not(:last-child)) {
    --tw-space-y-reverse: 0;
    margin-block-start: calc(calc(var(--spacing, .25rem) * 4) * var(--tw-space-y-reverse));
    margin-block-end: calc(calc(var(--spacing, .25rem) * 4) * calc(1 - var(--tw-space-y-reverse)));
  }

  :where(.space-y-reverse > :not(:last-child)) {
    --tw-space-y-reverse: 1;
  }

  .gap-x-2 {
    column-gap: calc(var(--spacing, .25rem) * 2);
  }

  :where(.-space-x-px > :not(:last-child)) {
    --tw-space-x-reverse: 0;
    margin-inline-start: calc(-1px * var(--tw-space-x-reverse));
    margin-inline-end: calc(-1px * calc(1 - var(--tw-space-x-reverse)));
  }

  :where(.space-x-1 > :not(:last-child)) {
    --tw-space-x-reverse: 0;
    margin-inline-start: calc(calc(var(--spacing, .25rem) * 1) * var(--tw-space-x-reverse));
    margin-inline-end: calc(calc(var(--spacing, .25rem) * 1) * calc(1 - var(--tw-space-x-reverse)));
  }

  :where(.space-x-reverse > :not(:last-child)) {
    --tw-space-x-reverse: 1;
  }

  .gap-y-0 {
    row-gap: calc(var(--spacing, .25rem) * 0);
  }

  .gap-y-0\\.5 {
    row-gap: calc(var(--spacing, .25rem) * .5);
  }

  .gap-y-1 {
    row-gap: calc(var(--spacing, .25rem) * 1);
  }

  .gap-y-1\\.5 {
    row-gap: calc(var(--spacing, .25rem) * 1.5);
  }

  :where(.divide-x > :not(:last-child)) {
    --tw-divide-x-reverse: 0;
    border-inline-style: var(--tw-border-style);
    border-inline-start-width: calc(1px * var(--tw-divide-x-reverse));
    border-inline-end-width: calc(1px * calc(1 - var(--tw-divide-x-reverse)));
  }

  :where(.divide-y > :not(:last-child)) {
    --tw-divide-y-reverse: 0;
    border-bottom-style: var(--tw-border-style);
    border-top-style: var(--tw-border-style);
    border-top-width: calc(1px * var(--tw-divide-y-reverse));
    border-bottom-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  }

  :where(.divide-y-reverse > :not(:last-child)) {
    --tw-divide-y-reverse: 1;
  }

  :where(.divide-default > :not(:last-child)) {
    border-color: var(--ui-border);
  }

  .self-end {
    align-self: flex-end;
  }

  .truncate {
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
  }

  .overflow-auto {
    overflow: auto;
  }

  .overflow-clip {
    overflow: clip;
  }

  .overflow-hidden {
    overflow: hidden;
  }

  .overflow-y-auto {
    overflow-y: auto;
  }

  .rounded {
    border-radius: .25rem;
  }

  .rounded-\\[inherit\\] {
    border-radius: inherit;
  }

  .rounded-full {
    border-radius: 3.40282e38px;
  }

  .rounded-lg {
    border-radius: var(--radius-lg, .5rem);
  }

  .rounded-md {
    border-radius: var(--radius-md, .375rem);
  }

  .rounded-sm {
    border-radius: var(--radius-sm, .25rem);
  }

  .rounded-xs {
    border-radius: var(--radius-xs, .125rem);
  }

  .rounded-s {
    border-start-start-radius: .25rem;
    border-end-start-radius: .25rem;
  }

  .rounded-ss {
    border-start-start-radius: .25rem;
  }

  .rounded-e {
    border-start-end-radius: .25rem;
    border-end-end-radius: .25rem;
  }

  .rounded-se {
    border-start-end-radius: .25rem;
  }

  .rounded-ee {
    border-end-end-radius: .25rem;
  }

  .rounded-es {
    border-end-start-radius: .25rem;
  }

  .rounded-t {
    border-top-left-radius: .25rem;
    border-top-right-radius: .25rem;
  }

  .rounded-t-lg {
    border-top-left-radius: var(--radius-lg, .5rem);
    border-top-right-radius: var(--radius-lg, .5rem);
  }

  .rounded-l {
    border-top-left-radius: .25rem;
    border-bottom-left-radius: .25rem;
  }

  .rounded-l-lg {
    border-top-left-radius: var(--radius-lg, .5rem);
    border-bottom-left-radius: var(--radius-lg, .5rem);
  }

  .rounded-tl {
    border-top-left-radius: .25rem;
  }

  .rounded-r {
    border-top-right-radius: .25rem;
    border-bottom-right-radius: .25rem;
  }

  .rounded-r-lg {
    border-top-right-radius: var(--radius-lg, .5rem);
    border-bottom-right-radius: var(--radius-lg, .5rem);
  }

  .rounded-tr {
    border-top-right-radius: .25rem;
  }

  .rounded-b {
    border-bottom-right-radius: .25rem;
    border-bottom-left-radius: .25rem;
  }

  .rounded-b-lg {
    border-bottom-right-radius: var(--radius-lg, .5rem);
    border-bottom-left-radius: var(--radius-lg, .5rem);
  }

  .rounded-br {
    border-bottom-right-radius: .25rem;
  }

  .rounded-bl {
    border-bottom-left-radius: .25rem;
  }

  .rounded-bl-lg {
    border-bottom-left-radius: var(--radius-lg, .5rem);
  }

  .border {
    border-style: var(--tw-border-style);
    border-width: 1px;
  }

  .border-0 {
    border-style: var(--tw-border-style);
    border-width: 0;
  }

  .border-2 {
    border-style: var(--tw-border-style);
    border-width: 2px;
  }

  .border-x {
    border-inline-style: var(--tw-border-style);
    border-inline-width: 1px;
  }

  .border-y {
    border-block-style: var(--tw-border-style);
    border-block-width: 1px;
  }

  .border-s {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 1px;
  }

  .border-s-\\[2px\\] {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 2px;
  }

  .border-s-\\[3px\\] {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 3px;
  }

  .border-s-\\[4px\\] {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 4px;
  }

  .border-s-\\[5px\\] {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 5px;
  }

  .border-e {
    border-inline-end-style: var(--tw-border-style);
    border-inline-end-width: 1px;
  }

  .border-t {
    border-top-style: var(--tw-border-style);
    border-top-width: 1px;
  }

  .border-t-\\[2px\\] {
    border-top-style: var(--tw-border-style);
    border-top-width: 2px;
  }

  .border-t-\\[3px\\] {
    border-top-style: var(--tw-border-style);
    border-top-width: 3px;
  }

  .border-t-\\[4px\\] {
    border-top-style: var(--tw-border-style);
    border-top-width: 4px;
  }

  .border-t-\\[5px\\] {
    border-top-style: var(--tw-border-style);
    border-top-width: 5px;
  }

  .border-r {
    border-right-style: var(--tw-border-style);
    border-right-width: 1px;
  }

  .border-b {
    border-bottom-style: var(--tw-border-style);
    border-bottom-width: 1px;
  }

  .border-l {
    border-left-style: var(--tw-border-style);
    border-left-width: 1px;
  }

  .border-dashed {
    --tw-border-style: dashed;
    border-style: dashed;
  }

  .border-dotted {
    --tw-border-style: dotted;
    border-style: dotted;
  }

  .border-none {
    --tw-border-style: none;
    border-style: none;
  }

  .border-solid {
    --tw-border-style: solid;
    border-style: solid;
  }

  .border-\\[var\\(--color-neutral-100\\)\\] {
    border-color: var(--color-neutral-100);
  }

  .border-\\[var\\(--color-neutral-200\\)\\] {
    border-color: var(--color-neutral-200);
  }

  .border-\\[var\\(--ui-primary\\)\\] {
    border-color: var(--ui-primary);
  }

  .border-bg {
    border-color: var(--ui-bg);
  }

  .border-blue-500 {
    border-color: var(--color-blue-500);
  }

  .border-default {
    border-color: var(--ui-border);
  }

  .border-error {
    border-color: var(--ui-error);
  }

  .border-info {
    border-color: var(--ui-info);
  }

  .border-inverted {
    border-color: var(--ui-border-inverted);
  }

  .border-muted {
    border-color: var(--ui-border-muted);
  }

  .border-primary {
    border-color: var(--ui-primary);
  }

  .border-secondary {
    border-color: var(--ui-secondary);
  }

  .border-success {
    border-color: var(--ui-success);
  }

  .border-transparent {
    border-color: #0000;
  }

  .border-warning {
    border-color: var(--ui-warning);
  }

  .\\!bg-accented {
    background-color: var(--ui-bg-accented) !important;
  }

  .bg-\\(--ui-border-accented\\) {
    background-color: var(--ui-border-accented);
  }

  .bg-\\[rgba\\(0\\,0\\,0\\,0\\.4\\)\\] {
    background-color: #0006;
  }

  .bg-\\[var\\(--color-blue-50\\)\\] {
    background-color: var(--color-blue-50);
  }

  .bg-accented {
    background-color: var(--ui-bg-accented);
  }

  .bg-blue-100 {
    background-color: var(--color-blue-100);
  }

  .bg-border {
    background-color: var(--ui-border);
  }

  .bg-default, .bg-default\\/75 {
    background-color: var(--ui-bg);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-default\\/75 {
      background-color: color-mix(in oklab, var(--ui-bg) 75%, transparent);
    }
  }

  .bg-elevated, .bg-elevated\\/50 {
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-elevated\\/50 {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .bg-elevated\\/75 {
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-elevated\\/75 {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 75%, transparent);
    }
  }

  .bg-error, .bg-error\\/10 {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-error\\/10 {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .bg-gray-300 {
    background-color: var(--color-gray-300, oklch(87.2% .01 258.338));
  }

  .bg-gray-500 {
    background-color: var(--color-gray-500, oklch(55.1% .027 264.364));
  }

  .bg-gray-800 {
    background-color: var(--color-gray-800, oklch(27.8% .033 256.848));
  }

  .bg-info, .bg-info\\/10 {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-info\\/10 {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .bg-inverted {
    background-color: var(--ui-bg-inverted);
  }

  .bg-primary, .bg-primary\\/10 {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-primary\\/10 {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .bg-secondary, .bg-secondary\\/10 {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-secondary\\/10 {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .bg-success, .bg-success\\/10 {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-success\\/10 {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .bg-transparent {
    background-color: #0000;
  }

  .bg-warning, .bg-warning\\/10 {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .bg-warning\\/10 {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .bg-white {
    background-color: var(--color-white, #fff);
  }

  .bg-repeat {
    background-repeat: repeat;
  }

  .fill-default {
    fill: var(--ui-border);
  }

  .object-cover {
    object-fit: cover;
  }

  .p-0 {
    padding: calc(var(--spacing, .25rem) * 0);
  }

  .p-0\\.5 {
    padding: calc(var(--spacing, .25rem) * .5);
  }

  .p-1 {
    padding: calc(var(--spacing, .25rem) * 1);
  }

  .p-1\\.5 {
    padding: calc(var(--spacing, .25rem) * 1.5);
  }

  .p-2 {
    padding: calc(var(--spacing, .25rem) * 2);
  }

  .p-2\\.5 {
    padding: calc(var(--spacing, .25rem) * 2.5);
  }

  .p-3 {
    padding: calc(var(--spacing, .25rem) * 3);
  }

  .p-3\\.5 {
    padding: calc(var(--spacing, .25rem) * 3.5);
  }

  .p-4 {
    padding: calc(var(--spacing, .25rem) * 4);
  }

  .p-4\\.5 {
    padding: calc(var(--spacing, .25rem) * 4.5);
  }

  .px-1 {
    padding-inline: calc(var(--spacing, .25rem) * 1);
  }

  .px-1\\.5 {
    padding-inline: calc(var(--spacing, .25rem) * 1.5);
  }

  .px-2 {
    padding-inline: calc(var(--spacing, .25rem) * 2);
  }

  .px-2\\.5 {
    padding-inline: calc(var(--spacing, .25rem) * 2.5);
  }

  .px-3 {
    padding-inline: calc(var(--spacing, .25rem) * 3);
  }

  .px-4 {
    padding-inline: calc(var(--spacing, .25rem) * 4);
  }

  .px-6 {
    padding-inline: calc(var(--spacing, .25rem) * 6);
  }

  .px-7 {
    padding-inline: calc(var(--spacing, .25rem) * 7);
  }

  .px-8 {
    padding-inline: calc(var(--spacing, .25rem) * 8);
  }

  .px-9 {
    padding-inline: calc(var(--spacing, .25rem) * 9);
  }

  .px-10 {
    padding-inline: calc(var(--spacing, .25rem) * 10);
  }

  .px-11 {
    padding-inline: calc(var(--spacing, .25rem) * 11);
  }

  .py-0 {
    padding-block: calc(var(--spacing, .25rem) * 0);
  }

  .py-0\\.5 {
    padding-block: calc(var(--spacing, .25rem) * .5);
  }

  .py-1 {
    padding-block: calc(var(--spacing, .25rem) * 1);
  }

  .py-1\\.5 {
    padding-block: calc(var(--spacing, .25rem) * 1.5);
  }

  .py-2 {
    padding-block: calc(var(--spacing, .25rem) * 2);
  }

  .py-3 {
    padding-block: calc(var(--spacing, .25rem) * 3);
  }

  .py-3\\.5 {
    padding-block: calc(var(--spacing, .25rem) * 3.5);
  }

  .py-6 {
    padding-block: calc(var(--spacing, .25rem) * 6);
  }

  .py-\\[6px\\] {
    padding-block: 6px;
  }

  .ps-1 {
    padding-inline-start: calc(var(--spacing, .25rem) * 1);
  }

  .ps-1\\.5 {
    padding-inline-start: calc(var(--spacing, .25rem) * 1.5);
  }

  .ps-2 {
    padding-inline-start: calc(var(--spacing, .25rem) * 2);
  }

  .ps-2\\.5 {
    padding-inline-start: calc(var(--spacing, .25rem) * 2.5);
  }

  .ps-3 {
    padding-inline-start: calc(var(--spacing, .25rem) * 3);
  }

  .ps-4 {
    padding-inline-start: calc(var(--spacing, .25rem) * 4);
  }

  .ps-7 {
    padding-inline-start: calc(var(--spacing, .25rem) * 7);
  }

  .ps-8 {
    padding-inline-start: calc(var(--spacing, .25rem) * 8);
  }

  .ps-9 {
    padding-inline-start: calc(var(--spacing, .25rem) * 9);
  }

  .ps-10 {
    padding-inline-start: calc(var(--spacing, .25rem) * 10);
  }

  .ps-11 {
    padding-inline-start: calc(var(--spacing, .25rem) * 11);
  }

  .pe-1 {
    padding-inline-end: calc(var(--spacing, .25rem) * 1);
  }

  .pe-2 {
    padding-inline-end: calc(var(--spacing, .25rem) * 2);
  }

  .pe-2\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 2.5);
  }

  .pe-3 {
    padding-inline-end: calc(var(--spacing, .25rem) * 3);
  }

  .pe-4 {
    padding-inline-end: calc(var(--spacing, .25rem) * 4);
  }

  .pe-4\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 4.5);
  }

  .pe-5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 5);
  }

  .pe-5\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 5.5);
  }

  .pe-6 {
    padding-inline-end: calc(var(--spacing, .25rem) * 6);
  }

  .pe-6\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 6.5);
  }

  .pe-7 {
    padding-inline-end: calc(var(--spacing, .25rem) * 7);
  }

  .pe-7\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 7.5);
  }

  .pe-8 {
    padding-inline-end: calc(var(--spacing, .25rem) * 8);
  }

  .pe-8\\.5 {
    padding-inline-end: calc(var(--spacing, .25rem) * 8.5);
  }

  .pe-9 {
    padding-inline-end: calc(var(--spacing, .25rem) * 9);
  }

  .pe-10 {
    padding-inline-end: calc(var(--spacing, .25rem) * 10);
  }

  .pe-11 {
    padding-inline-end: calc(var(--spacing, .25rem) * 11);
  }

  .pt-2 {
    padding-top: calc(var(--spacing, .25rem) * 2);
  }

  .pt-4 {
    padding-top: calc(var(--spacing, .25rem) * 4);
  }

  .pr-2 {
    padding-right: calc(var(--spacing, .25rem) * 2);
  }

  .pb-3 {
    padding-bottom: calc(var(--spacing, .25rem) * 3);
  }

  .pb-3\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 3.5);
  }

  .pb-4 {
    padding-bottom: calc(var(--spacing, .25rem) * 4);
  }

  .pb-4\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 4.5);
  }

  .pb-5 {
    padding-bottom: calc(var(--spacing, .25rem) * 5);
  }

  .pb-5\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 5.5);
  }

  .pb-6 {
    padding-bottom: calc(var(--spacing, .25rem) * 6);
  }

  .pb-6\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 6.5);
  }

  .pb-7 {
    padding-bottom: calc(var(--spacing, .25rem) * 7);
  }

  .pb-7\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 7.5);
  }

  .pb-8 {
    padding-bottom: calc(var(--spacing, .25rem) * 8);
  }

  .pb-8\\.5 {
    padding-bottom: calc(var(--spacing, .25rem) * 8.5);
  }

  .pl-2 {
    padding-left: calc(var(--spacing, .25rem) * 2);
  }

  .text-center {
    text-align: center;
  }

  .text-end {
    text-align: end;
  }

  .text-left {
    text-align: left;
  }

  .text-start {
    text-align: start;
  }

  .align-middle {
    vertical-align: middle;
  }

  .align-top {
    vertical-align: top;
  }

  .font-sans {
    font-family: var(--font-sans);
  }

  .text-2xl {
    font-size: var(--text-2xl, 1.5rem);
    line-height: var(--tw-leading, var(--text-2xl--line-height, calc(2 / 1.5)));
  }

  .text-\\[8px\\]\\/3 {
    font-size: 8px;
    line-height: calc(var(--spacing, .25rem) * 3);
  }

  .text-\\[10px\\]\\/3 {
    font-size: 10px;
    line-height: calc(var(--spacing, .25rem) * 3);
  }

  .text-base {
    font-size: var(--text-base, 1rem);
    line-height: var(--tw-leading, var(--text-base--line-height, calc(1.5 / 1)));
  }

  .text-lg {
    font-size: var(--text-lg, 1.125rem);
    line-height: var(--tw-leading, var(--text-lg--line-height, calc(1.75 / 1.125)));
  }

  .text-sm {
    font-size: var(--text-sm, .875rem);
    line-height: var(--tw-leading, var(--text-sm--line-height, calc(1.25 / .875)));
  }

  .text-xl {
    font-size: var(--text-xl, 1.25rem);
    line-height: var(--tw-leading, var(--text-xl--line-height, calc(1.75 / 1.25)));
  }

  .text-xs {
    font-size: var(--text-xs, .75rem);
    line-height: var(--tw-leading, var(--text-xs--line-height, calc(1 / .75)));
  }

  .text-xs\\/5 {
    font-size: var(--text-xs, .75rem);
    line-height: calc(var(--spacing, .25rem) * 5);
  }

  .text-\\[4px\\] {
    font-size: 4px;
  }

  .text-\\[5px\\] {
    font-size: 5px;
  }

  .text-\\[6px\\] {
    font-size: 6px;
  }

  .text-\\[7px\\] {
    font-size: 7px;
  }

  .text-\\[8px\\] {
    font-size: 8px;
  }

  .text-\\[9px\\] {
    font-size: 9px;
  }

  .text-\\[10px\\] {
    font-size: 10px;
  }

  .text-\\[11px\\] {
    font-size: 11px;
  }

  .text-\\[12px\\] {
    font-size: 12px;
  }

  .text-\\[22px\\] {
    font-size: 22px;
  }

  .leading-none {
    --tw-leading: 1;
    line-height: 1;
  }

  .font-bold {
    --tw-font-weight: var(--font-weight-bold, 700);
    font-weight: var(--font-weight-bold, 700);
  }

  .font-medium {
    --tw-font-weight: var(--font-weight-medium, 500);
    font-weight: var(--font-weight-medium, 500);
  }

  .font-normal {
    --tw-font-weight: var(--font-weight-normal, 400);
    font-weight: var(--font-weight-normal, 400);
  }

  .font-semibold {
    --tw-font-weight: var(--font-weight-semibold, 600);
    font-weight: var(--font-weight-semibold, 600);
  }

  .text-wrap {
    text-wrap: wrap;
  }

  .break-words {
    overflow-wrap: break-word;
  }

  .wrap-anywhere {
    overflow-wrap: anywhere;
  }

  .text-clip {
    text-overflow: clip;
  }

  .text-ellipsis {
    text-overflow: ellipsis;
  }

  .whitespace-nowrap {
    white-space: nowrap;
  }

  .text-\\[var\\(--color-neutral-300\\)\\] {
    color: var(--color-neutral-300);
  }

  .text-\\[var\\(--color-neutral-400\\)\\] {
    color: var(--color-neutral-400);
  }

  .text-\\[var\\(--header-icon-color\\)\\] {
    color: var(--header-icon-color);
  }

  .text-\\[var\\(--ui-primary\\)\\] {
    color: var(--ui-primary);
  }

  .text-blue-600 {
    color: var(--color-blue-600);
  }

  .text-default {
    color: var(--ui-text);
  }

  .text-dimmed {
    color: var(--ui-text-dimmed);
  }

  .text-error, .text-error\\/75 {
    color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-error\\/75 {
      color: color-mix(in oklab, var(--ui-error) 75%, transparent);
    }
  }

  .text-gray-400 {
    color: var(--color-gray-400, oklch(70.7% .022 261.325));
  }

  .text-gray-500 {
    color: var(--color-gray-500, oklch(55.1% .027 264.364));
  }

  .text-gray-600 {
    color: var(--color-gray-600, oklch(44.6% .03 256.802));
  }

  .text-green-600 {
    color: var(--color-green-600, oklch(62.7% .194 149.214));
  }

  .text-highlighted {
    color: var(--ui-text-highlighted);
  }

  .text-info, .text-info\\/75 {
    color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-info\\/75 {
      color: color-mix(in oklab, var(--ui-info) 75%, transparent);
    }
  }

  .text-inherit {
    color: inherit;
  }

  .text-inverted {
    color: var(--ui-text-inverted);
  }

  .text-muted {
    color: var(--ui-text-muted);
  }

  .text-primary, .text-primary\\/75 {
    color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-primary\\/75 {
      color: color-mix(in oklab, var(--ui-primary) 75%, transparent);
    }
  }

  .text-red-600 {
    color: var(--color-red-600, oklch(57.7% .245 27.325));
  }

  .text-secondary, .text-secondary\\/75 {
    color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-secondary\\/75 {
      color: color-mix(in oklab, var(--ui-secondary) 75%, transparent);
    }
  }

  .text-success, .text-success\\/75 {
    color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-success\\/75 {
      color: color-mix(in oklab, var(--ui-success) 75%, transparent);
    }
  }

  .text-warning, .text-warning\\/75 {
    color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .text-warning\\/75 {
      color: color-mix(in oklab, var(--ui-warning) 75%, transparent);
    }
  }

  .text-white {
    color: var(--color-white, #fff);
  }

  .text-yellow-500 {
    color: var(--color-yellow-500, oklch(79.5% .184 86.047));
  }

  .text-yellow-600 {
    color: var(--color-yellow-600, oklch(68.1% .162 75.834));
  }

  .capitalize {
    text-transform: capitalize;
  }

  .lowercase {
    text-transform: lowercase;
  }

  .normal-case {
    text-transform: none;
  }

  .uppercase {
    text-transform: uppercase;
  }

  .italic {
    font-style: italic;
  }

  .not-italic {
    font-style: normal;
  }

  .diagonal-fractions {
    --tw-numeric-fraction: diagonal-fractions;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .lining-nums {
    --tw-numeric-figure: lining-nums;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .oldstyle-nums {
    --tw-numeric-figure: oldstyle-nums;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .ordinal {
    --tw-ordinal: ordinal;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .proportional-nums {
    --tw-numeric-spacing: proportional-nums;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .slashed-zero {
    --tw-slashed-zero: slashed-zero;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .stacked-fractions {
    --tw-numeric-fraction: stacked-fractions;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .tabular-nums {
    --tw-numeric-spacing: tabular-nums;
    font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
  }

  .normal-nums {
    font-variant-numeric: normal;
  }

  .line-through {
    text-decoration-line: line-through;
  }

  .no-underline {
    text-decoration-line: none;
  }

  .overline {
    text-decoration-line: overline;
  }

  .underline {
    text-decoration-line: underline;
  }

  .antialiased {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .subpixel-antialiased {
    -webkit-font-smoothing: auto;
    -moz-osx-font-smoothing: auto;
  }

  .opacity-0 {
    opacity: 0;
  }

  .opacity-75 {
    opacity: .75;
  }

  .opacity-90 {
    opacity: .9;
  }

  .opacity-100 {
    opacity: 1;
  }

  .shadow {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, #0000001a), 0 1px 2px -1px var(--tw-shadow-color, #0000001a);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .shadow-lg {
    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, #0000001a), 0 4px 6px -4px var(--tw-shadow-color, #0000001a);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .shadow-sm {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, #0000001a), 0 1px 2px -1px var(--tw-shadow-color, #0000001a);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .shadow-xs {
    --tw-shadow: 0 1px 2px 0 var(--tw-shadow-color, #0000000d);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .ring {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .ring-0 {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .ring-2 {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .ring-3 {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .inset-ring {
    --tw-inset-ring-shadow: inset 0 0 0 1px var(--tw-inset-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .ring-\\(--color-white\\) {
    --tw-ring-color: var(--color-white);
  }

  .ring-accented {
    --tw-ring-color: var(--ui-border-accented);
  }

  .ring-bg {
    --tw-ring-color: var(--ui-bg);
  }

  .ring-default {
    --tw-ring-color: var(--ui-border);
  }

  .ring-error, .ring-error\\/25 {
    --tw-ring-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-error\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-error) 25%, transparent);
    }
  }

  .ring-error\\/50 {
    --tw-ring-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-error\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-error) 50%, transparent);
    }
  }

  .ring-info, .ring-info\\/25 {
    --tw-ring-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-info\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-info) 25%, transparent);
    }
  }

  .ring-info\\/50 {
    --tw-ring-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-info\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-info) 50%, transparent);
    }
  }

  .ring-inverted {
    --tw-ring-color: var(--ui-border-inverted);
  }

  .ring-primary, .ring-primary\\/25 {
    --tw-ring-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-primary\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-primary) 25%, transparent);
    }
  }

  .ring-primary\\/50 {
    --tw-ring-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-primary\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-primary) 50%, transparent);
    }
  }

  .ring-secondary, .ring-secondary\\/25 {
    --tw-ring-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-secondary\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-secondary) 25%, transparent);
    }
  }

  .ring-secondary\\/50 {
    --tw-ring-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-secondary\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-secondary) 50%, transparent);
    }
  }

  .ring-success, .ring-success\\/25 {
    --tw-ring-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-success\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-success) 25%, transparent);
    }
  }

  .ring-success\\/50 {
    --tw-ring-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-success\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-success) 50%, transparent);
    }
  }

  .ring-warning, .ring-warning\\/25 {
    --tw-ring-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-warning\\/25 {
      --tw-ring-color: color-mix(in oklab, var(--ui-warning) 25%, transparent);
    }
  }

  .ring-warning\\/50 {
    --tw-ring-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .ring-warning\\/50 {
      --tw-ring-color: color-mix(in oklab, var(--ui-warning) 50%, transparent);
    }
  }

  .outline {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }

  .blur {
    --tw-blur: blur(8px);
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .drop-shadow {
    --tw-drop-shadow-size: drop-shadow(0 1px 2px var(--tw-drop-shadow-color, #0000001a)) drop-shadow(0 1px 1px var(--tw-drop-shadow-color, #0000000f));
    --tw-drop-shadow: drop-shadow(0 1px 2px #0000001a) drop-shadow(0 1px 1px #0000000f);
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .grayscale {
    --tw-grayscale: grayscale(100%);
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .invert {
    --tw-invert: invert(100%);
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .sepia {
    --tw-sepia: sepia(100%);
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .filter {
    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
  }

  .backdrop-blur {
    --tw-backdrop-blur: blur(8px);
    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
  }

  .backdrop-grayscale {
    --tw-backdrop-grayscale: grayscale(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
  }

  .backdrop-invert {
    --tw-backdrop-invert: invert(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
  }

  .backdrop-sepia {
    --tw-backdrop-sepia: sepia(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
  }

  .backdrop-filter {
    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );
  }

  .transition {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, visibility, content-visibility, overlay, pointer-events;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[background\\] {
    transition-property: background;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[color\\,opacity\\] {
    transition-property: color, opacity;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[transform\\,translate\\,height\\] {
    transition-property: transform, translate, height;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[translate\\,width\\] {
    transition-property: translate, width;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[width\\,height\\,left\\] {
    transition-property: width, height, left;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-\\[width\\] {
    transition-property: width;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-all {
    transition-property: all;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-colors {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-opacity {
    transition-property: opacity;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .transition-transform {
    transition-property: transform, translate, scale, rotate;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .duration-200 {
    --tw-duration: .2s;
    transition-duration: .2s;
  }

  .ease-in {
    --tw-ease: var(--ease-in, cubic-bezier(.4, 0, 1, 1));
    transition-timing-function: var(--ease-in, cubic-bezier(.4, 0, 1, 1));
  }

  .ease-in-out {
    --tw-ease: var(--ease-in-out, cubic-bezier(.4, 0, .2, 1));
    transition-timing-function: var(--ease-in-out, cubic-bezier(.4, 0, .2, 1));
  }

  .ease-out {
    --tw-ease: var(--ease-out, cubic-bezier(0, 0, .2, 1));
    transition-timing-function: var(--ease-out, cubic-bezier(0, 0, .2, 1));
  }

  .outline-none {
    --tw-outline-style: none;
    outline-style: none;
  }

  .select-none {
    -webkit-user-select: none;
    user-select: none;
  }

  :where(.divide-x-reverse > :not(:last-child)) {
    --tw-divide-x-reverse: 1;
  }

  .ring-inset {
    --tw-ring-inset: inset;
  }

  .not-last\\:not-first\\:rounded-none:not(:last-child):not(:first-child), .group-not-last\\:group-not-first\\:rounded-none:is(:where(.group):not(:last-child) *):is(:where(.group):not(:first-child) *) {
    border-radius: 0;
  }

  .group-not-only\\:group-first\\:rounded-e-none:is(:where(.group):not(:only-child) *):is(:where(.group):first-child *) {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  .group-not-only\\:group-first\\:rounded-b-none:is(:where(.group):not(:only-child) *):is(:where(.group):first-child *) {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }

  .group-not-only\\:group-last\\:rounded-s-none:is(:where(.group):not(:only-child) *):is(:where(.group):last-child *) {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  .group-not-only\\:group-last\\:rounded-t-none:is(:where(.group):not(:only-child) *):is(:where(.group):last-child *) {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }

  @media (hover: hover) {
    .group-hover\\:border-2:is(:where(.group):hover *) {
      border-style: var(--tw-border-style);
      border-width: 2px;
    }

    .group-hover\\:border-white:is(:where(.group):hover *) {
      border-color: var(--color-white, #fff);
    }

    .group-hover\\:text-default:is(:where(.group):hover *) {
      color: var(--ui-text);
    }

    .group-hover\\:text-primary:is(:where(.group):hover *) {
      color: var(--ui-primary);
    }
  }

  .group-data-expanded\\:rotate-180:is(:where(.group)[data-expanded] *) {
    rotate: 180deg;
  }

  .group-data-highlighted\\:inline-flex:is(:where(.group)[data-highlighted] *) {
    display: inline-flex;
  }

  .group-data-highlighted\\:text-default:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-text);
  }

  .group-data-highlighted\\:text-error:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-error);
  }

  .group-data-highlighted\\:text-info:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-info);
  }

  .group-data-highlighted\\:text-primary:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-primary);
  }

  .group-data-highlighted\\:text-secondary:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-secondary);
  }

  .group-data-highlighted\\:text-success:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-success);
  }

  .group-data-highlighted\\:text-warning:is(:where(.group)[data-highlighted] *) {
    color: var(--ui-warning);
  }

  .group-data-highlighted\\:not-group-data-disabled\\:text-default:is(:where(.group)[data-highlighted] *):not(:is(:where(.group)[data-disabled] *)) {
    color: var(--ui-text);
  }

  .group-data-\\[disabled\\]\\:opacity-75:is(:where(.group)[data-disabled] *) {
    opacity: .75;
  }

  .group-data-\\[state\\=active\\]\\:bg-error:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-error);
  }

  .group-data-\\[state\\=active\\]\\:bg-info:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-info);
  }

  .group-data-\\[state\\=active\\]\\:bg-inverted:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-bg-inverted);
  }

  .group-data-\\[state\\=active\\]\\:bg-primary:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-primary);
  }

  .group-data-\\[state\\=active\\]\\:bg-secondary:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-secondary);
  }

  .group-data-\\[state\\=active\\]\\:bg-success:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-success);
  }

  .group-data-\\[state\\=active\\]\\:bg-warning:is(:where(.group)[data-state="active"] *) {
    background-color: var(--ui-warning);
  }

  .group-data-\\[state\\=active\\]\\:text-inverted:is(:where(.group)[data-state="active"] *) {
    color: var(--ui-text-inverted);
  }

  .group-data-\\[state\\=checked\\]\\:text-error:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-error);
  }

  .group-data-\\[state\\=checked\\]\\:text-highlighted:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-text-highlighted);
  }

  .group-data-\\[state\\=checked\\]\\:text-info:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-info);
  }

  .group-data-\\[state\\=checked\\]\\:text-primary:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-primary);
  }

  .group-data-\\[state\\=checked\\]\\:text-secondary:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-secondary);
  }

  .group-data-\\[state\\=checked\\]\\:text-success:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-success);
  }

  .group-data-\\[state\\=checked\\]\\:text-warning:is(:where(.group)[data-state="checked"] *) {
    color: var(--ui-warning);
  }

  .group-data-\\[state\\=checked\\]\\:opacity-100:is(:where(.group)[data-state="checked"] *) {
    opacity: 1;
  }

  .group-data-\\[state\\=completed\\]\\:bg-error:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-error);
  }

  .group-data-\\[state\\=completed\\]\\:bg-info:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-info);
  }

  .group-data-\\[state\\=completed\\]\\:bg-inverted:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-bg-inverted);
  }

  .group-data-\\[state\\=completed\\]\\:bg-primary:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-primary);
  }

  .group-data-\\[state\\=completed\\]\\:bg-secondary:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-secondary);
  }

  .group-data-\\[state\\=completed\\]\\:bg-success:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-success);
  }

  .group-data-\\[state\\=completed\\]\\:bg-warning:is(:where(.group)[data-state="completed"] *) {
    background-color: var(--ui-warning);
  }

  .group-data-\\[state\\=completed\\]\\:text-inverted:is(:where(.group)[data-state="completed"] *) {
    color: var(--ui-text-inverted);
  }

  .group-data-\\[state\\=open\\]\\:rotate-180:is(:where(.group)[data-state="open"] *) {
    rotate: 180deg;
  }

  .group-data-\\[state\\=open\\]\\:text-default:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-text);
  }

  .group-data-\\[state\\=open\\]\\:text-error:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-error);
  }

  .group-data-\\[state\\=open\\]\\:text-highlighted:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-text-highlighted);
  }

  .group-data-\\[state\\=open\\]\\:text-info:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-info);
  }

  .group-data-\\[state\\=open\\]\\:text-primary:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-primary);
  }

  .group-data-\\[state\\=open\\]\\:text-secondary:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-secondary);
  }

  .group-data-\\[state\\=open\\]\\:text-success:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-success);
  }

  .group-data-\\[state\\=open\\]\\:text-warning:is(:where(.group)[data-state="open"] *) {
    color: var(--ui-warning);
  }

  .group-data-\\[state\\=unchecked\\]\\:text-dimmed:is(:where(.group)[data-state="unchecked"] *) {
    color: var(--ui-text-dimmed);
  }

  .group-data-\\[state\\=unchecked\\]\\:opacity-100:is(:where(.group)[data-state="unchecked"] *) {
    opacity: 1;
  }

  .file\\:me-1\\.5::file-selector-button {
    margin-inline-end: calc(var(--spacing, .25rem) * 1.5);
  }

  .file\\:font-medium::file-selector-button {
    --tw-font-weight: var(--font-weight-medium, 500);
    font-weight: var(--font-weight-medium, 500);
  }

  .file\\:text-muted::file-selector-button {
    color: var(--ui-text-muted);
  }

  .file\\:outline-none::file-selector-button {
    --tw-outline-style: none;
    outline-style: none;
  }

  .placeholder\\:text-dimmed::placeholder {
    color: var(--ui-text-dimmed);
  }

  .before\\:absolute:before {
    content: var(--tw-content);
    position: absolute;
  }

  .before\\:inset-px:before {
    content: var(--tw-content);
    inset: 1px;
  }

  .before\\:inset-x-0:before {
    content: var(--tw-content);
    inset-inline: calc(var(--spacing, .25rem) * 0);
  }

  .before\\:inset-x-px:before {
    content: var(--tw-content);
    inset-inline: 1px;
  }

  .before\\:inset-y-0:before {
    content: var(--tw-content);
    inset-block: calc(var(--spacing, .25rem) * 0);
  }

  .before\\:inset-y-px:before {
    content: var(--tw-content);
    inset-block: 1px;
  }

  .before\\:z-\\[-1\\]:before {
    content: var(--tw-content);
    z-index: -1;
  }

  .before\\:rounded-md:before {
    content: var(--tw-content);
    border-radius: var(--radius-md, .375rem);
  }

  .before\\:bg-elevated:before {
    content: var(--tw-content);
    background-color: var(--ui-bg-elevated);
  }

  .before\\:bg-error\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-error\\/10:before {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .before\\:bg-info\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-info\\/10:before {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .before\\:bg-primary\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-primary\\/10:before {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .before\\:bg-secondary\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-secondary\\/10:before {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .before\\:bg-success\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-success\\/10:before {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .before\\:bg-warning\\/10:before {
    content: var(--tw-content);
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .before\\:bg-warning\\/10:before {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .before\\:transition-colors:before {
    content: var(--tw-content);
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .not-first-of-type\\:before\\:me-0\\.5:not(:first-of-type):before {
    content: var(--tw-content);
    margin-inline-end: calc(var(--spacing, .25rem) * .5);
  }

  .not-first-of-type\\:before\\:content-\\[\\'\\'\\]:not(:first-of-type):before {
    content: var(--tw-content);
    --tw-content: "";
    content: var(--tw-content);
  }

  .after\\:absolute:after {
    content: var(--tw-content);
    position: absolute;
  }

  .after\\:inset-x-2\\.5:after {
    content: var(--tw-content);
    inset-inline: calc(var(--spacing, .25rem) * 2.5);
  }

  .after\\:inset-y-0\\.5:after {
    content: var(--tw-content);
    inset-block: calc(var(--spacing, .25rem) * .5);
  }

  .after\\:-start-1\\.5:after {
    content: var(--tw-content);
    inset-inline-start: calc(var(--spacing, .25rem) * -1.5);
  }

  .after\\:-bottom-2:after {
    content: var(--tw-content);
    bottom: calc(var(--spacing, .25rem) * -2);
  }

  .after\\:bottom-0:after {
    content: var(--tw-content);
    bottom: calc(var(--spacing, .25rem) * 0);
  }

  .after\\:left-1\\/2:after {
    content: var(--tw-content);
    left: 50%;
  }

  .after\\:z-\\[1\\]:after {
    content: var(--tw-content);
    z-index: 1;
  }

  .after\\:ms-0\\.5:after {
    content: var(--tw-content);
    margin-inline-start: calc(var(--spacing, .25rem) * .5);
  }

  .after\\:block:after {
    content: var(--tw-content);
    display: block;
  }

  .after\\:hidden:after {
    content: var(--tw-content);
    display: none;
  }

  .after\\:size-1:after {
    content: var(--tw-content);
    width: calc(var(--spacing, .25rem) * 1);
    height: calc(var(--spacing, .25rem) * 1);
  }

  .after\\:size-1\\.5:after {
    content: var(--tw-content);
    width: calc(var(--spacing, .25rem) * 1.5);
    height: calc(var(--spacing, .25rem) * 1.5);
  }

  .after\\:size-2:after {
    content: var(--tw-content);
    width: calc(var(--spacing, .25rem) * 2);
    height: calc(var(--spacing, .25rem) * 2);
  }

  .after\\:h-1:after {
    content: var(--tw-content);
    height: calc(var(--spacing, .25rem) * 1);
  }

  .after\\:h-px:after {
    content: var(--tw-content);
    height: 1px;
  }

  .after\\:w-\\[80\\%\\]:after {
    content: var(--tw-content);
    width: 80%;
  }

  .after\\:w-px:after {
    content: var(--tw-content);
    width: 1px;
  }

  .after\\:-translate-x-1\\/2:after {
    content: var(--tw-content);
    --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .after\\:animate-\\[carousel-inverse_2s_ease-in-out_infinite\\]:after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite carousel-inverse;
  }

  .after\\:animate-\\[carousel_2s_ease-in-out_infinite\\]:after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite carousel;
  }

  .after\\:animate-\\[elastic_2s_ease-in-out_infinite\\]:after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite elastic;
  }

  .after\\:animate-\\[swing_2s_ease-in-out_infinite\\]:after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite swing;
  }

  .after\\:rounded-full:after {
    content: var(--tw-content);
    border-radius: 3.40282e38px;
  }

  .after\\:bg-\\[var\\(--header-icon-color\\)\\]:after {
    content: var(--tw-content);
    background-color: var(--header-icon-color);
  }

  .after\\:bg-default:after {
    content: var(--tw-content);
    background-color: var(--ui-bg);
  }

  .after\\:bg-error:after {
    content: var(--tw-content);
    background-color: var(--ui-error);
  }

  .after\\:bg-info:after {
    content: var(--tw-content);
    background-color: var(--ui-info);
  }

  .after\\:bg-inverted:after {
    content: var(--tw-content);
    background-color: var(--ui-bg-inverted);
  }

  .after\\:bg-primary:after {
    content: var(--tw-content);
    background-color: var(--ui-primary);
  }

  .after\\:bg-secondary:after {
    content: var(--tw-content);
    background-color: var(--ui-secondary);
  }

  .after\\:bg-success:after {
    content: var(--tw-content);
    background-color: var(--ui-success);
  }

  .after\\:bg-warning:after {
    content: var(--tw-content);
    background-color: var(--ui-warning);
  }

  .after\\:text-error:after {
    content: var(--tw-content);
    color: var(--ui-error);
  }

  .after\\:transition-colors:after {
    content: var(--tw-content);
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  .after\\:content-\\[\\'\\'\\]:after {
    content: var(--tw-content);
    --tw-content: "";
    content: var(--tw-content);
  }

  .after\\:content-\\[\\'\\*\\'\\]:after {
    content: var(--tw-content);
    --tw-content: "*";
    content: var(--tw-content);
  }

  .first\\:me-0:first-child {
    margin-inline-end: calc(var(--spacing, .25rem) * 0);
  }

  .not-only\\:first\\:rounded-e-none:not(:only-child):first-child {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  .not-only\\:first\\:rounded-b-none:not(:only-child):first-child {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }

  .last\\:border-b-0:last-child {
    border-bottom-style: var(--tw-border-style);
    border-bottom-width: 0;
  }

  .not-only\\:last\\:rounded-s-none:not(:only-child):last-child {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  .not-only\\:last\\:rounded-t-none:not(:only-child):last-child {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }

  .first-of-type\\:rounded-s-lg:first-of-type {
    border-start-start-radius: var(--radius-lg, .5rem);
    border-end-start-radius: var(--radius-lg, .5rem);
  }

  .first-of-type\\:rounded-t-lg:first-of-type {
    border-top-left-radius: var(--radius-lg, .5rem);
    border-top-right-radius: var(--radius-lg, .5rem);
  }

  .last-of-type\\:rounded-e-lg:last-of-type {
    border-start-end-radius: var(--radius-lg, .5rem);
    border-end-end-radius: var(--radius-lg, .5rem);
  }

  .last-of-type\\:rounded-b-lg:last-of-type {
    border-bottom-right-radius: var(--radius-lg, .5rem);
    border-bottom-left-radius: var(--radius-lg, .5rem);
  }

  @media (hover: hover) {
    .hover\\:bg-\\[rgba\\(0\\,0\\,0\\,0\\.1\\)\\]:hover {
      background-color: #0000001a;
    }

    .hover\\:bg-accented\\/75:hover {
      background-color: var(--ui-bg-accented);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-accented\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-bg-accented) 75%, transparent);
      }
    }

    .hover\\:bg-blue-100:hover {
      background-color: var(--color-blue-100);
    }

    .hover\\:bg-elevated:hover, .hover\\:bg-elevated\\/25:hover {
      background-color: var(--ui-bg-elevated);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-elevated\\/25:hover {
        background-color: color-mix(in oklab, var(--ui-bg-elevated) 25%, transparent);
      }
    }

    .hover\\:bg-error\\/10:hover {
      background-color: var(--ui-error);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-error\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
      }
    }

    .hover\\:bg-error\\/15:hover {
      background-color: var(--ui-error);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-error\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-error) 15%, transparent);
      }
    }

    .hover\\:bg-error\\/75:hover {
      background-color: var(--ui-error);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-error\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-error) 75%, transparent);
      }
    }

    .hover\\:bg-gray-100:hover {
      background-color: var(--color-gray-100, oklch(96.7% .003 264.542));
    }

    .hover\\:bg-gray-500\\/10:hover {
      background-color: #6a72821a;
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-gray-500\\/10:hover {
        background-color: color-mix(in oklab, var(--color-gray-500, oklch(55.1% .027 264.364)) 10%, transparent);
      }
    }

    .hover\\:bg-info\\/10:hover {
      background-color: var(--ui-info);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-info\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
      }
    }

    .hover\\:bg-info\\/15:hover {
      background-color: var(--ui-info);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-info\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-info) 15%, transparent);
      }
    }

    .hover\\:bg-info\\/75:hover {
      background-color: var(--ui-info);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-info\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-info) 75%, transparent);
      }
    }

    .hover\\:bg-inverted\\/90:hover {
      background-color: var(--ui-bg-inverted);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-inverted\\/90:hover {
        background-color: color-mix(in oklab, var(--ui-bg-inverted) 90%, transparent);
      }
    }

    .hover\\:bg-primary\\/10:hover {
      background-color: var(--ui-primary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-primary\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
      }
    }

    .hover\\:bg-primary\\/15:hover {
      background-color: var(--ui-primary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-primary\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-primary) 15%, transparent);
      }
    }

    .hover\\:bg-primary\\/75:hover {
      background-color: var(--ui-primary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-primary\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-primary) 75%, transparent);
      }
    }

    .hover\\:bg-secondary\\/10:hover {
      background-color: var(--ui-secondary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-secondary\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
      }
    }

    .hover\\:bg-secondary\\/15:hover {
      background-color: var(--ui-secondary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-secondary\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-secondary) 15%, transparent);
      }
    }

    .hover\\:bg-secondary\\/75:hover {
      background-color: var(--ui-secondary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-secondary\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-secondary) 75%, transparent);
      }
    }

    .hover\\:bg-success\\/10:hover {
      background-color: var(--ui-success);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-success\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
      }
    }

    .hover\\:bg-success\\/15:hover {
      background-color: var(--ui-success);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-success\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-success) 15%, transparent);
      }
    }

    .hover\\:bg-success\\/75:hover {
      background-color: var(--ui-success);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-success\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-success) 75%, transparent);
      }
    }

    .hover\\:bg-warning\\/10:hover {
      background-color: var(--ui-warning);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-warning\\/10:hover {
        background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
      }
    }

    .hover\\:bg-warning\\/15:hover {
      background-color: var(--ui-warning);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-warning\\/15:hover {
        background-color: color-mix(in oklab, var(--ui-warning) 15%, transparent);
      }
    }

    .hover\\:bg-warning\\/75:hover {
      background-color: var(--ui-warning);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:bg-warning\\/75:hover {
        background-color: color-mix(in oklab, var(--ui-warning) 75%, transparent);
      }
    }

    .hover\\:text-default:hover {
      color: var(--ui-text);
    }

    .hover\\:text-error\\/75:hover {
      color: var(--ui-error);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-error\\/75:hover {
        color: color-mix(in oklab, var(--ui-error) 75%, transparent);
      }
    }

    .hover\\:text-gray-800:hover {
      color: var(--color-gray-800, oklch(27.8% .033 256.848));
    }

    .hover\\:text-highlighted:hover {
      color: var(--ui-text-highlighted);
    }

    .hover\\:text-info\\/75:hover {
      color: var(--ui-info);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-info\\/75:hover {
        color: color-mix(in oklab, var(--ui-info) 75%, transparent);
      }
    }

    .hover\\:text-primary:hover, .hover\\:text-primary\\/75:hover {
      color: var(--ui-primary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-primary\\/75:hover {
        color: color-mix(in oklab, var(--ui-primary) 75%, transparent);
      }
    }

    .hover\\:text-secondary\\/75:hover {
      color: var(--ui-secondary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-secondary\\/75:hover {
        color: color-mix(in oklab, var(--ui-secondary) 75%, transparent);
      }
    }

    .hover\\:text-success\\/75:hover {
      color: var(--ui-success);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-success\\/75:hover {
        color: color-mix(in oklab, var(--ui-success) 75%, transparent);
      }
    }

    .hover\\:text-warning\\/75:hover {
      color: var(--ui-warning);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:text-warning\\/75:hover {
        color: color-mix(in oklab, var(--ui-warning) 75%, transparent);
      }
    }

    .hover\\:not-disabled\\:text-highlighted:hover:not(:disabled) {
      color: var(--ui-text-highlighted);
    }

    .hover\\:not-data-\\[selected\\]\\:bg-error\\/20:hover:not([data-selected]) {
      background-color: var(--ui-error);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-error\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-error) 20%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-info\\/20:hover:not([data-selected]) {
      background-color: var(--ui-info);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-info\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-info) 20%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-inverted\\/10:hover:not([data-selected]) {
      background-color: var(--ui-bg-inverted);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-inverted\\/10:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-bg-inverted) 10%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-primary\\/20:hover:not([data-selected]) {
      background-color: var(--ui-primary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-primary\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-primary) 20%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-secondary\\/20:hover:not([data-selected]) {
      background-color: var(--ui-secondary);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-secondary\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-secondary) 20%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-success\\/20:hover:not([data-selected]) {
      background-color: var(--ui-success);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-success\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-success) 20%, transparent);
      }
    }

    .hover\\:not-data-\\[selected\\]\\:bg-warning\\/20:hover:not([data-selected]) {
      background-color: var(--ui-warning);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-data-\\[selected\\]\\:bg-warning\\/20:hover:not([data-selected]) {
        background-color: color-mix(in oklab, var(--ui-warning) 20%, transparent);
      }
    }

    .hover\\:before\\:bg-elevated\\/50:hover:before {
      content: var(--tw-content);
      background-color: var(--ui-bg-elevated);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:before\\:bg-elevated\\/50:hover:before {
        background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
      }
    }

    .hover\\:not-disabled\\:before\\:bg-elevated\\/50:hover:not(:disabled):before {
      content: var(--tw-content);
      background-color: var(--ui-bg-elevated);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .hover\\:not-disabled\\:before\\:bg-elevated\\/50:hover:not(:disabled):before {
        background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
      }
    }
  }

  .focus\\:bg-elevated:focus {
    background-color: var(--ui-bg-elevated);
  }

  .focus\\:outline-none:focus {
    --tw-outline-style: none;
    outline-style: none;
  }

  .focus-visible\\:z-\\[1\\]:focus-visible {
    z-index: 1;
  }

  .focus-visible\\:bg-accented\\/75:focus-visible {
    background-color: var(--ui-bg-accented);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-accented\\/75:focus-visible {
      background-color: color-mix(in oklab, var(--ui-bg-accented) 75%, transparent);
    }
  }

  .focus-visible\\:bg-elevated:focus-visible {
    background-color: var(--ui-bg-elevated);
  }

  .focus-visible\\:bg-error\\/10:focus-visible {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-error\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .focus-visible\\:bg-error\\/15:focus-visible {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-error\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-error) 15%, transparent);
    }
  }

  .focus-visible\\:bg-info\\/10:focus-visible {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-info\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .focus-visible\\:bg-info\\/15:focus-visible {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-info\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-info) 15%, transparent);
    }
  }

  .focus-visible\\:bg-primary\\/10:focus-visible {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-primary\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .focus-visible\\:bg-primary\\/15:focus-visible {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-primary\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-primary) 15%, transparent);
    }
  }

  .focus-visible\\:bg-secondary\\/10:focus-visible {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-secondary\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .focus-visible\\:bg-secondary\\/15:focus-visible {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-secondary\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-secondary) 15%, transparent);
    }
  }

  .focus-visible\\:bg-success\\/10:focus-visible {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-success\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .focus-visible\\:bg-success\\/15:focus-visible {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-success\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-success) 15%, transparent);
    }
  }

  .focus-visible\\:bg-warning\\/10:focus-visible {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-warning\\/10:focus-visible {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .focus-visible\\:bg-warning\\/15:focus-visible {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:bg-warning\\/15:focus-visible {
      background-color: color-mix(in oklab, var(--ui-warning) 15%, transparent);
    }
  }

  .focus-visible\\:ring-2:focus-visible {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .focus-visible\\:ring-error:focus-visible {
    --tw-ring-color: var(--ui-error);
  }

  .focus-visible\\:ring-info:focus-visible {
    --tw-ring-color: var(--ui-info);
  }

  .focus-visible\\:ring-inverted:focus-visible {
    --tw-ring-color: var(--ui-border-inverted);
  }

  .focus-visible\\:ring-primary:focus-visible {
    --tw-ring-color: var(--ui-primary);
  }

  .focus-visible\\:ring-secondary:focus-visible {
    --tw-ring-color: var(--ui-secondary);
  }

  .focus-visible\\:ring-success:focus-visible {
    --tw-ring-color: var(--ui-success);
  }

  .focus-visible\\:ring-warning:focus-visible {
    --tw-ring-color: var(--ui-warning);
  }

  .focus-visible\\:ring-offset-2:focus-visible {
    --tw-ring-offset-width: 2px;
    --tw-ring-offset-shadow: var(--tw-ring-inset, ) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  }

  .focus-visible\\:outline-2:focus-visible {
    outline-style: var(--tw-outline-style);
    outline-width: 2px;
  }

  .focus-visible\\:outline-offset-2:focus-visible {
    outline-offset: 2px;
  }

  .focus-visible\\:outline-error:focus-visible, .focus-visible\\:outline-error\\/50:focus-visible {
    outline-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-error\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-error) 50%, transparent);
    }
  }

  .focus-visible\\:outline-info:focus-visible, .focus-visible\\:outline-info\\/50:focus-visible {
    outline-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-info\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-info) 50%, transparent);
    }
  }

  .focus-visible\\:outline-inverted:focus-visible, .focus-visible\\:outline-inverted\\/50:focus-visible {
    outline-color: var(--ui-border-inverted);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-inverted\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-border-inverted) 50%, transparent);
    }
  }

  .focus-visible\\:outline-primary:focus-visible, .focus-visible\\:outline-primary\\/50:focus-visible {
    outline-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-primary\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-primary) 50%, transparent);
    }
  }

  .focus-visible\\:outline-secondary:focus-visible, .focus-visible\\:outline-secondary\\/50:focus-visible {
    outline-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-secondary\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-secondary) 50%, transparent);
    }
  }

  .focus-visible\\:outline-success:focus-visible, .focus-visible\\:outline-success\\/50:focus-visible {
    outline-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-success\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-success) 50%, transparent);
    }
  }

  .focus-visible\\:outline-warning:focus-visible, .focus-visible\\:outline-warning\\/50:focus-visible {
    outline-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .focus-visible\\:outline-warning\\/50:focus-visible {
      outline-color: color-mix(in oklab, var(--ui-warning) 50%, transparent);
    }
  }

  .focus-visible\\:outline-none:focus-visible {
    --tw-outline-style: none;
    outline-style: none;
  }

  .focus-visible\\:ring-inset:focus-visible {
    --tw-ring-inset: inset;
  }

  .focus-visible\\:before\\:ring-2:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .focus-visible\\:before\\:ring-error:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-error);
  }

  .focus-visible\\:before\\:ring-info:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-info);
  }

  .focus-visible\\:before\\:ring-inverted:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-border-inverted);
  }

  .focus-visible\\:before\\:ring-primary:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-primary);
  }

  .focus-visible\\:before\\:ring-secondary:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-secondary);
  }

  .focus-visible\\:before\\:ring-success:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-success);
  }

  .focus-visible\\:before\\:ring-warning:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-color: var(--ui-warning);
  }

  .focus-visible\\:before\\:ring-inset:focus-visible:before {
    content: var(--tw-content);
    --tw-ring-inset: inset;
  }

  .active\\:bg-accented\\/75:active {
    background-color: var(--ui-bg-accented);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-accented\\/75:active {
      background-color: color-mix(in oklab, var(--ui-bg-accented) 75%, transparent);
    }
  }

  .active\\:bg-elevated:active {
    background-color: var(--ui-bg-elevated);
  }

  .active\\:bg-error\\/10:active {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-error\\/10:active {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .active\\:bg-error\\/15:active {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-error\\/15:active {
      background-color: color-mix(in oklab, var(--ui-error) 15%, transparent);
    }
  }

  .active\\:bg-error\\/75:active {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-error\\/75:active {
      background-color: color-mix(in oklab, var(--ui-error) 75%, transparent);
    }
  }

  .active\\:bg-info\\/10:active {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-info\\/10:active {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .active\\:bg-info\\/15:active {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-info\\/15:active {
      background-color: color-mix(in oklab, var(--ui-info) 15%, transparent);
    }
  }

  .active\\:bg-info\\/75:active {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-info\\/75:active {
      background-color: color-mix(in oklab, var(--ui-info) 75%, transparent);
    }
  }

  .active\\:bg-inverted\\/90:active {
    background-color: var(--ui-bg-inverted);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-inverted\\/90:active {
      background-color: color-mix(in oklab, var(--ui-bg-inverted) 90%, transparent);
    }
  }

  .active\\:bg-primary\\/10:active {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-primary\\/10:active {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .active\\:bg-primary\\/15:active {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-primary\\/15:active {
      background-color: color-mix(in oklab, var(--ui-primary) 15%, transparent);
    }
  }

  .active\\:bg-primary\\/75:active {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-primary\\/75:active {
      background-color: color-mix(in oklab, var(--ui-primary) 75%, transparent);
    }
  }

  .active\\:bg-secondary\\/10:active {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-secondary\\/10:active {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .active\\:bg-secondary\\/15:active {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-secondary\\/15:active {
      background-color: color-mix(in oklab, var(--ui-secondary) 15%, transparent);
    }
  }

  .active\\:bg-secondary\\/75:active {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-secondary\\/75:active {
      background-color: color-mix(in oklab, var(--ui-secondary) 75%, transparent);
    }
  }

  .active\\:bg-success\\/10:active {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-success\\/10:active {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .active\\:bg-success\\/15:active {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-success\\/15:active {
      background-color: color-mix(in oklab, var(--ui-success) 15%, transparent);
    }
  }

  .active\\:bg-success\\/75:active {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-success\\/75:active {
      background-color: color-mix(in oklab, var(--ui-success) 75%, transparent);
    }
  }

  .active\\:bg-warning\\/10:active {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-warning\\/10:active {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .active\\:bg-warning\\/15:active {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-warning\\/15:active {
      background-color: color-mix(in oklab, var(--ui-warning) 15%, transparent);
    }
  }

  .active\\:bg-warning\\/75:active {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:bg-warning\\/75:active {
      background-color: color-mix(in oklab, var(--ui-warning) 75%, transparent);
    }
  }

  .active\\:text-default:active {
    color: var(--ui-text);
  }

  .active\\:text-error\\/75:active {
    color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-error\\/75:active {
      color: color-mix(in oklab, var(--ui-error) 75%, transparent);
    }
  }

  .active\\:text-info\\/75:active {
    color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-info\\/75:active {
      color: color-mix(in oklab, var(--ui-info) 75%, transparent);
    }
  }

  .active\\:text-primary\\/75:active {
    color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-primary\\/75:active {
      color: color-mix(in oklab, var(--ui-primary) 75%, transparent);
    }
  }

  .active\\:text-secondary\\/75:active {
    color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-secondary\\/75:active {
      color: color-mix(in oklab, var(--ui-secondary) 75%, transparent);
    }
  }

  .active\\:text-success\\/75:active {
    color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-success\\/75:active {
      color: color-mix(in oklab, var(--ui-success) 75%, transparent);
    }
  }

  .active\\:text-warning\\/75:active {
    color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .active\\:text-warning\\/75:active {
      color: color-mix(in oklab, var(--ui-warning) 75%, transparent);
    }
  }

  .disabled\\:pointer-events-none:disabled {
    pointer-events: none;
  }

  .disabled\\:cursor-not-allowed:disabled {
    cursor: not-allowed;
  }

  .disabled\\:bg-default:disabled {
    background-color: var(--ui-bg);
  }

  .disabled\\:bg-elevated:disabled, .disabled\\:bg-elevated\\/50:disabled {
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-elevated\\/50:disabled {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .disabled\\:bg-error:disabled, .disabled\\:bg-error\\/10:disabled {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-error\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .disabled\\:bg-info:disabled, .disabled\\:bg-info\\/10:disabled {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-info\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .disabled\\:bg-inverted:disabled {
    background-color: var(--ui-bg-inverted);
  }

  .disabled\\:bg-primary:disabled, .disabled\\:bg-primary\\/10:disabled {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-primary\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .disabled\\:bg-secondary:disabled, .disabled\\:bg-secondary\\/10:disabled {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-secondary\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .disabled\\:bg-success:disabled, .disabled\\:bg-success\\/10:disabled {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-success\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .disabled\\:bg-transparent:disabled {
    background-color: #0000;
  }

  .disabled\\:bg-warning:disabled, .disabled\\:bg-warning\\/10:disabled {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .disabled\\:bg-warning\\/10:disabled {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .disabled\\:text-error:disabled {
    color: var(--ui-error);
  }

  .disabled\\:text-info:disabled {
    color: var(--ui-info);
  }

  .disabled\\:text-muted:disabled {
    color: var(--ui-text-muted);
  }

  .disabled\\:text-primary:disabled {
    color: var(--ui-primary);
  }

  .disabled\\:text-secondary:disabled {
    color: var(--ui-secondary);
  }

  .disabled\\:text-success:disabled {
    color: var(--ui-success);
  }

  .disabled\\:text-warning:disabled {
    color: var(--ui-warning);
  }

  .disabled\\:opacity-50:disabled {
    opacity: .5;
  }

  .disabled\\:opacity-75:disabled {
    opacity: .75;
  }

  @media (hover: hover) {
    .hover\\:disabled\\:bg-transparent:hover:disabled {
      background-color: #0000;
    }
  }

  .has-focus\\:bg-elevated:has(:focus) {
    background-color: var(--ui-bg-elevated);
  }

  .has-focus-visible\\:z-\\[1\\]:has(:focus-visible) {
    z-index: 1;
  }

  .has-focus-visible\\:ring-2:has(:focus-visible) {
    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }

  .has-focus-visible\\:ring-error:has(:focus-visible) {
    --tw-ring-color: var(--ui-error);
  }

  .has-focus-visible\\:ring-info:has(:focus-visible) {
    --tw-ring-color: var(--ui-info);
  }

  .has-focus-visible\\:ring-inverted:has(:focus-visible) {
    --tw-ring-color: var(--ui-border-inverted);
  }

  .has-focus-visible\\:ring-primary:has(:focus-visible) {
    --tw-ring-color: var(--ui-primary);
  }

  .has-focus-visible\\:ring-secondary:has(:focus-visible) {
    --tw-ring-color: var(--ui-secondary);
  }

  .has-focus-visible\\:ring-success:has(:focus-visible) {
    --tw-ring-color: var(--ui-success);
  }

  .has-focus-visible\\:ring-warning:has(:focus-visible) {
    --tw-ring-color: var(--ui-warning);
  }

  .has-focus-visible\\:ring-inset:has(:focus-visible) {
    --tw-ring-inset: inset;
  }

  .has-data-\\[state\\=checked\\]\\:z-\\[1\\]:has([data-state="checked"]) {
    z-index: 1;
  }

  .has-data-\\[state\\=checked\\]\\:border-error:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-error\\/50:has([data-state="checked"]) {
    border-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-error\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-error) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-info:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-info\\/50:has([data-state="checked"]) {
    border-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-info\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-info) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-inverted:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-inverted\\/50:has([data-state="checked"]) {
    border-color: var(--ui-border-inverted);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-inverted\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-border-inverted) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-primary:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-primary\\/50:has([data-state="checked"]) {
    border-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-primary\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-primary) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-secondary:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-secondary\\/50:has([data-state="checked"]) {
    border-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-secondary\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-secondary) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-success:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-success\\/50:has([data-state="checked"]) {
    border-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-success\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-success) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:border-warning:has([data-state="checked"]), .has-data-\\[state\\=checked\\]\\:border-warning\\/50:has([data-state="checked"]) {
    border-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:border-warning\\/50:has([data-state="checked"]) {
      border-color: color-mix(in oklab, var(--ui-warning) 50%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-elevated:has([data-state="checked"]) {
    background-color: var(--ui-bg-elevated);
  }

  .has-data-\\[state\\=checked\\]\\:bg-error\\/10:has([data-state="checked"]) {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-error\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-info\\/10:has([data-state="checked"]) {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-info\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-primary\\/10:has([data-state="checked"]) {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-primary\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-secondary\\/10:has([data-state="checked"]) {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-secondary\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-success\\/10:has([data-state="checked"]) {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-success\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .has-data-\\[state\\=checked\\]\\:bg-warning\\/10:has([data-state="checked"]) {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .has-data-\\[state\\=checked\\]\\:bg-warning\\/10:has([data-state="checked"]) {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .aria-disabled\\:cursor-not-allowed[aria-disabled="true"] {
    cursor: not-allowed;
  }

  .aria-disabled\\:bg-default[aria-disabled="true"] {
    background-color: var(--ui-bg);
  }

  .aria-disabled\\:bg-elevated[aria-disabled="true"] {
    background-color: var(--ui-bg-elevated);
  }

  .aria-disabled\\:bg-error[aria-disabled="true"], .aria-disabled\\:bg-error\\/10[aria-disabled="true"] {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-error\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .aria-disabled\\:bg-info[aria-disabled="true"], .aria-disabled\\:bg-info\\/10[aria-disabled="true"] {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-info\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .aria-disabled\\:bg-inverted[aria-disabled="true"] {
    background-color: var(--ui-bg-inverted);
  }

  .aria-disabled\\:bg-primary[aria-disabled="true"], .aria-disabled\\:bg-primary\\/10[aria-disabled="true"] {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-primary\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .aria-disabled\\:bg-secondary[aria-disabled="true"], .aria-disabled\\:bg-secondary\\/10[aria-disabled="true"] {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-secondary\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .aria-disabled\\:bg-success[aria-disabled="true"], .aria-disabled\\:bg-success\\/10[aria-disabled="true"] {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-success\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .aria-disabled\\:bg-transparent[aria-disabled="true"] {
    background-color: #0000;
  }

  .aria-disabled\\:bg-warning[aria-disabled="true"], .aria-disabled\\:bg-warning\\/10[aria-disabled="true"] {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .aria-disabled\\:bg-warning\\/10[aria-disabled="true"] {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .aria-disabled\\:text-error[aria-disabled="true"] {
    color: var(--ui-error);
  }

  .aria-disabled\\:text-info[aria-disabled="true"] {
    color: var(--ui-info);
  }

  .aria-disabled\\:text-muted[aria-disabled="true"] {
    color: var(--ui-text-muted);
  }

  .aria-disabled\\:text-primary[aria-disabled="true"] {
    color: var(--ui-primary);
  }

  .aria-disabled\\:text-secondary[aria-disabled="true"] {
    color: var(--ui-secondary);
  }

  .aria-disabled\\:text-success[aria-disabled="true"] {
    color: var(--ui-success);
  }

  .aria-disabled\\:text-warning[aria-disabled="true"] {
    color: var(--ui-warning);
  }

  .aria-disabled\\:opacity-75[aria-disabled="true"] {
    opacity: .75;
  }

  @media (hover: hover) {
    .hover\\:aria-disabled\\:bg-transparent:hover[aria-disabled="true"] {
      background-color: #0000;
    }
  }

  .data-disabled\\:cursor-not-allowed[data-disabled] {
    cursor: not-allowed;
  }

  .data-disabled\\:text-muted[data-disabled] {
    color: var(--ui-text-muted);
  }

  .data-disabled\\:opacity-75[data-disabled] {
    opacity: .75;
  }

  .data-highlighted\\:text-error[data-highlighted] {
    color: var(--ui-error);
  }

  .data-highlighted\\:text-highlighted[data-highlighted] {
    color: var(--ui-text-highlighted);
  }

  .data-highlighted\\:text-info[data-highlighted] {
    color: var(--ui-info);
  }

  .data-highlighted\\:text-primary[data-highlighted] {
    color: var(--ui-primary);
  }

  .data-highlighted\\:text-secondary[data-highlighted] {
    color: var(--ui-secondary);
  }

  .data-highlighted\\:text-success[data-highlighted] {
    color: var(--ui-success);
  }

  .data-highlighted\\:text-warning[data-highlighted] {
    color: var(--ui-warning);
  }

  .data-highlighted\\:not-data-disabled\\:text-highlighted[data-highlighted]:not([data-disabled]) {
    color: var(--ui-text-highlighted);
  }

  .data-highlighted\\:before\\:bg-elevated\\/50[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-elevated\\/50[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-error\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-error\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-info\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-info\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-primary\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-primary\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-secondary\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-secondary\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-success\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-success\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .data-highlighted\\:before\\:bg-warning\\/10[data-highlighted]:before {
    content: var(--tw-content);
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:before\\:bg-warning\\/10[data-highlighted]:before {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .data-highlighted\\:not-data-disabled\\:before\\:bg-elevated\\/50[data-highlighted]:not([data-disabled]):before {
    content: var(--tw-content);
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-highlighted\\:not-data-disabled\\:before\\:bg-elevated\\/50[data-highlighted]:not([data-disabled]):before {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .data-today\\:font-semibold[data-today] {
    --tw-font-weight: var(--font-weight-semibold, 600);
    font-weight: var(--font-weight-semibold, 600);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-error[data-today]:not([data-selected]) {
    color: var(--ui-error);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-highlighted[data-today]:not([data-selected]) {
    color: var(--ui-text-highlighted);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-info[data-today]:not([data-selected]) {
    color: var(--ui-info);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-primary[data-today]:not([data-selected]) {
    color: var(--ui-primary);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-secondary[data-today]:not([data-selected]) {
    color: var(--ui-secondary);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-success[data-today]:not([data-selected]) {
    color: var(--ui-success);
  }

  .data-today\\:not-data-\\[selected\\]\\:text-warning[data-today]:not([data-selected]) {
    color: var(--ui-warning);
  }

  .data-unavailable\\:pointer-events-none[data-unavailable] {
    pointer-events: none;
  }

  .data-unavailable\\:text-muted[data-unavailable] {
    color: var(--ui-text-muted);
  }

  .data-unavailable\\:line-through[data-unavailable] {
    text-decoration-line: line-through;
  }

  .data-\\[disabled\\]\\:cursor-not-allowed[data-disabled] {
    cursor: not-allowed;
  }

  .data-\\[disabled\\]\\:opacity-75[data-disabled] {
    opacity: .75;
  }

  .data-\\[dragging\\=true\\]\\:bg-elevated\\/25[data-dragging="true"] {
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[dragging\\=true\\]\\:bg-elevated\\/25[data-dragging="true"] {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 25%, transparent);
    }
  }

  .data-\\[expanded\\=true\\]\\:h-\\(--height\\)[data-expanded="true"] {
    height: var(--height);
  }

  :is(.data-\\[front\\=false\\]\\:\\*\\:transition-opacity[data-front="false"] > *) {
    transition-property: opacity;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function, cubic-bezier(.4, 0, .2, 1)));
    transition-duration: var(--tw-duration, var(--default-transition-duration, .15s));
  }

  :is(.data-\\[front\\=false\\]\\:\\*\\:duration-100[data-front="false"] > *) {
    --tw-duration: .1s;
    transition-duration: .1s;
  }

  .data-\\[expanded\\=false\\]\\:data-\\[front\\=false\\]\\:h-\\(--front-height\\)[data-expanded="false"][data-front="false"] {
    height: var(--front-height);
  }

  :is(.data-\\[expanded\\=false\\]\\:data-\\[front\\=false\\]\\:\\*\\:opacity-0[data-expanded="false"][data-front="false"] > *) {
    opacity: 0;
  }

  .data-\\[highlighted\\]\\:bg-error\\/20[data-highlighted] {
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-error\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-error) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-info\\/20[data-highlighted] {
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-info\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-info) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-inverted\\/20[data-highlighted] {
    background-color: var(--ui-bg-inverted);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-inverted\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-bg-inverted) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-primary\\/20[data-highlighted] {
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-primary\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-primary) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-secondary\\/20[data-highlighted] {
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-secondary\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-secondary) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-success\\/20[data-highlighted] {
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-success\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-success) 20%, transparent);
    }
  }

  .data-\\[highlighted\\]\\:bg-warning\\/20[data-highlighted] {
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[highlighted\\]\\:bg-warning\\/20[data-highlighted] {
      background-color: color-mix(in oklab, var(--ui-warning) 20%, transparent);
    }
  }

  .data-\\[motion\\=from-end\\]\\:animate-\\[enter-from-right_200ms_ease\\][data-motion="from-end"] {
    animation: .2s enter-from-right;
  }

  .data-\\[motion\\=from-start\\]\\:animate-\\[enter-from-left_200ms_ease\\][data-motion="from-start"] {
    animation: .2s enter-from-left;
  }

  .data-\\[motion\\=to-end\\]\\:animate-\\[exit-to-right_200ms_ease\\][data-motion="to-end"] {
    animation: .2s exit-to-right;
  }

  .data-\\[motion\\=to-start\\]\\:animate-\\[exit-to-left_200ms_ease\\][data-motion="to-start"] {
    animation: .2s exit-to-left;
  }

  .data-\\[outside-view\\]\\:text-muted[data-outside-view] {
    color: var(--ui-text-muted);
  }

  .data-\\[pinned\\=left\\]\\:left-0[data-pinned="left"] {
    left: calc(var(--spacing, .25rem) * 0);
  }

  .data-\\[pinned\\=right\\]\\:right-0[data-pinned="right"] {
    right: calc(var(--spacing, .25rem) * 0);
  }

  .data-\\[selected\\]\\:bg-error[data-selected] {
    background-color: var(--ui-error);
  }

  .data-\\[selected\\]\\:bg-info[data-selected] {
    background-color: var(--ui-info);
  }

  .data-\\[selected\\]\\:bg-inverted[data-selected] {
    background-color: var(--ui-bg-inverted);
  }

  .data-\\[selected\\]\\:bg-primary[data-selected] {
    background-color: var(--ui-primary);
  }

  .data-\\[selected\\]\\:bg-secondary[data-selected] {
    background-color: var(--ui-secondary);
  }

  .data-\\[selected\\]\\:bg-success[data-selected] {
    background-color: var(--ui-success);
  }

  .data-\\[selected\\]\\:bg-warning[data-selected] {
    background-color: var(--ui-warning);
  }

  .data-\\[selected\\]\\:text-inverted[data-selected] {
    color: var(--ui-text-inverted);
  }

  .data-\\[selected\\=true\\]\\:bg-elevated\\/50[data-selected="true"] {
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[selected\\=true\\]\\:bg-elevated\\/50[data-selected="true"] {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .data-\\[state\\=\\\\\\"active\\\\\\"\\]\\:bg-accented[data-state="\\"active\\""] {
    background-color: var(--ui-bg-accented);
  }

  .data-\\[state\\=active\\]\\:bg-inverted[data-state="active"] {
    background-color: var(--ui-bg-inverted);
  }

  .data-\\[state\\=active\\]\\:bg-white[data-state="active"] {
    background-color: var(--color-white, #fff);
  }

  .data-\\[state\\=active\\]\\:text-error[data-state="active"] {
    color: var(--ui-error);
  }

  .data-\\[state\\=active\\]\\:text-gray-900[data-state="active"] {
    color: var(--color-gray-900, oklch(21% .034 264.665));
  }

  .data-\\[state\\=active\\]\\:text-highlighted[data-state="active"] {
    color: var(--ui-text-highlighted);
  }

  .data-\\[state\\=active\\]\\:text-info[data-state="active"] {
    color: var(--ui-info);
  }

  .data-\\[state\\=active\\]\\:text-inverted[data-state="active"] {
    color: var(--ui-text-inverted);
  }

  .data-\\[state\\=active\\]\\:text-primary[data-state="active"] {
    color: var(--ui-primary);
  }

  .data-\\[state\\=active\\]\\:text-secondary[data-state="active"] {
    color: var(--ui-secondary);
  }

  .data-\\[state\\=active\\]\\:text-success[data-state="active"] {
    color: var(--ui-success);
  }

  .data-\\[state\\=active\\]\\:text-warning[data-state="active"] {
    color: var(--ui-warning);
  }

  .data-\\[state\\=checked\\]\\:translate-x-3[data-state="checked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 3);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:translate-x-3\\.5[data-state="checked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 3.5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:translate-x-4[data-state="checked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 4);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:translate-x-4\\.5[data-state="checked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 4.5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:translate-x-5[data-state="checked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:bg-error[data-state="checked"] {
    background-color: var(--ui-error);
  }

  .data-\\[state\\=checked\\]\\:bg-info[data-state="checked"] {
    background-color: var(--ui-info);
  }

  .data-\\[state\\=checked\\]\\:bg-inverted[data-state="checked"] {
    background-color: var(--ui-bg-inverted);
  }

  .data-\\[state\\=checked\\]\\:bg-primary[data-state="checked"] {
    background-color: var(--ui-primary);
  }

  .data-\\[state\\=checked\\]\\:bg-secondary[data-state="checked"] {
    background-color: var(--ui-secondary);
  }

  .data-\\[state\\=checked\\]\\:bg-success[data-state="checked"] {
    background-color: var(--ui-success);
  }

  .data-\\[state\\=checked\\]\\:bg-warning[data-state="checked"] {
    background-color: var(--ui-warning);
  }

  .data-\\[state\\=closed\\]\\:animate-\\[accordion-up_200ms_ease-out\\][data-state="closed"] {
    animation: .2s ease-out accordion-up;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[collapsible-up_200ms_ease-out\\][data-state="closed"] {
    animation: .2s ease-out collapsible-up;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[fade-out_200ms_ease-in\\][data-state="closed"] {
    animation: .2s ease-in fade-out;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[scale-out_100ms_ease-in\\][data-state="closed"] {
    animation: .1s ease-in scale-out;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[scale-out_200ms_ease-in\\][data-state="closed"] {
    animation: .2s ease-in scale-out;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[slide-out-to-bottom_200ms_ease-in-out\\][data-state="closed"] {
    animation: .2s ease-in-out slide-out-to-bottom;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[slide-out-to-left_200ms_ease-in-out\\][data-state="closed"] {
    animation: .2s ease-in-out slide-out-to-left;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[slide-out-to-right_200ms_ease-in-out\\][data-state="closed"] {
    animation: .2s ease-in-out slide-out-to-right;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[slide-out-to-top_200ms_ease-in-out\\][data-state="closed"] {
    animation: .2s ease-in-out slide-out-to-top;
  }

  .data-\\[state\\=closed\\]\\:animate-\\[toast-closed_200ms_ease-in-out\\][data-state="closed"] {
    animation: .2s ease-in-out toast-closed;
  }

  .data-\\[state\\=closed\\]\\:data-\\[expanded\\=false\\]\\:data-\\[front\\=false\\]\\:animate-\\[toast-collapsed-closed_200ms_ease-in-out\\][data-state="closed"][data-expanded="false"][data-front="false"] {
    animation: .2s ease-in-out toast-collapsed-closed;
  }

  .data-\\[state\\=delayed-open\\]\\:animate-\\[scale-in_100ms_ease-out\\][data-state="delayed-open"] {
    animation: .1s ease-out scale-in;
  }

  .data-\\[state\\=hidden\\]\\:animate-\\[fade-out_100ms_ease-in\\][data-state="hidden"] {
    animation: .1s ease-in fade-out;
  }

  .data-\\[state\\=hidden\\]\\:opacity-0[data-state="hidden"] {
    opacity: 0;
  }

  .data-\\[state\\=inactive\\]\\:text-muted[data-state="inactive"] {
    color: var(--ui-text-muted);
  }

  @media (hover: hover) {
    .hover\\:data-\\[state\\=inactive\\]\\:not-disabled\\:text-default:hover[data-state="inactive"]:not(:disabled) {
      color: var(--ui-text);
    }
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[carousel-inverse-vertical_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite carousel-inverse-vertical;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[carousel-inverse_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite carousel-inverse;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[carousel-vertical_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite carousel-vertical;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[carousel_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite carousel;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[elastic-vertical_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite elastic-vertical;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[elastic_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite elastic;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[swing-vertical_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite swing-vertical;
  }

  .data-\\[state\\=indeterminate\\]\\:animate-\\[swing_2s_ease-in-out_infinite\\][data-state="indeterminate"] {
    animation: 2s ease-in-out infinite swing;
  }

  .data-\\[state\\=open\\]\\:animate-\\[accordion-down_200ms_ease-out\\][data-state="open"] {
    animation: .2s ease-out accordion-down;
  }

  .data-\\[state\\=open\\]\\:animate-\\[collapsible-down_200ms_ease-out\\][data-state="open"] {
    animation: .2s ease-out collapsible-down;
  }

  .data-\\[state\\=open\\]\\:animate-\\[fade-in_200ms_ease-out\\][data-state="open"] {
    animation: .2s ease-out fade-in;
  }

  .data-\\[state\\=open\\]\\:animate-\\[scale-in_100ms_ease-out\\][data-state="open"] {
    animation: .1s ease-out scale-in;
  }

  .data-\\[state\\=open\\]\\:animate-\\[scale-in_200ms_ease-out\\][data-state="open"] {
    animation: .2s ease-out scale-in;
  }

  .data-\\[state\\=open\\]\\:animate-\\[slide-in-from-bottom_200ms_ease-in-out\\][data-state="open"] {
    animation: .2s ease-in-out slide-in-from-bottom;
  }

  .data-\\[state\\=open\\]\\:animate-\\[slide-in-from-left_200ms_ease-in-out\\][data-state="open"] {
    animation: .2s ease-in-out slide-in-from-left;
  }

  .data-\\[state\\=open\\]\\:animate-\\[slide-in-from-right_200ms_ease-in-out\\][data-state="open"] {
    animation: .2s ease-in-out slide-in-from-right;
  }

  .data-\\[state\\=open\\]\\:animate-\\[slide-in-from-top_200ms_ease-in-out\\][data-state="open"] {
    animation: .2s ease-in-out slide-in-from-top;
  }

  .data-\\[state\\=open\\]\\:text-highlighted[data-state="open"] {
    color: var(--ui-text-highlighted);
  }

  .data-\\[state\\=open\\]\\:before\\:bg-elevated\\/50[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-bg-elevated);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-elevated\\/50[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-error\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-error);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-error\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-error) 10%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-info\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-info);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-info\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-info) 10%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-primary\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-primary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-primary\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-primary) 10%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-secondary\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-secondary);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-secondary\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-secondary) 10%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-success\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-success);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-success\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-success) 10%, transparent);
    }
  }

  .data-\\[state\\=open\\]\\:before\\:bg-warning\\/10[data-state="open"]:before {
    content: var(--tw-content);
    background-color: var(--ui-warning);
  }

  @supports (color: color-mix(in lab, red, red)) {
    .data-\\[state\\=open\\]\\:before\\:bg-warning\\/10[data-state="open"]:before {
      background-color: color-mix(in oklab, var(--ui-warning) 10%, transparent);
    }
  }

  .data-\\[state\\=unchecked\\]\\:translate-x-0[data-state="unchecked"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 0);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=unchecked\\]\\:bg-accented[data-state="unchecked"] {
    background-color: var(--ui-bg-accented);
  }

  .data-\\[state\\=visible\\]\\:animate-\\[fade-in_100ms_ease-out\\][data-state="visible"] {
    animation: .1s ease-out fade-in;
  }

  .data-\\[swipe\\=cancel\\]\\:translate-x-0[data-swipe="cancel"] {
    --tw-translate-x: calc(var(--spacing, .25rem) * 0);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=cancel\\]\\:translate-y-0[data-swipe="cancel"] {
    --tw-translate-y: calc(var(--spacing, .25rem) * 0);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=end\\]\\:translate-x-\\(--reka-toast-swipe-end-x\\)[data-swipe="end"] {
    --tw-translate-x: var(--reka-toast-swipe-end-x);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=end\\]\\:translate-y-\\(--reka-toast-swipe-end-y\\)[data-swipe="end"] {
    --tw-translate-y: var(--reka-toast-swipe-end-y);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=end\\]\\:animate-\\[toast-slide-down_200ms_ease-out\\][data-swipe="end"] {
    animation: .2s ease-out toast-slide-down;
  }

  .data-\\[swipe\\=end\\]\\:animate-\\[toast-slide-left_200ms_ease-out\\][data-swipe="end"] {
    animation: .2s ease-out toast-slide-left;
  }

  .data-\\[swipe\\=end\\]\\:animate-\\[toast-slide-right_200ms_ease-out\\][data-swipe="end"] {
    animation: .2s ease-out toast-slide-right;
  }

  .data-\\[swipe\\=end\\]\\:animate-\\[toast-slide-up_200ms_ease-out\\][data-swipe="end"] {
    animation: .2s ease-out toast-slide-up;
  }

  .data-\\[swipe\\=move\\]\\:translate-x-\\(--reka-toast-swipe-move-x\\)[data-swipe="move"] {
    --tw-translate-x: var(--reka-toast-swipe-move-x);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=move\\]\\:translate-y-\\(--reka-toast-swipe-move-y\\)[data-swipe="move"] {
    --tw-translate-y: var(--reka-toast-swipe-move-y);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[swipe\\=move\\]\\:transition-none[data-swipe="move"] {
    transition-property: none;
  }

  @media (min-width: 40rem) {
    .sm\\:-start-12 {
      inset-inline-start: calc(var(--spacing, .25rem) * -12);
    }

    .sm\\:-end-12 {
      inset-inline-end: calc(var(--spacing, .25rem) * -12);
    }

    .sm\\:-top-12 {
      top: calc(var(--spacing, .25rem) * -12);
    }

    .sm\\:-bottom-12 {
      bottom: calc(var(--spacing, .25rem) * -12);
    }

    .sm\\:max-h-\\[calc\\(100dvh-4rem\\)\\] {
      max-height: calc(100dvh - 4rem);
    }

    .sm\\:w-\\(--reka-navigation-menu-viewport-width\\) {
      width: var(--reka-navigation-menu-viewport-width);
    }

    .sm\\:w-96 {
      width: calc(var(--spacing, .25rem) * 96);
    }

    .sm\\:flex-row {
      flex-direction: row;
    }

    :where(.sm\\:space-y-0 > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing, .25rem) * 0) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing, .25rem) * 0) * calc(1 - var(--tw-space-y-reverse)));
    }

    :where(.sm\\:space-x-4 > :not(:last-child)) {
      --tw-space-x-reverse: 0;
      margin-inline-start: calc(calc(var(--spacing, .25rem) * 4) * var(--tw-space-x-reverse));
      margin-inline-end: calc(calc(var(--spacing, .25rem) * 4) * calc(1 - var(--tw-space-x-reverse)));
    }

    .sm\\:p-6 {
      padding: calc(var(--spacing, .25rem) * 6);
    }

    .sm\\:px-6 {
      padding-inline: calc(var(--spacing, .25rem) * 6);
    }

    .sm\\:shadow-lg {
      --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, #0000001a), 0 4px 6px -4px var(--tw-shadow-color, #0000001a);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }

    .sm\\:ring {
      --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }

  @media (min-width: 48rem) {
    .md\\:grid-cols-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
  }

  @media (min-width: 64rem) {
    .lg\\:inline-flex {
      display: inline-flex;
    }

    .lg\\:px-8 {
      padding-inline: calc(var(--spacing, .25rem) * 8);
    }
  }

  .rtl\\:translate-x-\\[4px\\]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: 4px;
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .rtl\\:-rotate-90:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    rotate: -90deg;
  }

  .rtl\\:text-right:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    text-align: right;
  }

  .rtl\\:after\\:animate-\\[carousel-inverse-rtl_2s_ease-in-out_infinite\\]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *):after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite carousel-inverse-rtl;
  }

  .rtl\\:after\\:animate-\\[carousel-rtl_2s_ease-in-out_infinite\\]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *):after {
    content: var(--tw-content);
    animation: 2s ease-in-out infinite carousel-rtl;
  }

  .data-\\[state\\=checked\\]\\:rtl\\:-translate-x-3[data-state="checked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * -3);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:rtl\\:-translate-x-3\\.5[data-state="checked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * -3.5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:rtl\\:-translate-x-4[data-state="checked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * -4);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:rtl\\:-translate-x-4\\.5[data-state="checked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * -4.5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=checked\\]\\:rtl\\:-translate-x-5[data-state="checked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * -5);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .data-\\[state\\=indeterminate\\]\\:rtl\\:animate-\\[carousel-inverse-rtl_2s_ease-in-out_infinite\\][data-state="indeterminate"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    animation: 2s ease-in-out infinite carousel-inverse-rtl;
  }

  .data-\\[state\\=indeterminate\\]\\:rtl\\:animate-\\[carousel-rtl_2s_ease-in-out_infinite\\][data-state="indeterminate"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    animation: 2s ease-in-out infinite carousel-rtl;
  }

  .data-\\[state\\=unchecked\\]\\:rtl\\:-translate-x-0[data-state="unchecked"]:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *) {
    --tw-translate-x: calc(var(--spacing, .25rem) * 0);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }

  .dark\\:focus-visible\\:outline-none:where(.dark, .dark *):focus-visible {
    --tw-outline-style: none;
    outline-style: none;
  }

  .dark\\:disabled\\:bg-transparent:where(.dark, .dark *):disabled {
    background-color: #0000;
  }

  @media (hover: hover) {
    .dark\\:hover\\:disabled\\:bg-transparent:where(.dark, .dark *):hover:disabled {
      background-color: #0000;
    }
  }

  .dark\\:aria-disabled\\:bg-transparent:where(.dark, .dark *)[aria-disabled="true"] {
    background-color: #0000;
  }

  @media (hover: hover) {
    .dark\\:hover\\:aria-disabled\\:bg-transparent:where(.dark, .dark *):hover[aria-disabled="true"] {
      background-color: #0000;
    }
  }

  .\\[\\&\\:has\\(\\[role\\=checkbox\\]\\)\\]\\:pe-0:has([role="checkbox"]) {
    padding-inline-end: calc(var(--spacing, .25rem) * 0);
  }

  .\\[\\&\\>button\\]\\:py-0 > button {
    padding-block: calc(var(--spacing, .25rem) * 0);
  }

  .\\[\\&\\>div\\]\\:min-w-0 > div {
    min-width: calc(var(--spacing, .25rem) * 0);
  }

  .\\[\\&\\>input\\]\\:h-12 > input {
    height: calc(var(--spacing, .25rem) * 12);
  }

  .\\[\\&\\>mark\\]\\:bg-primary > mark {
    background-color: var(--ui-primary);
  }

  .\\[\\&\\>mark\\]\\:text-inverted > mark {
    color: var(--ui-text-inverted);
  }

  @media (hover: hover) {
    .\\[\\&\\>tr\\]\\:data-\\[selectable\\=true\\]\\:hover\\:bg-elevated\\/50 > tr[data-selectable="true"]:hover {
      background-color: var(--ui-bg-elevated);
    }

    @supports (color: color-mix(in lab, red, red)) {
      .\\[\\&\\>tr\\]\\:data-\\[selectable\\=true\\]\\:hover\\:bg-elevated\\/50 > tr[data-selectable="true"]:hover {
        background-color: color-mix(in oklab, var(--ui-bg-elevated) 50%, transparent);
      }
    }
  }

  .\\[\\&\\>tr\\]\\:data-\\[selectable\\=true\\]\\:focus-visible\\:outline-primary > tr[data-selectable="true"]:focus-visible {
    outline-color: var(--ui-primary);
  }
}

@keyframes accordion-up {
  0% {
    height: var(--reka-accordion-content-height);
  }

  to {
    height: 0;
  }
}

@keyframes accordion-down {
  0% {
    height: 0;
  }

  to {
    height: var(--reka-accordion-content-height);
  }
}

@keyframes collapsible-up {
  0% {
    height: var(--reka-collapsible-content-height);
  }

  to {
    height: 0;
  }
}

@keyframes collapsible-down {
  0% {
    height: 0;
  }

  to {
    height: var(--reka-collapsible-content-height);
  }
}

@keyframes toast-collapsed-closed {
  0% {
    transform: var(--transform);
  }

  to {
    transform: translateY(calc((var(--before)  - var(--height)) * var(--gap))) scale(var(--scale));
  }
}

@keyframes toast-closed {
  0% {
    transform: var(--transform);
  }

  to {
    transform: translateY(calc((var(--offset)  - var(--height)) * var(--translate-factor)));
  }
}

@keyframes toast-slide-left {
  0% {
    transform: translateX(0) translateY(var(--translate));
  }

  to {
    transform: translateX(-100%) translateY(var(--translate));
  }
}

@keyframes toast-slide-right {
  0% {
    transform: translateX(0) translateY(var(--translate));
  }

  to {
    transform: translateX(100%) translateY(var(--translate));
  }
}

@keyframes fade-in {
  0% {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

@keyframes fade-out {
  0% {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
}

@keyframes scale-in {
  0% {
    opacity: 0;
    transform: scale(.95);
  }

  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes scale-out {
  0% {
    opacity: 1;
    transform: scale(1);
  }

  to {
    opacity: 0;
    transform: scale(.95);
  }
}

@keyframes slide-in-from-top {
  0% {
    transform: translateY(-100%);
  }

  to {
    transform: translateY(0);
  }
}

@keyframes slide-out-to-top {
  0% {
    transform: translateY(0);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes slide-in-from-right {
  0% {
    transform: translateX(100%);
  }

  to {
    transform: translateX(0);
  }
}

@keyframes slide-out-to-right {
  0% {
    transform: translateX(0);
  }

  to {
    transform: translateX(100%);
  }
}

@keyframes slide-in-from-bottom {
  0% {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0);
  }
}

@keyframes slide-out-to-bottom {
  0% {
    transform: translateY(0);
  }

  to {
    transform: translateY(100%);
  }
}

@keyframes slide-in-from-left {
  0% {
    transform: translateX(-100%);
  }

  to {
    transform: translateX(0);
  }
}

@keyframes slide-out-to-left {
  0% {
    transform: translateX(0);
  }

  to {
    transform: translateX(-100%);
  }
}

@keyframes slide-in-from-top-and-fade {
  0% {
    opacity: 0;
    transform: translateY(-4px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slide-out-to-top-and-fade {
  0% {
    opacity: 1;
    transform: translateY(0);
  }

  to {
    opacity: 0;
    transform: translateY(-4px);
  }
}

@keyframes slide-in-from-right-and-fade {
  0% {
    opacity: 0;
    transform: translateX(4px);
  }

  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slide-out-to-right-and-fade {
  0% {
    opacity: 1;
    transform: translateX(0);
  }

  to {
    opacity: 0;
    transform: translateX(4px);
  }
}

@keyframes slide-in-from-bottom-and-fade {
  0% {
    opacity: 0;
    transform: translateY(4px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slide-out-to-bottom-and-fade {
  0% {
    opacity: 1;
    transform: translateY(0);
  }

  to {
    opacity: 0;
    transform: translateY(4px);
  }
}

@keyframes slide-in-from-left-and-fade {
  0% {
    opacity: 0;
    transform: translateX(-4px);
  }

  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slide-out-to-left-and-fade {
  0% {
    opacity: 1;
    transform: translateX(0);
  }

  to {
    opacity: 0;
    transform: translateX(-4px);
  }
}

@keyframes enter-from-right {
  0% {
    opacity: 0;
    transform: translateX(200px);
  }

  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes enter-from-left {
  0% {
    opacity: 0;
    transform: translateX(-200px);
  }

  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes exit-to-right {
  0% {
    opacity: 1;
    transform: translateX(0);
  }

  to {
    opacity: 0;
    transform: translateX(200px);
  }
}

@keyframes exit-to-left {
  0% {
    opacity: 1;
    transform: translateX(0);
  }

  to {
    opacity: 0;
    transform: translateX(-200px);
  }
}

@keyframes carousel {
  0%, to {
    width: 50%;
  }

  0% {
    transform: translateX(-100%);
  }

  to {
    transform: translateX(200%);
  }
}

@keyframes carousel-rtl {
  0%, to {
    width: 50%;
  }

  0% {
    transform: translateX(100%);
  }

  to {
    transform: translateX(-200%);
  }
}

@keyframes carousel-vertical {
  0%, to {
    height: 50%;
  }

  0% {
    transform: translateY(-100%);
  }

  to {
    transform: translateY(200%);
  }
}

@keyframes carousel-inverse {
  0%, to {
    width: 50%;
  }

  0% {
    transform: translateX(200%);
  }

  to {
    transform: translateX(-100%);
  }
}

@keyframes carousel-inverse-rtl {
  0%, to {
    width: 50%;
  }

  0% {
    transform: translateX(-200%);
  }

  to {
    transform: translateX(100%);
  }
}

@keyframes carousel-inverse-vertical {
  0%, to {
    height: 50%;
  }

  0% {
    transform: translateY(200%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes swing {
  0%, to {
    width: 50%;
  }

  0%, to {
    transform: translateX(-25%);
  }

  50% {
    transform: translateX(125%);
  }
}

@keyframes swing-vertical {
  0%, to {
    height: 50%;
  }

  0%, to {
    transform: translateY(-25%);
  }

  50% {
    transform: translateY(125%);
  }
}

@keyframes elastic {
  0%, to {
    width: 50%;
    margin-left: 25%;
  }

  50% {
    width: 90%;
    margin-left: 5%;
  }
}

@keyframes elastic-vertical {
  0%, to {
    height: 50%;
    margin-top: 25%;
  }

  50% {
    height: 90%;
    margin-top: 5%;
  }
}

:root {
  --ui-color-success-50: #f0fdf4;
  --ui-color-success-100: #dcfce7;
  --ui-color-success-200: #bbf7d0;
  --ui-color-success-300: #86efac;
  --ui-color-success-400: #4ade80;
  --ui-color-success-500: #22c55e;
  --ui-color-success-600: #16a34a;
  --ui-color-success-700: #15803d;
  --ui-color-success-800: #166534;
  --ui-color-success-900: #14532d;
  --ui-color-success-950: #052e16;
  --ui-color-primary-50: #eff6ff;
  --ui-color-primary-100: #dbeafe;
  --ui-color-primary-200: #bfdbfe;
  --ui-color-primary-300: #93c5fd;
  --ui-color-primary-400: #60a5fa;
  --ui-color-primary-500: #3b82f6;
  --ui-color-primary-600: #2563eb;
  --ui-color-primary-700: #1d4ed8;
  --ui-color-primary-800: #1e40af;
  --ui-color-primary-900: #1e3a8a;
  --ui-color-primary-950: #172554;
  --ui-color-danger-50: #fef2f2;
  --ui-color-danger-100: #fee2e2;
  --ui-color-danger-200: #fecaca;
  --ui-color-danger-300: #fca5a5;
  --ui-color-danger-400: #f87171;
  --ui-color-danger-500: #ef4444;
  --ui-color-danger-600: #dc2626;
  --ui-color-danger-700: #b91c1c;
  --ui-color-danger-800: #991b1b;
  --ui-color-danger-900: #7f1d1d;
  --ui-color-danger-950: #450a0a;
  --ui-color-warning-50: #fffbeb;
  --ui-color-warning-100: #fef3c7;
  --ui-color-warning-200: #fde68a;
  --ui-color-warning-300: #fcd34d;
  --ui-color-warning-400: #fbbf24;
  --ui-color-warning-500: #f59e0b;
  --ui-color-warning-600: #d97706;
  --ui-color-warning-700: #b45309;
  --ui-color-warning-800: #92400e;
  --ui-color-warning-900: #78350f;
  --ui-color-warning-950: #451a03;
  --ui-color-gray-50: #f9fafb;
  --ui-color-gray-100: #f3f4f6;
  --ui-color-gray-200: #e5e7eb;
  --ui-color-gray-300: #d1d5db;
  --ui-color-gray-400: #9ca3af;
  --ui-color-gray-500: #6b7280;
  --ui-color-gray-600: #4b5563;
  --ui-color-gray-700: #374151;
  --ui-color-gray-800: #1f2937;
  --ui-color-gray-900: #111827;
  --ui-color-gray-950: #030712;
  --ui-color-neutral-50: #f9fafb;
  --ui-color-neutral-100: #f3f4f6;
  --ui-color-neutral-200: #e5e7eb;
  --ui-color-neutral-300: #d1d5db;
  --ui-color-neutral-400: #9ca3af;
  --ui-color-neutral-500: #6b7280;
  --ui-color-neutral-600: #4b5563;
  --ui-color-neutral-700: #374151;
  --ui-color-neutral-800: #1f2937;
  --ui-color-neutral-900: #111827;
  --ui-color-neutral-950: #030712;
  --ui-success: var(--ui-color-success-500);
  --ui-danger: var(--ui-color-danger-500);
  --ui-error: var(--ui-color-danger-500);
  --ui-warning: var(--ui-color-warning-500);
  --ui-gray: var(--ui-color-gray-500);
  --ui-secondary: var(--ui-color-gray-500);
  --ui-info: var(--ui-color-primary-500);
  --ui-primary: var(--color-blue-500);
  --ui-neutral: var(--color-neutral-500);
  --ui-text-dimmed: var(--ui-color-gray-400);
  --ui-text-muted: var(--ui-color-gray-500);
  --ui-text-toned: var(--ui-color-gray-600);
  --ui-text: var(--ui-color-gray-700);
  --ui-text-highlighted: var(--ui-color-gray-900);
  --ui-text-inverted: #fff;
  --ui-bg: #fff;
  --ui-bg-muted: var(--ui-color-gray-50);
  --ui-bg-elevated: var(--ui-color-gray-100);
  --ui-bg-accented: var(--ui-color-gray-200);
  --ui-bg-inverted: var(--ui-color-gray-900);
  --ui-border: var(--ui-color-gray-200);
  --ui-border-muted: var(--ui-color-gray-200);
  --ui-border-accented: var(--ui-color-gray-300);
  --ui-border-inverted: var(--ui-color-gray-900);
  --ui-radius: .25rem;
  --ui-font: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --ui-font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --ui-transition: all .15s cubic-bezier(.4, 0, .2, 1);
  --ui-transition-duration: .15s;
  --ui-transition-timing: cubic-bezier(.4, 0, .2, 1);
  --ui-container: 80rem;
  --ui-spacing: .25rem;
  --ui-shadow: 0 1px 3px 0 #0000001a, 0 1px 2px -1px #0000001a;
  --ui-shadow-sm: 0 1px 2px 0 #0000000d;
  --ui-shadow-md: 0 4px 6px -1px #0000001a, 0 2px 4px -2px #0000001a;
  --ui-shadow-lg: 0 10px 15px -3px #0000001a, 0 4px 6px -4px #0000001a;
  --ui-shadow-xl: 0 20px 25px -5px #0000001a, 0 8px 10px -6px #0000001a;
  --ui-z-dropdown: 1000;
  --ui-z-sticky: 1020;
  --ui-z-fixed: 1030;
  --ui-z-modal-backdrop: 1040;
  --ui-z-modal: 1050;
  --ui-z-popover: 1060;
  --ui-z-tooltip: 1070;
  --ui-z-toast: 1080;
  --tw-duration: .15s;
  --tw-ease-in: cubic-bezier(.4, 0, 1, 1);
  --tw-ease-out: cubic-bezier(0, 0, .2, 1);
  --tw-ease-in-out: cubic-bezier(.4, 0, .2, 1);
  --tw-timing-function: cubic-bezier(.4, 0, .2, 1);
  --tw-bg-opacity: 1;
  --tw-text-opacity: 1;
  --tw-border-opacity: 1;
  --tw-ring-opacity: .5;
  --tw-shadow-color: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
  --tw-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #3b82f680;
  --tw-ring-inset: ;
  --tw-divide-x-reverse: 0;
  --tw-divide-y-reverse: 0;
  --tw-divide-opacity: 1;
  --tw-space-x-reverse: 0;
  --tw-space-y-reverse: 0;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-gradient-from: #000;
  --tw-gradient-to: #000;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
  --tw-scroll-snap-strictness: proximity;
}

::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  display: none;
}

::-webkit-scrollbar-thumb {
  background: #00000040;
  border-radius: 15px;
}

::-webkit-scrollbar-thumb:hover {
  background: #00000073;
}

@property --tw-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-translate-z {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-scale-x {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}

@property --tw-scale-y {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}

@property --tw-scale-z {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}

@property --tw-rotate-x {
  syntax: "*";
  inherits: false
}

@property --tw-rotate-y {
  syntax: "*";
  inherits: false
}

@property --tw-rotate-z {
  syntax: "*";
  inherits: false
}

@property --tw-skew-x {
  syntax: "*";
  inherits: false
}

@property --tw-skew-y {
  syntax: "*";
  inherits: false
}

@property --tw-pan-x {
  syntax: "*";
  inherits: false
}

@property --tw-pan-y {
  syntax: "*";
  inherits: false
}

@property --tw-pinch-zoom {
  syntax: "*";
  inherits: false
}

@property --tw-space-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-space-x-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-divide-x-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}

@property --tw-divide-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-leading {
  syntax: "*";
  inherits: false
}

@property --tw-font-weight {
  syntax: "*";
  inherits: false
}

@property --tw-ordinal {
  syntax: "*";
  inherits: false
}

@property --tw-slashed-zero {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-figure {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-spacing {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-fraction {
  syntax: "*";
  inherits: false
}

@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-ring-color {
  syntax: "*";
  inherits: false
}

@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false
}

@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-ring-inset {
  syntax: "*";
  inherits: false
}

@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0;
}

@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}

@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-outline-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}

@property --tw-blur {
  syntax: "*";
  inherits: false
}

@property --tw-brightness {
  syntax: "*";
  inherits: false
}

@property --tw-contrast {
  syntax: "*";
  inherits: false
}

@property --tw-grayscale {
  syntax: "*";
  inherits: false
}

@property --tw-hue-rotate {
  syntax: "*";
  inherits: false
}

@property --tw-invert {
  syntax: "*";
  inherits: false
}

@property --tw-opacity {
  syntax: "*";
  inherits: false
}

@property --tw-saturate {
  syntax: "*";
  inherits: false
}

@property --tw-sepia {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-drop-shadow-size {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-blur {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-brightness {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-contrast {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-grayscale {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-hue-rotate {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-invert {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-opacity {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-saturate {
  syntax: "*";
  inherits: false
}

@property --tw-backdrop-sepia {
  syntax: "*";
  inherits: false
}

@property --tw-duration {
  syntax: "*";
  inherits: false
}

@property --tw-ease {
  syntax: "*";
  inherits: false
}

@property --tw-content {
  syntax: "*";
  inherits: false;
  initial-value: "";
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@keyframes pulse {
  50% {
    opacity: .5;
  }
}
`;
const meIconStyles = `/*!
 * ME Font Library - version 3.5.8
 * 2025 Mercado Eletrnico
 */

.me-icon,.me-icon-b,.me-icon-l,.me-icon-s,.me-icon-t{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto}.icon-address-book:before{content:"\\f101"}.icon-address-card:before{content:"\\f102"}.icon-adjust:before{content:"\\f103"}.icon-alarm-clock:before{content:"\\f104"}.icon-alarm-exclamation:before{content:"\\f105"}.icon-alarm-plus:before{content:"\\f106"}.icon-align-center:before{content:"\\f107"}.icon-align-justify:before{content:"\\f108"}.icon-align-left:before{content:"\\f109"}.icon-align-right:before{content:"\\f10a"}.icon-align-slash:before{content:"\\f10b"}.icon-analytics:before{content:"\\f10c"}.icon-angle-double-down:before{content:"\\f10d"}.icon-angle-double-left:before{content:"\\f10e"}.icon-angle-double-right:before{content:"\\f10f"}.icon-angle-double-up:before{content:"\\f110"}.icon-angle-down:before{content:"\\f111"}.icon-angle-left:before{content:"\\f112"}.icon-angle-right:before{content:"\\f113"}.icon-angle-up:before{content:"\\f114"}.icon-angles-down:before{content:"\\f115"}.icon-angles-left:before{content:"\\f116"}.icon-angles-right:before{content:"\\f117"}.icon-angles-up:before{content:"\\f118"}.icon-apps:before{content:"\\f119"}.icon-archive:before{content:"\\f11a"}.icon-arrow-alt-circle-down:before{content:"\\f11b"}.icon-arrow-alt-circle-left:before{content:"\\f11c"}.icon-arrow-alt-circle-right:before{content:"\\f11d"}.icon-arrow-alt-circle-up:before{content:"\\f11e"}.icon-arrow-alt-down:before{content:"\\f11f"}.icon-arrow-alt-from-bottom:before{content:"\\f120"}.icon-arrow-alt-from-left:before{content:"\\f121"}.icon-arrow-alt-from-right:before{content:"\\f122"}.icon-arrow-alt-from-top:before{content:"\\f123"}.icon-arrow-alt-left:before{content:"\\f124"}.icon-arrow-alt-right:before{content:"\\f125"}.icon-arrow-alt-square-down:before{content:"\\f126"}.icon-arrow-alt-square-left:before{content:"\\f127"}.icon-arrow-alt-square-right:before{content:"\\f128"}.icon-arrow-alt-square-up:before{content:"\\f129"}.icon-arrow-alt-to-bottom:before{content:"\\f12a"}.icon-arrow-alt-to-left:before{content:"\\f12b"}.icon-arrow-alt-to-right:before{content:"\\f12c"}.icon-arrow-alt-to-top:before{content:"\\f12d"}.icon-arrow-alt-up:before{content:"\\f12e"}.icon-arrow-circle-down:before{content:"\\f12f"}.icon-arrow-circle-left:before{content:"\\f130"}.icon-arrow-circle-right:before{content:"\\f131"}.icon-arrow-circle-up:before{content:"\\f132"}.icon-arrow-down-1-9:before{content:"\\f133"}.icon-arrow-down-9-1:before{content:"\\f134"}.icon-arrow-down-a-z:before{content:"\\f135"}.icon-arrow-down-arrow-up:before{content:"\\f136"}.icon-arrow-down-big-small:before{content:"\\f137"}.icon-arrow-down-from-dotted-line:before{content:"\\f138"}.icon-arrow-down-from-line:before{content:"\\f139"}.icon-arrow-down-left-and-arrow-up-right-to-center:before{content:"\\f13a"}.icon-arrow-down-left:before{content:"\\f13b"}.icon-arrow-down-long:before{content:"\\f13c"}.icon-arrow-down-right:before{content:"\\f13d"}.icon-arrow-down-short-wide:before{content:"\\f13e"}.icon-arrow-down-small-big:before{content:"\\f13f"}.icon-arrow-down-square-triangle:before{content:"\\f140"}.icon-arrow-down-to-arc:before{content:"\\f141"}.icon-arrow-down-to-bracket:before{content:"\\f142"}.icon-arrow-down-to-dotted-line:before{content:"\\f143"}.icon-arrow-down-to-line:before{content:"\\f144"}.icon-arrow-down-to-square:before{content:"\\f145"}.icon-arrow-down-triangle-square:before{content:"\\f146"}.icon-arrow-down-up-across-line:before{content:"\\f147"}.icon-arrow-down-up-lock:before{content:"\\f148"}.icon-arrow-down-wide-short:before{content:"\\f149"}.icon-arrow-down-z-a:before{content:"\\f14a"}.icon-arrow-down:before{content:"\\f14b"}.icon-arrow-from-bottom:before{content:"\\f14c"}.icon-arrow-from-left:before{content:"\\f14d"}.icon-arrow-from-right:before{content:"\\f14e"}.icon-arrow-from-top:before{content:"\\f14f"}.icon-arrow-left-from-line:before{content:"\\f150"}.icon-arrow-left-long-to-line:before{content:"\\f151"}.icon-arrow-left-long:before{content:"\\f152"}.icon-arrow-left-to-line:before{content:"\\f153"}.icon-arrow-left:before{content:"\\f154"}.icon-arrow-pointer:before{content:"\\f155"}.icon-arrow-right-arrow-left:before{content:"\\f156"}.icon-arrow-right-from-arc:before{content:"\\f157"}.icon-arrow-right-from-bracket:before{content:"\\f158"}.icon-arrow-right-from-line:before{content:"\\f159"}.icon-arrow-right-long-to-line:before{content:"\\f15a"}.icon-arrow-right-long:before{content:"\\f15b"}.icon-arrow-right-to-arc:before{content:"\\f15c"}.icon-arrow-right-to-bracket:before{content:"\\f15d"}.icon-arrow-right-to-line:before{content:"\\f15e"}.icon-arrow-right:before{content:"\\f15f"}.icon-arrow-rotate-left:before{content:"\\f160"}.icon-arrow-rotate-right:before{content:"\\f161"}.icon-arrow-square-down:before{content:"\\f162"}.icon-arrow-square-left:before{content:"\\f163"}.icon-arrow-square-right:before{content:"\\f164"}.icon-arrow-square-up:before{content:"\\f165"}.icon-arrow-to-bottom:before{content:"\\f166"}.icon-arrow-to-left:before{content:"\\f167"}.icon-arrow-to-right:before{content:"\\f168"}.icon-arrow-to-top:before{content:"\\f169"}.icon-arrow-trend-down:before{content:"\\f16a"}.icon-arrow-trend-up:before{content:"\\f16b"}.icon-arrow-turn-down-left:before{content:"\\f16c"}.icon-arrow-turn-down-right:before{content:"\\f16d"}.icon-arrow-turn-down:before{content:"\\f16e"}.icon-arrow-turn-up:before{content:"\\f16f"}.icon-arrow-up-1-9:before{content:"\\f170"}.icon-arrow-up-9-1:before{content:"\\f171"}.icon-arrow-up-a-z:before{content:"\\f172"}.icon-arrow-up-arrow-down:before{content:"\\f173"}.icon-arrow-up-big-small:before{content:"\\f174"}.icon-arrow-up-from-arc:before{content:"\\f175"}.icon-arrow-up-from-bracket:before{content:"\\f176"}.icon-arrow-up-from-dotted-line:before{content:"\\f177"}.icon-arrow-up-from-ground-water:before{content:"\\f178"}.icon-arrow-up-from-line:before{content:"\\f179"}.icon-arrow-up-from-square:before{content:"\\f17a"}.icon-arrow-up-from-water-pump:before{content:"\\f17b"}.icon-arrow-up-left-from-circle:before{content:"\\f17c"}.icon-arrow-up-left:before{content:"\\f17d"}.icon-arrow-up-long:before{content:"\\f17e"}.icon-arrow-up-right-and-arrow-down-left-from-center:before{content:"\\f17f"}.icon-arrow-up-right-dots:before{content:"\\f180"}.icon-arrow-up-right-from-square:before{content:"\\f181"}.icon-arrow-up-right:before{content:"\\f182"}.icon-arrow-up-short-wide:before{content:"\\f183"}.icon-arrow-up-small-big:before{content:"\\f184"}.icon-arrow-up-square-triangle:before{content:"\\f185"}.icon-arrow-up-to-dotted-line:before{content:"\\f186"}.icon-arrow-up-to-line:before{content:"\\f187"}.icon-arrow-up-triangle-square:before{content:"\\f188"}.icon-arrow-up-wide-short:before{content:"\\f189"}.icon-arrow-up-z-a:before{content:"\\f18a"}.icon-arrow-up:before{content:"\\f18b"}.icon-arrows-alt-h:before{content:"\\f18c"}.icon-arrows-alt-v:before{content:"\\f18d"}.icon-arrows-alt:before{content:"\\f18e"}.icon-arrows-cross:before{content:"\\f18f"}.icon-arrows-down-to-line:before{content:"\\f190"}.icon-arrows-down-to-people:before{content:"\\f191"}.icon-arrows-from-dotted-line:before{content:"\\f192"}.icon-arrows-from-line:before{content:"\\f193"}.icon-arrows-h:before{content:"\\f194"}.icon-arrows-left-right-to-line:before{content:"\\f195"}.icon-arrows-left-right:before{content:"\\f196"}.icon-arrows-maximize:before{content:"\\f197"}.icon-arrows-minimize:before{content:"\\f198"}.icon-arrows-repeat-1:before{content:"\\f199"}.icon-arrows-repeat:before{content:"\\f19a"}.icon-arrows-retweet:before{content:"\\f19b"}.icon-arrows-rotate:before{content:"\\f19c"}.icon-arrows-spin:before{content:"\\f19d"}.icon-arrows-split-up-and-left:before{content:"\\f19e"}.icon-arrows-to-circle:before{content:"\\f19f"}.icon-arrows-to-dot:before{content:"\\f1a0"}.icon-arrows-to-dotted-line:before{content:"\\f1a1"}.icon-arrows-to-line:before{content:"\\f1a2"}.icon-arrows-turn-right:before{content:"\\f1a3"}.icon-arrows-turn-to-dots:before{content:"\\f1a4"}.icon-arrows-up-down-left-right:before{content:"\\f1a5"}.icon-arrows-up-down:before{content:"\\f1a6"}.icon-arrows-up-to-line:before{content:"\\f1a7"}.icon-arrows-v:before{content:"\\f1a8"}.icon-arrows:before{content:"\\f1a9"}.icon-asterisk:before{content:"\\f1aa"}.icon-at:before{content:"\\f1ab"}.icon-atlas:before{content:"\\f1ac"}.icon-award-simple:before{content:"\\f1ad"}.icon-award:before{content:"\\f1ae"}.icon-backpack:before{content:"\\f1af"}.icon-backspace:before{content:"\\f1b0"}.icon-backward-fast:before{content:"\\f1b1"}.icon-backward-step:before{content:"\\f1b2"}.icon-backward:before{content:"\\f1b3"}.icon-badge-check:before{content:"\\f1b4"}.icon-badge-dollar:before{content:"\\f1b5"}.icon-badge-percent:before{content:"\\f1b6"}.icon-badge:before{content:"\\f1b7"}.icon-bag-shopping:before{content:"\\f1b8"}.icon-bags-shopping:before{content:"\\f1b9"}.icon-ballot-check:before{content:"\\f1ba"}.icon-ballot:before{content:"\\f1bb"}.icon-ban:before{content:"\\f1bc"}.icon-bars-filter:before{content:"\\f1bd"}.icon-bars-progress:before{content:"\\f1be"}.icon-bars-sort:before{content:"\\f1bf"}.icon-bars-staggered:before{content:"\\f1c0"}.icon-bars:before{content:"\\f1c1"}.icon-basket-shopping-simple:before{content:"\\f1c2"}.icon-basket-shopping:before{content:"\\f1c3"}.icon-battery-bolt:before{content:"\\f1c4"}.icon-battery-empty:before{content:"\\f1c5"}.icon-battery-exclamation:before{content:"\\f1c6"}.icon-battery-full:before{content:"\\f1c7"}.icon-battery-half:before{content:"\\f1c8"}.icon-battery-low:before{content:"\\f1c9"}.icon-battery-quarter:before{content:"\\f1ca"}.icon-battery-slash:before{content:"\\f1cb"}.icon-battery-three-quarters:before{content:"\\f1cc"}.icon-bell-exclamation:before{content:"\\f1cd"}.icon-bell-on:before{content:"\\f1ce"}.icon-bell-plus:before{content:"\\f1cf"}.icon-bell-slash:before{content:"\\f1d0"}.icon-bell:before{content:"\\f1d1"}.icon-bells:before{content:"\\f1d2"}.icon-bezier-curve:before{content:"\\f1d3"}.icon-binary-circle-check:before{content:"\\f1d4"}.icon-binary-lock:before{content:"\\f1d5"}.icon-binary-slash:before{content:"\\f1d6"}.icon-binary:before{content:"\\f1d7"}.icon-board:before{content:"\\f1d8"}.icon-bold:before{content:"\\f1d9"}.icon-book-alt:before{content:"\\f1da"}.icon-book-arrow-right:before{content:"\\f1db"}.icon-book-arrow-up:before{content:"\\f1dc"}.icon-book-atlas:before{content:"\\f1dd"}.icon-book-blank:before{content:"\\f1de"}.icon-book-bookmark:before{content:"\\f1df"}.icon-book-circle-arrow-right:before{content:"\\f1e0"}.icon-book-circle-arrow-up:before{content:"\\f1e1"}.icon-book-copy:before{content:"\\f1e2"}.icon-book-font:before{content:"\\f1e3"}.icon-book-open-cover:before{content:"\\f1e4"}.icon-book-open-reader:before{content:"\\f1e5"}.icon-book-open:before{content:"\\f1e6"}.icon-book-reader:before{content:"\\f1e7"}.icon-book-section:before{content:"\\f1e8"}.icon-book-user:before{content:"\\f1e9"}.icon-book:before{content:"\\f1ea"}.icon-bookmark-slash:before{content:"\\f1eb"}.icon-bookmark:before{content:"\\f1ec"}.icon-books:before{content:"\\f1ed"}.icon-border-all:before{content:"\\f1ee"}.icon-border-bottom-right:before{content:"\\f1ef"}.icon-border-bottom:before{content:"\\f1f0"}.icon-border-center-h:before{content:"\\f1f1"}.icon-border-center-v:before{content:"\\f1f2"}.icon-border-inner:before{content:"\\f1f3"}.icon-border-left:before{content:"\\f1f4"}.icon-border-none:before{content:"\\f1f5"}.icon-border-outer:before{content:"\\f1f6"}.icon-border-right:before{content:"\\f1f7"}.icon-border-style-alt:before{content:"\\f1f8"}.icon-border-style:before{content:"\\f1f9"}.icon-border-top-left:before{content:"\\f1fa"}.icon-border-top:before{content:"\\f1fb"}.icon-box-alt:before{content:"\\f1fc"}.icon-box-archive:before{content:"\\f1fd"}.icon-box-ballot:before{content:"\\f1fe"}.icon-box-check:before{content:"\\f1ff"}.icon-box-circle-check:before{content:"\\f200"}.icon-box-dollar:before{content:"\\f201"}.icon-box-full:before{content:"\\f202"}.icon-box-open-full:before{content:"\\f203"}.icon-box-open:before{content:"\\f204"}.icon-box-taped:before{content:"\\f205"}.icon-box-tissue:before{content:"\\f206"}.icon-box-up:before{content:"\\f207"}.icon-box-usd:before{content:"\\f208"}.icon-box:before{content:"\\f209"}.icon-boxes-alt:before{content:"\\f20a"}.icon-boxes-packing:before{content:"\\f20b"}.icon-boxes-stacked:before{content:"\\f20c"}.icon-boxes:before{content:"\\f20d"}.icon-bracket-curly-right:before{content:"\\f20e"}.icon-bracket-curly:before{content:"\\f20f"}.icon-bracket-round-right:before{content:"\\f210"}.icon-bracket-round:before{content:"\\f211"}.icon-bracket-square-right:before{content:"\\f212"}.icon-bracket-square:before{content:"\\f213"}.icon-brackets-curly:before{content:"\\f214"}.icon-brackets-round:before{content:"\\f215"}.icon-brackets-square:before{content:"\\f216"}.icon-brackets:before{content:"\\f217"}.icon-brake-warning:before{content:"\\f218"}.icon-briefcase-arrow-right:before{content:"\\f219"}.icon-briefcase-blank:before{content:"\\f21a"}.icon-briefcase-medical:before{content:"\\f21b"}.icon-briefcase:before{content:"\\f21c"}.icon-brightness-low:before{content:"\\f21d"}.icon-brightness:before{content:"\\f21e"}.icon-bring-forward:before{content:"\\f21f"}.icon-bring-front:before{content:"\\f220"}.icon-broadcast-tower:before{content:"\\f221"}.icon-broom-ball:before{content:"\\f222"}.icon-broom:before{content:"\\f223"}.icon-browser:before{content:"\\f224"}.icon-browsers:before{content:"\\f225"}.icon-bucket:before{content:"\\f226"}.icon-building-circle-arrow-right:before{content:"\\f227"}.icon-building-circle-check:before{content:"\\f228"}.icon-building-circle-exclamation:before{content:"\\f229"}.icon-building-circle-xmark:before{content:"\\f22a"}.icon-building-columns:before{content:"\\f22b"}.icon-building-flag:before{content:"\\f22c"}.icon-building-lock:before{content:"\\f22d"}.icon-building-shield:before{content:"\\f22e"}.icon-building-user:before{content:"\\f22f"}.icon-building:before{content:"\\f230"}.icon-buildings:before{content:"\\f231"}.icon-bullhorn:before{content:"\\f232"}.icon-bullseye-arrow:before{content:"\\f233"}.icon-bullseye-pointer:before{content:"\\f234"}.icon-bullseye:before{content:"\\f235"}.icon-business-time:before{content:"\\f236"}.icon-cabinet-filing:before{content:"\\f237"}.icon-cake-candles:before{content:"\\f238"}.icon-calculator-alt:before{content:"\\f239"}.icon-calculator-simple:before{content:"\\f23a"}.icon-calculator:before{content:"\\f23b"}.icon-calendar-alt:before{content:"\\f23c"}.icon-calendar-arrow-down:before{content:"\\f23d"}.icon-calendar-arrow-up:before{content:"\\f23e"}.icon-calendar-check:before{content:"\\f23f"}.icon-calendar-circle-exclamation:before{content:"\\f240"}.icon-calendar-circle-minus:before{content:"\\f241"}.icon-calendar-circle-plus:before{content:"\\f242"}.icon-calendar-circle-user:before{content:"\\f243"}.icon-calendar-clock:before{content:"\\f244"}.icon-calendar-day:before{content:"\\f245"}.icon-calendar-days:before{content:"\\f246"}.icon-calendar-edit:before{content:"\\f247"}.icon-calendar-exclamation:before{content:"\\f248"}.icon-calendar-heart:before{content:"\\f249"}.icon-calendar-image:before{content:"\\f24a"}.icon-calendar-lines-pen:before{content:"\\f24b"}.icon-calendar-lines:before{content:"\\f24c"}.icon-calendar-minus:before{content:"\\f24d"}.icon-calendar-pen:before{content:"\\f24e"}.icon-calendar-plus:before{content:"\\f24f"}.icon-calendar-range:before{content:"\\f250"}.icon-calendar-star:before{content:"\\f251"}.icon-calendar-times:before{content:"\\f252"}.icon-calendar-week:before{content:"\\f253"}.icon-calendar-xmark:before{content:"\\f254"}.icon-calendar:before{content:"\\f255"}.icon-calendars:before{content:"\\f256"}.icon-camera-alt:before{content:"\\f257"}.icon-camera-retro:before{content:"\\f258"}.icon-camera-rotate:before{content:"\\f259"}.icon-camera-slash:before{content:"\\f25a"}.icon-camera-viewfinder:before{content:"\\f25b"}.icon-camera-web-slash:before{content:"\\f25c"}.icon-camera-web:before{content:"\\f25d"}.icon-camera:before{content:"\\f25e"}.icon-cards-blank:before{content:"\\f25f"}.icon-caret-circle-down:before{content:"\\f260"}.icon-caret-circle-left:before{content:"\\f261"}.icon-caret-circle-right:before{content:"\\f262"}.icon-caret-circle-up:before{content:"\\f263"}.icon-caret-down:before{content:"\\f264"}.icon-caret-left:before{content:"\\f265"}.icon-caret-right:before{content:"\\f266"}.icon-caret-square-down:before{content:"\\f267"}.icon-caret-square-left:before{content:"\\f268"}.icon-caret-square-right:before{content:"\\f269"}.icon-caret-square-up:before{content:"\\f26a"}.icon-caret-up:before{content:"\\f26b"}.icon-cart-arrow-down:before{content:"\\f26c"}.icon-cart-arrow-up:before{content:"\\f26d"}.icon-cart-circle-arrow-down:before{content:"\\f26e"}.icon-cart-circle-arrow-up:before{content:"\\f26f"}.icon-cart-circle-check:before{content:"\\f270"}.icon-cart-circle-exclamation:before{content:"\\f271"}.icon-cart-circle-plus:before{content:"\\f272"}.icon-cart-circle-xmark:before{content:"\\f273"}.icon-cart-flatbed-boxes:before{content:"\\f274"}.icon-cart-flatbed-empty:before{content:"\\f275"}.icon-cart-flatbed-suitcase:before{content:"\\f276"}.icon-cart-flatbed:before{content:"\\f277"}.icon-cart-minus:before{content:"\\f278"}.icon-cart-plus:before{content:"\\f279"}.icon-cart-shopping-fast:before{content:"\\f27a"}.icon-cart-shopping:before{content:"\\f27b"}.icon-cart-xmark:before{content:"\\f27c"}.icon-certificate:before{content:"\\f27d"}.icon-chalkboard-teacher:before{content:"\\f27e"}.icon-chalkboard-user:before{content:"\\f27f"}.icon-chalkboard:before{content:"\\f280"}.icon-chart-area:before{content:"\\f281"}.icon-chart-bar:before{content:"\\f282"}.icon-chart-bullet:before{content:"\\f283"}.icon-chart-candlestick:before{content:"\\f284"}.icon-chart-column:before{content:"\\f285"}.icon-chart-gantt:before{content:"\\f286"}.icon-chart-line-down:before{content:"\\f287"}.icon-chart-line-up:before{content:"\\f288"}.icon-chart-line:before{content:"\\f289"}.icon-chart-mixed:before{content:"\\f28a"}.icon-chart-network:before{content:"\\f28b"}.icon-chart-pie-alt:before{content:"\\f28c"}.icon-chart-pie-simple:before{content:"\\f28d"}.icon-chart-pie:before{content:"\\f28e"}.icon-chart-pyramid:before{content:"\\f28f"}.icon-chart-radar:before{content:"\\f290"}.icon-chart-scatter-3d:before{content:"\\f291"}.icon-chart-scatter-bubble:before{content:"\\f292"}.icon-chart-scatter:before{content:"\\f293"}.icon-chart-simple-horizontal:before{content:"\\f294"}.icon-chart-simple:before{content:"\\f295"}.icon-chart-tree-map:before{content:"\\f296"}.icon-chart-user:before{content:"\\f297"}.icon-chart-waterfall:before{content:"\\f298"}.icon-check-circle:before{content:"\\f299"}.icon-check-double:before{content:"\\f29a"}.icon-check-square:before{content:"\\f29b"}.icon-check-to-slot:before{content:"\\f29c"}.icon-check:before{content:"\\f29d"}.icon-chevron-circle-down:before{content:"\\f29e"}.icon-chevron-circle-left:before{content:"\\f29f"}.icon-chevron-circle-right:before{content:"\\f2a0"}.icon-chevron-circle-up:before{content:"\\f2a1"}.icon-chevron-double-down:before{content:"\\f2a2"}.icon-chevron-double-left:before{content:"\\f2a3"}.icon-chevron-double-right:before{content:"\\f2a4"}.icon-chevron-double-up:before{content:"\\f2a5"}.icon-chevron-down:before{content:"\\f2a6"}.icon-chevron-left:before{content:"\\f2a7"}.icon-chevron-right:before{content:"\\f2a8"}.icon-chevron-square-down:before{content:"\\f2a9"}.icon-chevron-square-left:before{content:"\\f2aa"}.icon-chevron-square-right:before{content:"\\f2ab"}.icon-chevron-square-up:before{content:"\\f2ac"}.icon-chevron-up:before{content:"\\f2ad"}.icon-chevrons-down:before{content:"\\f2ae"}.icon-chevrons-left:before{content:"\\f2af"}.icon-chevrons-right:before{content:"\\f2b0"}.icon-chevrons-up:before{content:"\\f2b1"}.icon-circle-arrow-down-left:before{content:"\\f2b2"}.icon-circle-arrow-down-right:before{content:"\\f2b3"}.icon-circle-arrow-down:before{content:"\\f2b4"}.icon-circle-arrow-left:before{content:"\\f2b5"}.icon-circle-arrow-right:before{content:"\\f2b6"}.icon-circle-arrow-up-left:before{content:"\\f2b7"}.icon-circle-arrow-up-right:before{content:"\\f2b8"}.icon-circle-arrow-up:before{content:"\\f2b9"}.icon-circle-bolt:before{content:"\\f2ba"}.icon-circle-book-open:before{content:"\\f2bb"}.icon-circle-bookmark:before{content:"\\f2bc"}.icon-circle-calendar:before{content:"\\f2bd"}.icon-circle-camera:before{content:"\\f2be"}.icon-circle-caret-down:before{content:"\\f2bf"}.icon-circle-caret-left:before{content:"\\f2c0"}.icon-circle-caret-right:before{content:"\\f2c1"}.icon-circle-caret-up:before{content:"\\f2c2"}.icon-circle-check:before{content:"\\f2c3"}.icon-circle-chevron-down:before{content:"\\f2c4"}.icon-circle-chevron-left:before{content:"\\f2c5"}.icon-circle-chevron-right:before{content:"\\f2c6"}.icon-circle-chevron-up:before{content:"\\f2c7"}.icon-circle-dashed:before{content:"\\f2c8"}.icon-circle-divide:before{content:"\\f2c9"}.icon-circle-dollar-to-slot:before{content:"\\f2ca"}.icon-circle-dollar:before{content:"\\f2cb"}.icon-circle-dot:before{content:"\\f2cc"}.icon-circle-down-left:before{content:"\\f2cd"}.icon-circle-down-right:before{content:"\\f2ce"}.icon-circle-down:before{content:"\\f2cf"}.icon-circle-ellipsis-vertical:before{content:"\\f2d0"}.icon-circle-ellipsis:before{content:"\\f2d1"}.icon-circle-envelope:before{content:"\\f2d2"}.icon-circle-exclamation-check:before{content:"\\f2d3"}.icon-circle-exclamation:before{content:"\\f2d4"}.icon-circle-half-stroke:before{content:"\\f2d5"}.icon-circle-half:before{content:"\\f2d6"}.icon-circle-info:before{content:"\\f2d7"}.icon-circle-left:before{content:"\\f2d8"}.icon-circle-location-arrow:before{content:"\\f2d9"}.icon-circle-microphone-lines:before{content:"\\f2da"}.icon-circle-microphone:before{content:"\\f2db"}.icon-circle-minus:before{content:"\\f2dc"}.icon-circle-nodes:before{content:"\\f2dd"}.icon-circle-notch:before{content:"\\f2de"}.icon-circle-parking:before{content:"\\f2df"}.icon-circle-pause:before{content:"\\f2e0"}.icon-circle-phone-flip:before{content:"\\f2e1"}.icon-circle-phone-hangup:before{content:"\\f2e2"}.icon-circle-phone:before{content:"\\f2e3"}.icon-circle-play:before{content:"\\f2e4"}.icon-circle-plus:before{content:"\\f2e5"}.icon-circle-quarter:before{content:"\\f2e6"}.icon-circle-quarters:before{content:"\\f2e7"}.icon-circle-question:before{content:"\\f2e8"}.icon-circle-right:before{content:"\\f2e9"}.icon-circle-small:before{content:"\\f2ea"}.icon-circle-sort-down:before{content:"\\f2eb"}.icon-circle-sort-up:before{content:"\\f2ec"}.icon-circle-sort:before{content:"\\f2ed"}.icon-circle-star:before{content:"\\f2ee"}.icon-circle-stop:before{content:"\\f2ef"}.icon-circle-three-quarters:before{content:"\\f2f0"}.icon-circle-trash:before{content:"\\f2f1"}.icon-circle-up-left:before{content:"\\f2f2"}.icon-circle-up-right:before{content:"\\f2f3"}.icon-circle-up:before{content:"\\f2f4"}.icon-circle-user:before{content:"\\f2f5"}.icon-circle-video:before{content:"\\f2f6"}.icon-circle-waveform-lines:before{content:"\\f2f7"}.icon-circle-xmark:before{content:"\\f2f8"}.icon-circle:before{content:"\\f2f9"}.icon-city:before{content:"\\f2fa"}.icon-clapperboard-play:before{content:"\\f2fb"}.icon-clapperboard:before{content:"\\f2fc"}.icon-clinic-medical:before{content:"\\f2fd"}.icon-clipboard-check:before{content:"\\f2fe"}.icon-clipboard-list-check:before{content:"\\f2ff"}.icon-clipboard-list:before{content:"\\f300"}.icon-clipboard-medical:before{content:"\\f301"}.icon-clipboard-question:before{content:"\\f302"}.icon-clipboard-user:before{content:"\\f303"}.icon-clipboard:before{content:"\\f304"}.icon-clock-desk:before{content:"\\f305"}.icon-clock-eight-thirty:before{content:"\\f306"}.icon-clock-eight:before{content:"\\f307"}.icon-clock-eleven-thirty:before{content:"\\f308"}.icon-clock-eleven:before{content:"\\f309"}.icon-clock-five-thirty:before{content:"\\f30a"}.icon-clock-five:before{content:"\\f30b"}.icon-clock-four-thirty:before{content:"\\f30c"}.icon-clock-nine-thirty:before{content:"\\f30d"}.icon-clock-nine:before{content:"\\f30e"}.icon-clock-one-thirty:before{content:"\\f30f"}.icon-clock-one:before{content:"\\f310"}.icon-clock-rotate-left:before{content:"\\f311"}.icon-clock-seven-thirty:before{content:"\\f312"}.icon-clock-seven:before{content:"\\f313"}.icon-clock-six-thirty:before{content:"\\f314"}.icon-clock-six:before{content:"\\f315"}.icon-clock-ten-thirty:before{content:"\\f316"}.icon-clock-ten:before{content:"\\f317"}.icon-clock-three-thirty:before{content:"\\f318"}.icon-clock-three:before{content:"\\f319"}.icon-clock-twelve-thirty:before{content:"\\f31a"}.icon-clock-twelve:before{content:"\\f31b"}.icon-clock-two-thirty:before{content:"\\f31c"}.icon-clock-two:before{content:"\\f31d"}.icon-clock:before{content:"\\f31e"}.icon-clone:before{content:"\\f31f"}.icon-closed-captioning-slash:before{content:"\\f320"}.icon-closed-captioning:before{content:"\\f321"}.icon-cloud-arrow-down:before{content:"\\f322"}.icon-cloud-arrow-up:before{content:"\\f323"}.icon-cloud-check:before{content:"\\f324"}.icon-cloud-download-alt:before{content:"\\f325"}.icon-cloud-download:before{content:"\\f326"}.icon-cloud-exclamation:before{content:"\\f327"}.icon-cloud-fog:before{content:"\\f328"}.icon-cloud-minus:before{content:"\\f329"}.icon-cloud-music:before{content:"\\f32a"}.icon-cloud-plus:before{content:"\\f32b"}.icon-cloud-question:before{content:"\\f32c"}.icon-cloud-slash:before{content:"\\f32d"}.icon-cloud-upload-alt:before{content:"\\f32e"}.icon-cloud-upload:before{content:"\\f32f"}.icon-cloud-word:before{content:"\\f330"}.icon-cloud-xmark:before{content:"\\f331"}.icon-cloud:before{content:"\\f332"}.icon-clouds:before{content:"\\f333"}.icon-code-branch:before{content:"\\f334"}.icon-code-commit:before{content:"\\f335"}.icon-code-compare:before{content:"\\f336"}.icon-code-fork:before{content:"\\f337"}.icon-code-merge:before{content:"\\f338"}.icon-code-pull-request-closed:before{content:"\\f339"}.icon-code-pull-request-draft:before{content:"\\f33a"}.icon-code-pull-request:before{content:"\\f33b"}.icon-code-simple:before{content:"\\f33c"}.icon-code:before{content:"\\f33d"}.icon-cog:before{content:"\\f33e"}.icon-cogs:before{content:"\\f33f"}.icon-coins:before{content:"\\f340"}.icon-columns-3:before{content:"\\f341"}.icon-columns:before{content:"\\f342"}.icon-command:before{content:"\\f343"}.icon-comment-alt-check:before{content:"\\f344"}.icon-comment-alt-dollar:before{content:"\\f345"}.icon-comment-alt-dots:before{content:"\\f346"}.icon-comment-alt-edit:before{content:"\\f347"}.icon-comment-alt-exclamation:before{content:"\\f348"}.icon-comment-alt-lines:before{content:"\\f349"}.icon-comment-alt-medical:before{content:"\\f34a"}.icon-comment-alt-minus:before{content:"\\f34b"}.icon-comment-alt-music:before{content:"\\f34c"}.icon-comment-alt-plus:before{content:"\\f34d"}.icon-comment-alt-slash:before{content:"\\f34e"}.icon-comment-alt-smile:before{content:"\\f34f"}.icon-comment-alt-times:before{content:"\\f350"}.icon-comment-alt:before{content:"\\f351"}.icon-comment-arrow-down:before{content:"\\f352"}.icon-comment-arrow-up-right:before{content:"\\f353"}.icon-comment-arrow-up:before{content:"\\f354"}.icon-comment-captions:before{content:"\\f355"}.icon-comment-check:before{content:"\\f356"}.icon-comment-code:before{content:"\\f357"}.icon-comment-dollar:before{content:"\\f358"}.icon-comment-dots:before{content:"\\f359"}.icon-comment-edit:before{content:"\\f35a"}.icon-comment-exclamation:before{content:"\\f35b"}.icon-comment-image:before{content:"\\f35c"}.icon-comment-lines:before{content:"\\f35d"}.icon-comment-medical:before{content:"\\f35e"}.icon-comment-middle-top:before{content:"\\f35f"}.icon-comment-middle:before{content:"\\f360"}.icon-comment-minus:before{content:"\\f361"}.icon-comment-music:before{content:"\\f362"}.icon-comment-pen:before{content:"\\f363"}.icon-comment-plus:before{content:"\\f364"}.icon-comment-question:before{content:"\\f365"}.icon-comment-quote:before{content:"\\f366"}.icon-comment-slash:before{content:"\\f367"}.icon-comment-smile:before{content:"\\f368"}.icon-comment-sms:before{content:"\\f369"}.icon-comment-text:before{content:"\\f36a"}.icon-comment-times:before{content:"\\f36b"}.icon-comment-xmark:before{content:"\\f36c"}.icon-comment:before{content:"\\f36d"}.icon-comments-alt-dollar:before{content:"\\f36e"}.icon-comments-alt:before{content:"\\f36f"}.icon-comments-dollar:before{content:"\\f370"}.icon-comments-question-check:before{content:"\\f371"}.icon-comments-question:before{content:"\\f372"}.icon-comments:before{content:"\\f373"}.icon-compact-disc:before{content:"\\f374"}.icon-compass-slash:before{content:"\\f375"}.icon-compass:before{content:"\\f376"}.icon-compress-alt:before{content:"\\f377"}.icon-compress-arrows-alt:before{content:"\\f378"}.icon-compress-wide:before{content:"\\f379"}.icon-compress:before{content:"\\f37a"}.icon-container-storage:before{content:"\\f37b"}.icon-conveyor-belt-alt:before{content:"\\f37c"}.icon-conveyor-belt-boxes:before{content:"\\f37d"}.icon-conveyor-belt-empty:before{content:"\\f37e"}.icon-conveyor-belt:before{content:"\\f37f"}.icon-copy:before{content:"\\f380"}.icon-corner:before{content:"\\f381"}.icon-cowbell-circle-plus:before{content:"\\f382"}.icon-cowbell-more:before{content:"\\f383"}.icon-cowbell:before{content:"\\f384"}.icon-crate-apple:before{content:"\\f385"}.icon-crate-empty:before{content:"\\f386"}.icon-credit-card-blank:before{content:"\\f387"}.icon-credit-card-front:before{content:"\\f388"}.icon-credit-card:before{content:"\\f389"}.icon-crop-alt:before{content:"\\f38a"}.icon-crop-simple:before{content:"\\f38b"}.icon-crop:before{content:"\\f38c"}.icon-crosshairs:before{content:"\\f38d"}.icon-cube:before{content:"\\f38e"}.icon-cubes-stacked:before{content:"\\f38f"}.icon-cubes:before{content:"\\f390"}.icon-currency-sign:before{content:"\\f391"}.icon-dash:before{content:"\\f392"}.icon-dashboard:before{content:"\\f393"}.icon-database:before{content:"\\f394"}.icon-deaf:before{content:"\\f395"}.icon-delete-left:before{content:"\\f396"}.icon-delete-right:before{content:"\\f397"}.icon-desktop-alt:before{content:"\\f398"}.icon-desktop-arrow-down:before{content:"\\f399"}.icon-desktop:before{content:"\\f39a"}.icon-diagram-cells:before{content:"\\f39b"}.icon-diagram-lean-canvas:before{content:"\\f39c"}.icon-diagram-nested:before{content:"\\f39d"}.icon-diagram-next:before{content:"\\f39e"}.icon-diagram-predecessor:before{content:"\\f39f"}.icon-diagram-previous:before{content:"\\f3a0"}.icon-diagram-project:before{content:"\\f3a1"}.icon-diagram-sankey:before{content:"\\f3a2"}.icon-diagram-subtask:before{content:"\\f3a3"}.icon-diagram-successor:before{content:"\\f3a4"}.icon-diagram-venn:before{content:"\\f3a5"}.icon-diamond-exclamation:before{content:"\\f3a6"}.icon-diamond-turn-right:before{content:"\\f3a7"}.icon-diamond:before{content:"\\f3a8"}.icon-dice-d6:before{content:"\\f3a9"}.icon-digging:before{content:"\\f3aa"}.icon-diploma:before{content:"\\f3ab"}.icon-directions:before{content:"\\f3ac"}.icon-disc-drive:before{content:"\\f3ad"}.icon-display-arrow-down:before{content:"\\f3ae"}.icon-display-code:before{content:"\\f3af"}.icon-display-medical:before{content:"\\f3b0"}.icon-display-slash:before{content:"\\f3b1"}.icon-display:before{content:"\\f3b2"}.icon-distribute-spacing-horizontal:before{content:"\\f3b3"}.icon-distribute-spacing-vertical:before{content:"\\f3b4"}.icon-ditto:before{content:"\\f3b5"}.icon-divide:before{content:"\\f3b6"}.icon-do-not-enter:before{content:"\\f3b7"}.icon-dollar-sign:before{content:"\\f3b8"}.icon-dolly-empty:before{content:"\\f3b9"}.icon-dolly-flatbed-alt:before{content:"\\f3ba"}.icon-dolly-flatbed-empty:before{content:"\\f3bb"}.icon-dolly-flatbed:before{content:"\\f3bc"}.icon-dolly:before{content:"\\f3bd"}.icon-door-closed:before{content:"\\f3be"}.icon-door-open:before{content:"\\f3bf"}.icon-dot-circle:before{content:"\\f3c0"}.icon-down-from-dotted-line:before{content:"\\f3c1"}.icon-down-from-line:before{content:"\\f3c2"}.icon-down-left-and-up-right-to-center:before{content:"\\f3c3"}.icon-down-left:before{content:"\\f3c4"}.icon-down-long:before{content:"\\f3c5"}.icon-down-right:before{content:"\\f3c6"}.icon-down-to-bracket:before{content:"\\f3c7"}.icon-down-to-dotted-line:before{content:"\\f3c8"}.icon-down-to-line:before{content:"\\f3c9"}.icon-down:before{content:"\\f3ca"}.icon-download:before{content:"\\f3cb"}.icon-drafting-compass:before{content:"\\f3cc"}.icon-draw-circle:before{content:"\\f3cd"}.icon-draw-polygon:before{content:"\\f3ce"}.icon-draw-square:before{content:"\\f3cf"}.icon-earth-africa:before{content:"\\f3d0"}.icon-earth-americas:before{content:"\\f3d1"}.icon-earth-asia:before{content:"\\f3d2"}.icon-earth-europe:before{content:"\\f3d3"}.icon-earth-oceania:before{content:"\\f3d4"}.icon-edit:before{content:"\\f3d5"}.icon-eject:before{content:"\\f3d6"}.icon-elevator:before{content:"\\f3d7"}.icon-ellipsis-h-alt:before{content:"\\f3d8"}.icon-ellipsis-h:before{content:"\\f3d9"}.icon-ellipsis-stroke-vertical:before{content:"\\f3da"}.icon-ellipsis-stroke:before{content:"\\f3db"}.icon-ellipsis-v-alt:before{content:"\\f3dc"}.icon-ellipsis-v:before{content:"\\f3dd"}.icon-ellipsis-vertical:before{content:"\\f3de"}.icon-ellipsis:before{content:"\\f3df"}.icon-empty-set:before{content:"\\f3e0"}.icon-envelope-circle-check:before{content:"\\f3e1"}.icon-envelope-dot:before{content:"\\f3e2"}.icon-envelope-open-dollar:before{content:"\\f3e3"}.icon-envelope-open-text:before{content:"\\f3e4"}.icon-envelope-open:before{content:"\\f3e5"}.icon-envelope-square:before{content:"\\f3e6"}.icon-envelope:before{content:"\\f3e7"}.icon-envelopes-bulk:before{content:"\\f3e8"}.icon-envelopes:before{content:"\\f3e9"}.icon-equals:before{content:"\\f3ea"}.icon-eraser:before{content:"\\f3eb"}.icon-ethernet:before{content:"\\f3ec"}.icon-euro-sign:before{content:"\\f3ed"}.icon-exchange-alt:before{content:"\\f3ee"}.icon-exchange:before{content:"\\f3ef"}.icon-exclamation-circle:before{content:"\\f3f0"}.icon-exclamation-sign:before{content:"\\f3f1"}.icon-exclamation-square:before{content:"\\f3f2"}.icon-exclamation-triangle:before{content:"\\f3f3"}.icon-exclamation:before{content:"\\f3f4"}.icon-expand-alt:before{content:"\\f3f5"}.icon-expand-arrows-alt:before{content:"\\f3f6"}.icon-expand-arrows:before{content:"\\f3f7"}.icon-expand-wide:before{content:"\\f3f8"}.icon-expand:before{content:"\\f3f9"}.icon-external-link-alt:before{content:"\\f3fa"}.icon-external-link-square-alt:before{content:"\\f3fb"}.icon-external-link-square:before{content:"\\f3fc"}.icon-external-link:before{content:"\\f3fd"}.icon-eye-dropper-full:before{content:"\\f3fe"}.icon-eye-dropper-half:before{content:"\\f3ff"}.icon-eye-dropper:before{content:"\\f400"}.icon-eye-low-vision:before{content:"\\f401"}.icon-eye-slash:before{content:"\\f402"}.icon-eye:before{content:"\\f403"}.icon-face-smile:before{content:"\\f404"}.icon-fast-backward:before{content:"\\f405"}.icon-fast-forward:before{content:"\\f406"}.icon-fax:before{content:"\\f407"}.icon-file-alt:before{content:"\\f408"}.icon-file-archive:before{content:"\\f409"}.icon-file-arrow-down:before{content:"\\f40a"}.icon-file-arrow-up:before{content:"\\f40b"}.icon-file-audio:before{content:"\\f40c"}.icon-file-binary:before{content:"\\f40d"}.icon-file-certificate:before{content:"\\f40e"}.icon-file-chart-column:before{content:"\\f40f"}.icon-file-chart-line:before{content:"\\f410"}.icon-file-chart-pie:before{content:"\\f411"}.icon-file-check:before{content:"\\f412"}.icon-file-circle-check:before{content:"\\f413"}.icon-file-circle-exclamation:before{content:"\\f414"}.icon-file-circle-info:before{content:"\\f415"}.icon-file-circle-minus:before{content:"\\f416"}.icon-file-circle-plus:before{content:"\\f417"}.icon-file-circle-question:before{content:"\\f418"}.icon-file-circle-xmark:before{content:"\\f419"}.icon-file-code:before{content:"\\f41a"}.icon-file-contract:before{content:"\\f41b"}.icon-file-csv:before{content:"\\f41c"}.icon-file-dashed-line:before{content:"\\f41d"}.icon-file-download:before{content:"\\f41e"}.icon-file-edit:before{content:"\\f41f"}.icon-file-excel:before{content:"\\f420"}.icon-file-exclamation:before{content:"\\f421"}.icon-file-export:before{content:"\\f422"}.icon-file-heart:before{content:"\\f423"}.icon-file-image:before{content:"\\f424"}.icon-file-import:before{content:"\\f425"}.icon-file-invoice-dollar:before{content:"\\f426"}.icon-file-invoice:before{content:"\\f427"}.icon-file-lines:before{content:"\\f428"}.icon-file-lock:before{content:"\\f429"}.icon-file-magnifying-glass:before{content:"\\f42a"}.icon-file-medical-alt:before{content:"\\f42b"}.icon-file-medical:before{content:"\\f42c"}.icon-file-minus:before{content:"\\f42d"}.icon-file-music:before{content:"\\f42e"}.icon-file-pdf:before{content:"\\f42f"}.icon-file-pen:before{content:"\\f430"}.icon-file-plus-minus:before{content:"\\f431"}.icon-file-plus:before{content:"\\f432"}.icon-file-powerpoint:before{content:"\\f433"}.icon-file-search:before{content:"\\f434"}.icon-file-shield:before{content:"\\f435"}.icon-file-signature:before{content:"\\f436"}.icon-file-slash:before{content:"\\f437"}.icon-file-spreadsheet:before{content:"\\f438"}.icon-file-times:before{content:"\\f439"}.icon-file-upload:before{content:"\\f43a"}.icon-file-user:before{content:"\\f43b"}.icon-file-video:before{content:"\\f43c"}.icon-file-waveform:before{content:"\\f43d"}.icon-file-word:before{content:"\\f43e"}.icon-file-xmark:before{content:"\\f43f"}.icon-file-zipper:before{content:"\\f440"}.icon-file:before{content:"\\f441"}.icon-files-medical:before{content:"\\f442"}.icon-files:before{content:"\\f443"}.icon-fill-drip:before{content:"\\f444"}.icon-fill:before{content:"\\f445"}.icon-filter-circle-dollar:before{content:"\\f446"}.icon-filter-circle-xmark:before{content:"\\f447"}.icon-filter-list:before{content:"\\f448"}.icon-filter-slash:before{content:"\\f449"}.icon-filter:before{content:"\\f44a"}.icon-filters:before{content:"\\f44b"}.icon-fingerprint:before{content:"\\f44c"}.icon-fire-burner:before{content:"\\f44d"}.icon-fire-flame:before{content:"\\f44e"}.icon-fire:before{content:"\\f44f"}.icon-flag-alt:before{content:"\\f450"}.icon-flag-checkered:before{content:"\\f451"}.icon-flag-pennant:before{content:"\\f452"}.icon-flag-swallowtail:before{content:"\\f453"}.icon-flag:before{content:"\\f454"}.icon-flame:before{content:"\\f455"}.icon-floppy-disk-circle-arrow-right:before{content:"\\f456"}.icon-floppy-disk-circle-xmark:before{content:"\\f457"}.icon-floppy-disk-pen:before{content:"\\f458"}.icon-floppy-disk:before{content:"\\f459"}.icon-floppy-disks:before{content:"\\f45a"}.icon-folder-arrow-down:before{content:"\\f45b"}.icon-folder-arrow-up:before{content:"\\f45c"}.icon-folder-bookmark:before{content:"\\f45d"}.icon-folder-closed:before{content:"\\f45e"}.icon-folder-gear:before{content:"\\f45f"}.icon-folder-grid:before{content:"\\f460"}.icon-folder-heart:before{content:"\\f461"}.icon-folder-image:before{content:"\\f462"}.icon-folder-magnifying-glass:before{content:"\\f463"}.icon-folder-medical:before{content:"\\f464"}.icon-folder-minus:before{content:"\\f465"}.icon-folder-music:before{content:"\\f466"}.icon-folder-open:before{content:"\\f467"}.icon-folder-plus:before{content:"\\f468"}.icon-folder-times:before{content:"\\f469"}.icon-folder-tree:before{content:"\\f46a"}.icon-folder-user:before{content:"\\f46b"}.icon-folder-xmark:before{content:"\\f46c"}.icon-folder:before{content:"\\f46d"}.icon-folders:before{content:"\\f46e"}.icon-font-awesome-logo-full:before{content:"\\f46f"}.icon-font-awesome:before{content:"\\f470"}.icon-font-case:before{content:"\\f471"}.icon-font:before{content:"\\f472"}.icon-forward-fast:before{content:"\\f473"}.icon-forward-step:before{content:"\\f474"}.icon-forward:before{content:"\\f475"}.icon-frame:before{content:"\\f476"}.icon-frown-open:before{content:"\\f477"}.icon-frown:before{content:"\\f478"}.icon-function:before{content:"\\f479"}.icon-funnel-dollar:before{content:"\\f47a"}.icon-fup:before{content:"\\f47b"}.icon-g:before{content:"\\f47c"}.icon-gallery-thumbnails:before{content:"\\f47d"}.icon-gauge-circle-bolt:before{content:"\\f47e"}.icon-gauge-circle-minus:before{content:"\\f47f"}.icon-gauge-circle-plus:before{content:"\\f480"}.icon-gauge-high:before{content:"\\f481"}.icon-gauge-low:before{content:"\\f482"}.icon-gauge-max:before{content:"\\f483"}.icon-gauge-min:before{content:"\\f484"}.icon-gauge-simple-high:before{content:"\\f485"}.icon-gauge-simple-low:before{content:"\\f486"}.icon-gauge-simple-max:before{content:"\\f487"}.icon-gauge-simple-min:before{content:"\\f488"}.icon-gauge-simple:before{content:"\\f489"}.icon-gauge:before{content:"\\f48a"}.icon-gear:before{content:"\\f48b"}.icon-gears:before{content:"\\f48c"}.icon-genderless:before{content:"\\f48d"}.icon-gif:before{content:"\\f48e"}.icon-gift-card:before{content:"\\f48f"}.icon-gift:before{content:"\\f490"}.icon-gifts:before{content:"\\f491"}.icon-glass-empty:before{content:"\\f492"}.icon-glass-half:before{content:"\\f493"}.icon-glass-water-droplet:before{content:"\\f494"}.icon-glass-water:before{content:"\\f495"}.icon-glass:before{content:"\\f496"}.icon-globe-africa:before{content:"\\f497"}.icon-globe-americas:before{content:"\\f498"}.icon-globe-asia:before{content:"\\f499"}.icon-globe-europe:before{content:"\\f49a"}.icon-globe-snow:before{content:"\\f49b"}.icon-globe:before{content:"\\f49c"}.icon-greater-than-equal:before{content:"\\f49d"}.icon-greater-than:before{content:"\\f49e"}.icon-grid-2-plus:before{content:"\\f49f"}.icon-grid-2:before{content:"\\f4a0"}.icon-grid-4:before{content:"\\f4a1"}.icon-grid-5:before{content:"\\f4a2"}.icon-grid-dividers:before{content:"\\f4a3"}.icon-grid-horizontal:before{content:"\\f4a4"}.icon-grid:before{content:"\\f4a5"}.icon-grip-dots-vertical:before{content:"\\f4a6"}.icon-grip-dots:before{content:"\\f4a7"}.icon-grip-horizontal:before{content:"\\f4a8"}.icon-grip-lines-vertical:before{content:"\\f4a9"}.icon-grip-lines:before{content:"\\f4aa"}.icon-grip-vertical:before{content:"\\f4ab"}.icon-grip:before{content:"\\f4ac"}.icon-group-arrows-rotate:before{content:"\\f4ad"}.icon-h-square:before{content:"\\f4ae"}.icon-h:before{content:"\\f4af"}.icon-h1:before{content:"\\f4b0"}.icon-h2:before{content:"\\f4b1"}.icon-h3:before{content:"\\f4b2"}.icon-h4:before{content:"\\f4b3"}.icon-h5:before{content:"\\f4b4"}.icon-h6:before{content:"\\f4b5"}.icon-hammer:before{content:"\\f4b6"}.icon-hand-back-fist:before{content:"\\f4b7"}.icon-hand-back-point-down:before{content:"\\f4b8"}.icon-hand-back-point-left:before{content:"\\f4b9"}.icon-hand-back-point-ribbon:before{content:"\\f4ba"}.icon-hand-back-point-right:before{content:"\\f4bb"}.icon-hand-back-point-up:before{content:"\\f4bc"}.icon-hand-dots:before{content:"\\f4bd"}.icon-hand-fingers-crossed:before{content:"\\f4be"}.icon-hand-fist:before{content:"\\f4bf"}.icon-hand-heart:before{content:"\\f4c0"}.icon-hand-holding-box:before{content:"\\f4c1"}.icon-hand-holding-dollar:before{content:"\\f4c2"}.icon-hand-holding-droplet:before{content:"\\f4c3"}.icon-hand-holding-hand:before{content:"\\f4c4"}.icon-hand-holding-heart:before{content:"\\f4c5"}.icon-hand-holding-seedling:before{content:"\\f4c6"}.icon-hand-holding-usd:before{content:"\\f4c7"}.icon-hand-holding-water:before{content:"\\f4c8"}.icon-hand-holding:before{content:"\\f4c9"}.icon-hand-horns:before{content:"\\f4ca"}.icon-hand-love:before{content:"\\f4cb"}.icon-hand-paper:before{content:"\\f4cc"}.icon-hand-peace:before{content:"\\f4cd"}.icon-hand-point-down:before{content:"\\f4ce"}.icon-hand-point-left:before{content:"\\f4cf"}.icon-hand-point-ribbon:before{content:"\\f4d0"}.icon-hand-point-right:before{content:"\\f4d1"}.icon-hand-point-up:before{content:"\\f4d2"}.icon-hand-pointer:before{content:"\\f4d3"}.icon-hand-receiving:before{content:"\\f4d4"}.icon-hand-rock:before{content:"\\f4d5"}.icon-hand-scissors:before{content:"\\f4d6"}.icon-hand-sparkles:before{content:"\\f4d7"}.icon-hand-spock:before{content:"\\f4d8"}.icon-hand-wave:before{content:"\\f4d9"}.icon-hand:before{content:"\\f4da"}.icon-hands-asl-interpreting:before{content:"\\f4db"}.icon-hands-bound:before{content:"\\f4dc"}.icon-hands-bubbles:before{content:"\\f4dd"}.icon-hands-clapping:before{content:"\\f4de"}.icon-hands-heart:before{content:"\\f4df"}.icon-hands-helping:before{content:"\\f4e0"}.icon-hands-holding-child:before{content:"\\f4e1"}.icon-hands-holding-circle:before{content:"\\f4e2"}.icon-hands-holding-diamond:before{content:"\\f4e3"}.icon-hands-holding-dollar:before{content:"\\f4e4"}.icon-hands-holding-heart:before{content:"\\f4e5"}.icon-hands-holding:before{content:"\\f4e6"}.icon-hands-praying:before{content:"\\f4e7"}.icon-hands-usd:before{content:"\\f4e8"}.icon-hands:before{content:"\\f4e9"}.icon-handshake-alt:before{content:"\\f4ea"}.icon-handshake-angle:before{content:"\\f4eb"}.icon-handshake-simple-slash:before{content:"\\f4ec"}.icon-handshake-simple:before{content:"\\f4ed"}.icon-handshake-slash:before{content:"\\f4ee"}.icon-handshake:before{content:"\\f4ef"}.icon-hard-drive:before{content:"\\f4f0"}.icon-hashtag-lock:before{content:"\\f4f1"}.icon-hashtag:before{content:"\\f4f2"}.icon-hat-wizard:before{content:"\\f4f3"}.icon-hdd:before{content:"\\f4f4"}.icon-heading:before{content:"\\f4f5"}.icon-headphones-alt:before{content:"\\f4f6"}.icon-headphones-simple:before{content:"\\f4f7"}.icon-headphones:before{content:"\\f4f8"}.icon-headset:before{content:"\\f4f9"}.icon-heart:before{content:"\\f4fa"}.icon-hexagon-check:before{content:"\\f4fb"}.icon-hexagon-divide:before{content:"\\f4fc"}.icon-hexagon-exclamation:before{content:"\\f4fd"}.icon-hexagon-image:before{content:"\\f4fe"}.icon-hexagon-minus:before{content:"\\f4ff"}.icon-hexagon-plus:before{content:"\\f500"}.icon-hexagon-xmark:before{content:"\\f501"}.icon-hexagon:before{content:"\\f502"}.icon-high-definition:before{content:"\\f503"}.icon-highlighter-line:before{content:"\\f504"}.icon-highlighter:before{content:"\\f505"}.icon-history:before{content:"\\f506"}.icon-hockey-puck:before{content:"\\f507"}.icon-home-alt:before{content:"\\f508"}.icon-home-heart:before{content:"\\f509"}.icon-home-lg-alt:before{content:"\\f50a"}.icon-home-lg:before{content:"\\f50b"}.icon-home:before{content:"\\f50c"}.icon-horizontal-rule:before{content:"\\f50d"}.icon-hospital-alt:before{content:"\\f50e"}.icon-hospital-symbol:before{content:"\\f50f"}.icon-hotel:before{content:"\\f510"}.icon-hourglass-clock:before{content:"\\f511"}.icon-hourglass-empty:before{content:"\\f512"}.icon-hourglass-end:before{content:"\\f513"}.icon-hourglass-half:before{content:"\\f514"}.icon-hourglass-start:before{content:"\\f515"}.icon-hourglass:before{content:"\\f516"}.icon-house-blank:before{content:"\\f517"}.icon-house-building:before{content:"\\f518"}.icon-house-chimney-blank:before{content:"\\f519"}.icon-house-chimney-crack:before{content:"\\f51a"}.icon-house-chimney-heart:before{content:"\\f51b"}.icon-house-chimney-medical:before{content:"\\f51c"}.icon-house-chimney-user:before{content:"\\f51d"}.icon-house-chimney-window:before{content:"\\f51e"}.icon-house-chimney:before{content:"\\f51f"}.icon-house-circle-check:before{content:"\\f520"}.icon-house-circle-exclamation:before{content:"\\f521"}.icon-house-circle-xmark:before{content:"\\f522"}.icon-house-crack:before{content:"\\f523"}.icon-house-damage:before{content:"\\f524"}.icon-house-day:before{content:"\\f525"}.icon-house-fire:before{content:"\\f526"}.icon-house-flag:before{content:"\\f527"}.icon-house-flood-water-circle-arrow-right:before{content:"\\f528"}.icon-house-flood-water:before{content:"\\f529"}.icon-house-flood:before{content:"\\f52a"}.icon-house-heart:before{content:"\\f52b"}.icon-house-laptop:before{content:"\\f52c"}.icon-house-lock:before{content:"\\f52d"}.icon-house-medical-circle-check:before{content:"\\f52e"}.icon-house-medical-circle-exclamation:before{content:"\\f52f"}.icon-house-medical-circle-xmark:before{content:"\\f530"}.icon-house-medical-flag:before{content:"\\f531"}.icon-house-medical:before{content:"\\f532"}.icon-house-night:before{content:"\\f533"}.icon-house-person-leave:before{content:"\\f534"}.icon-house-person-return:before{content:"\\f535"}.icon-house-signal:before{content:"\\f536"}.icon-house-user:before{content:"\\f537"}.icon-house-water:before{content:"\\f538"}.icon-house-window:before{content:"\\f539"}.icon-house:before{content:"\\f53a"}.icon-hyphen:before{content:"\\f53b"}.icon-i-cursor:before{content:"\\f53c"}.icon-i:before{content:"\\f53d"}.icon-icons-alt:before{content:"\\f53e"}.icon-icons:before{content:"\\f53f"}.icon-id-badge:before{content:"\\f540"}.icon-id-card-alt:before{content:"\\f541"}.icon-id-card-clip:before{content:"\\f542"}.icon-id-card:before{content:"\\f543"}.icon-image-landscape:before{content:"\\f544"}.icon-image-polaroid-user:before{content:"\\f545"}.icon-image-polaroid:before{content:"\\f546"}.icon-image-portrait:before{content:"\\f547"}.icon-image-slash:before{content:"\\f548"}.icon-image-user:before{content:"\\f549"}.icon-image:before{content:"\\f54a"}.icon-images-user:before{content:"\\f54b"}.icon-images:before{content:"\\f54c"}.icon-inbox-full:before{content:"\\f54d"}.icon-inbox-in:before{content:"\\f54e"}.icon-inbox-out:before{content:"\\f54f"}.icon-inbox:before{content:"\\f550"}.icon-inboxes:before{content:"\\f551"}.icon-indent:before{content:"\\f552"}.icon-industry-alt:before{content:"\\f553"}.icon-industry-windows:before{content:"\\f554"}.icon-industry:before{content:"\\f555"}.icon-infinity:before{content:"\\f556"}.icon-info-circle:before{content:"\\f557"}.icon-info-square:before{content:"\\f558"}.icon-info:before{content:"\\f559"}.icon-input-numeric:before{content:"\\f55a"}.icon-input-pipe:before{content:"\\f55b"}.icon-input-text:before{content:"\\f55c"}.icon-integral:before{content:"\\f55d"}.icon-intersection:before{content:"\\f55e"}.icon-inventory:before{content:"\\f55f"}.icon-italic:before{content:"\\f560"}.icon-kaaba:before{content:"\\f561"}.icon-key-skeleton-left-right:before{content:"\\f562"}.icon-key-skeleton:before{content:"\\f563"}.icon-key:before{content:"\\f564"}.icon-keyboard-brightness-low:before{content:"\\f565"}.icon-keyboard-brightness:before{content:"\\f566"}.icon-keyboard-down:before{content:"\\f567"}.icon-keyboard-left:before{content:"\\f568"}.icon-keyboard:before{content:"\\f569"}.icon-keynote:before{content:"\\f56a"}.icon-lambda:before{content:"\\f56b"}.icon-landmark-alt:before{content:"\\f56c"}.icon-landmark-dome:before{content:"\\f56d"}.icon-landmark-flag:before{content:"\\f56e"}.icon-landmark:before{content:"\\f56f"}.icon-language:before{content:"\\f570"}.icon-laptop-arrow-down:before{content:"\\f571"}.icon-laptop-code:before{content:"\\f572"}.icon-laptop-file:before{content:"\\f573"}.icon-laptop-medical:before{content:"\\f574"}.icon-laptop-mobile:before{content:"\\f575"}.icon-laptop-slash:before{content:"\\f576"}.icon-laptop:before{content:"\\f577"}.icon-lasso-sparkles:before{content:"\\f578"}.icon-lasso:before{content:"\\f579"}.icon-layer-group:before{content:"\\f57a"}.icon-layer-minus:before{content:"\\f57b"}.icon-layer-plus:before{content:"\\f57c"}.icon-layout-full:before{content:"\\f57d"}.icon-layout-left:before{content:"\\f57e"}.icon-layout-splitted-columns:before{content:"\\f57f"}.icon-layout-splitted-vert:before{content:"\\f580"}.icon-layout-splitted:before{content:"\\f581"}.icon-left-from-line:before{content:"\\f582"}.icon-left-long-to-line:before{content:"\\f583"}.icon-left-long:before{content:"\\f584"}.icon-left-right:before{content:"\\f585"}.icon-left-to-line:before{content:"\\f586"}.icon-left:before{content:"\\f587"}.icon-less-than-equal:before{content:"\\f588"}.icon-less-than:before{content:"\\f589"}.icon-level-down-alt:before{content:"\\f58a"}.icon-level-down:before{content:"\\f58b"}.icon-level-up-alt:before{content:"\\f58c"}.icon-level-up:before{content:"\\f58d"}.icon-light-emergency-on:before{content:"\\f58e"}.icon-light-emergency:before{content:"\\f58f"}.icon-light-switch-off:before{content:"\\f590"}.icon-light-switch-on:before{content:"\\f591"}.icon-light-switch:before{content:"\\f592"}.icon-lightbulb-dollar:before{content:"\\f593"}.icon-lightbulb-exclamation-on:before{content:"\\f594"}.icon-lightbulb-exclamation:before{content:"\\f595"}.icon-lightbulb-on:before{content:"\\f596"}.icon-lightbulb-slash:before{content:"\\f597"}.icon-lightbulb:before{content:"\\f598"}.icon-lightning-bolt:before{content:"\\f599"}.icon-line-columns:before{content:"\\f59a"}.icon-line-height:before{content:"\\f59b"}.icon-lines-leaning:before{content:"\\f59c"}.icon-link-horizontal-slash:before{content:"\\f59d"}.icon-link-horizontal:before{content:"\\f59e"}.icon-link-simple-slash:before{content:"\\f59f"}.icon-link-simple:before{content:"\\f5a0"}.icon-link-slash:before{content:"\\f5a1"}.icon-link:before{content:"\\f5a2"}.icon-lira-sign:before{content:"\\f5a3"}.icon-list-alt:before{content:"\\f5a4"}.icon-list-check:before{content:"\\f5a5"}.icon-list-dropdown:before{content:"\\f5a6"}.icon-list-music:before{content:"\\f5a7"}.icon-list-ol:before{content:"\\f5a8"}.icon-list-radio:before{content:"\\f5a9"}.icon-list-timeline:before{content:"\\f5aa"}.icon-list-tree:before{content:"\\f5ab"}.icon-list-ul:before{content:"\\f5ac"}.icon-list:before{content:"\\f5ad"}.icon-loader:before{content:"\\f5ae"}.icon-location-arrow:before{content:"\\f5af"}.icon-location-check:before{content:"\\f5b0"}.icon-location-circle:before{content:"\\f5b1"}.icon-location-crosshairs-slash:before{content:"\\f5b2"}.icon-location-crosshairs:before{content:"\\f5b3"}.icon-location-dot-slash:before{content:"\\f5b4"}.icon-location-dot:before{content:"\\f5b5"}.icon-location-exclamation:before{content:"\\f5b6"}.icon-location-minus:before{content:"\\f5b7"}.icon-location-pen:before{content:"\\f5b8"}.icon-location-pin-lock:before{content:"\\f5b9"}.icon-location-pin-slash:before{content:"\\f5ba"}.icon-location-pin:before{content:"\\f5bb"}.icon-location-plus:before{content:"\\f5bc"}.icon-location-question:before{content:"\\f5bd"}.icon-location-slash:before{content:"\\f5be"}.icon-location-smile:before{content:"\\f5bf"}.icon-location-xmark:before{content:"\\f5c0"}.icon-location:before{content:"\\f5c1"}.icon-lock-a:before{content:"\\f5c2"}.icon-lock-alt:before{content:"\\f5c3"}.icon-lock-hashtag:before{content:"\\f5c4"}.icon-lock-keyhole-open:before{content:"\\f5c5"}.icon-lock-keyhole:before{content:"\\f5c6"}.icon-lock-open-alt:before{content:"\\f5c7"}.icon-lock-open:before{content:"\\f5c8"}.icon-lock:before{content:"\\f5c9"}.icon-long-arrow-alt-down:before{content:"\\f5ca"}.icon-long-arrow-alt-left:before{content:"\\f5cb"}.icon-long-arrow-alt-right:before{content:"\\f5cc"}.icon-long-arrow-alt-up:before{content:"\\f5cd"}.icon-long-arrow-down:before{content:"\\f5ce"}.icon-long-arrow-left:before{content:"\\f5cf"}.icon-long-arrow-right:before{content:"\\f5d0"}.icon-long-arrow-up:before{content:"\\f5d1"}.icon-low-vision:before{content:"\\f5d2"}.icon-luggage-cart:before{content:"\\f5d3"}.icon-magic:before{content:"\\f5d4"}.icon-magnet:before{content:"\\f5d5"}.icon-magnifying-glass-arrow-right:before{content:"\\f5d6"}.icon-magnifying-glass-chart:before{content:"\\f5d7"}.icon-magnifying-glass-dollar:before{content:"\\f5d8"}.icon-magnifying-glass-location:before{content:"\\f5d9"}.icon-magnifying-glass-minus:before{content:"\\f5da"}.icon-magnifying-glass-plus:before{content:"\\f5db"}.icon-magnifying-glass:before{content:"\\f5dc"}.icon-mail-bulk:before{content:"\\f5dd"}.icon-mailbox:before{content:"\\f5de"}.icon-male:before{content:"\\f5df"}.icon-map-location-dot:before{content:"\\f5e0"}.icon-map-location:before{content:"\\f5e1"}.icon-map-marked-alt:before{content:"\\f5e2"}.icon-map-marked:before{content:"\\f5e3"}.icon-map-marker-alt-slash:before{content:"\\f5e4"}.icon-map-marker-alt:before{content:"\\f5e5"}.icon-map-marker-check:before{content:"\\f5e6"}.icon-map-marker-edit:before{content:"\\f5e7"}.icon-map-marker-exclamation:before{content:"\\f5e8"}.icon-map-marker-minus:before{content:"\\f5e9"}.icon-map-marker-plus:before{content:"\\f5ea"}.icon-map-marker-question:before{content:"\\f5eb"}.icon-map-marker-slash:before{content:"\\f5ec"}.icon-map-marker-smile:before{content:"\\f5ed"}.icon-map-marker-times:before{content:"\\f5ee"}.icon-map-marker:before{content:"\\f5ef"}.icon-map-pin:before{content:"\\f5f0"}.icon-map-signs:before{content:"\\f5f1"}.icon-map:before{content:"\\f5f2"}.icon-marker:before{content:"\\f5f3"}.icon-market-place:before{content:"\\f5f4"}.icon-market:before{content:"\\f5f5"}.icon-mattress-pillow:before{content:"\\f5f6"}.icon-maximize:before{content:"\\f5f7"}.icon-me-logo:before{content:"\\f5f8"}.icon-memo-circle-check:before{content:"\\f5f9"}.icon-memo-circle-info:before{content:"\\f5fa"}.icon-memo-pad:before{content:"\\f5fb"}.icon-memo:before{content:"\\f5fc"}.icon-memory:before{content:"\\f5fd"}.icon-merge:before{content:"\\f5fe"}.icon-message-arrow-down:before{content:"\\f5ff"}.icon-message-arrow-up-right:before{content:"\\f600"}.icon-message-arrow-up:before{content:"\\f601"}.icon-message-bot:before{content:"\\f602"}.icon-message-captions:before{content:"\\f603"}.icon-message-check:before{content:"\\f604"}.icon-message-code:before{content:"\\f605"}.icon-message-dollar:before{content:"\\f606"}.icon-message-dots:before{content:"\\f607"}.icon-message-exclamation:before{content:"\\f608"}.icon-message-image:before{content:"\\f609"}.icon-message-lines:before{content:"\\f60a"}.icon-message-medical:before{content:"\\f60b"}.icon-message-middle-top:before{content:"\\f60c"}.icon-message-middle:before{content:"\\f60d"}.icon-message-minus:before{content:"\\f60e"}.icon-message-music:before{content:"\\f60f"}.icon-message-pen:before{content:"\\f610"}.icon-message-plus:before{content:"\\f611"}.icon-message-question:before{content:"\\f612"}.icon-message-quote:before{content:"\\f613"}.icon-message-slash:before{content:"\\f614"}.icon-message-smile:before{content:"\\f615"}.icon-message-sms:before{content:"\\f616"}.icon-message-text:before{content:"\\f617"}.icon-message-xmark:before{content:"\\f618"}.icon-message:before{content:"\\f619"}.icon-messages-dollar:before{content:"\\f61a"}.icon-messages-question:before{content:"\\f61b"}.icon-messages:before{content:"\\f61c"}.icon-meter-bolt:before{content:"\\f61d"}.icon-meter-droplet:before{content:"\\f61e"}.icon-meter-fire:before{content:"\\f61f"}.icon-meter:before{content:"\\f620"}.icon-microchip-ai:before{content:"\\f621"}.icon-microchip:before{content:"\\f622"}.icon-microphone-alt-slash:before{content:"\\f623"}.icon-microphone-alt:before{content:"\\f624"}.icon-microphone-lines-slash:before{content:"\\f625"}.icon-microphone-lines:before{content:"\\f626"}.icon-microphone-slash:before{content:"\\f627"}.icon-microphone:before{content:"\\f628"}.icon-minimize:before{content:"\\f629"}.icon-minus-circle:before{content:"\\f62a"}.icon-minus-hexagon:before{content:"\\f62b"}.icon-minus-octagon:before{content:"\\f62c"}.icon-minus-square:before{content:"\\f62d"}.icon-minus:before{content:"\\f62e"}.icon-mobile-alt:before{content:"\\f62f"}.icon-mobile-android-alt:before{content:"\\f630"}.icon-mobile-android:before{content:"\\f631"}.icon-mobile-button:before{content:"\\f632"}.icon-mobile-notch:before{content:"\\f633"}.icon-mobile-retro:before{content:"\\f634"}.icon-mobile-screen-button:before{content:"\\f635"}.icon-mobile-screen:before{content:"\\f636"}.icon-mobile-signal-out:before{content:"\\f637"}.icon-mobile-signal:before{content:"\\f638"}.icon-mobile:before{content:"\\f639"}.icon-money-bill-1-wave:before{content:"\\f63a"}.icon-money-bill-1:before{content:"\\f63b"}.icon-money-bill-alt:before{content:"\\f63c"}.icon-money-bill-simple-wave:before{content:"\\f63d"}.icon-money-bill-simple:before{content:"\\f63e"}.icon-money-bill-transfer:before{content:"\\f63f"}.icon-money-bill-trend-up:before{content:"\\f640"}.icon-money-bill-wave-alt:before{content:"\\f641"}.icon-money-bill-wave:before{content:"\\f642"}.icon-money-bill-wheat:before{content:"\\f643"}.icon-money-bill:before{content:"\\f644"}.icon-money-bills-simple:before{content:"\\f645"}.icon-money-bills:before{content:"\\f646"}.icon-money-check-alt:before{content:"\\f647"}.icon-money-check-dollar-pen:before{content:"\\f648"}.icon-money-check-dollar:before{content:"\\f649"}.icon-money-check-edit-alt:before{content:"\\f64a"}.icon-money-check-edit:before{content:"\\f64b"}.icon-money-check-pen:before{content:"\\f64c"}.icon-money-check:before{content:"\\f64d"}.icon-money-from-bracket:before{content:"\\f64e"}.icon-money-simple-from-bracket:before{content:"\\f64f"}.icon-monitor-heart-rate:before{content:"\\f650"}.icon-monitor-waveform:before{content:"\\f651"}.icon-mouse-alt:before{content:"\\f652"}.icon-mouse-pointer:before{content:"\\f653"}.icon-mouse:before{content:"\\f654"}.icon-mp3-player:before{content:"\\f655"}.icon-network-wired:before{content:"\\f656"}.icon-neuter:before{content:"\\f657"}.icon-newspaper:before{content:"\\f658"}.icon-nfc-lock:before{content:"\\f659"}.icon-nfc-magnifying-glass:before{content:"\\f65a"}.icon-nfc-pen:before{content:"\\f65b"}.icon-nfc-signal:before{content:"\\f65c"}.icon-nfc-slash:before{content:"\\f65d"}.icon-nfc-symbol:before{content:"\\f65e"}.icon-nfc-trash:before{content:"\\f65f"}.icon-nfc:before{content:"\\f660"}.icon-not-equal:before{content:"\\f661"}.icon-notdef:before{content:"\\f662"}.icon-note-medical:before{content:"\\f663"}.icon-note-sticky:before{content:"\\f664"}.icon-note:before{content:"\\f665"}.icon-notebook:before{content:"\\f666"}.icon-notes-medical:before{content:"\\f667"}.icon-notes:before{content:"\\f668"}.icon-o:before{content:"\\f669"}.icon-object-exclude:before{content:"\\f66a"}.icon-object-group:before{content:"\\f66b"}.icon-object-intersect:before{content:"\\f66c"}.icon-object-subtract:before{content:"\\f66d"}.icon-object-ungroup:before{content:"\\f66e"}.icon-object-union:before{content:"\\f66f"}.icon-objects-align-bottom:before{content:"\\f670"}.icon-objects-align-center-horizontal:before{content:"\\f671"}.icon-objects-align-center-vertical:before{content:"\\f672"}.icon-objects-align-left:before{content:"\\f673"}.icon-objects-align-right:before{content:"\\f674"}.icon-objects-align-top:before{content:"\\f675"}.icon-objects-column:before{content:"\\f676"}.icon-octagon-check:before{content:"\\f677"}.icon-octagon-divide:before{content:"\\f678"}.icon-octagon-exclamation:before{content:"\\f679"}.icon-octagon-minus:before{content:"\\f67a"}.icon-octagon-plus:before{content:"\\f67b"}.icon-octagon-xmark:before{content:"\\f67c"}.icon-octagon:before{content:"\\f67d"}.icon-omega:before{content:"\\f67e"}.icon-option:before{content:"\\f67f"}.icon-outdent:before{content:"\\f680"}.icon-overline:before{content:"\\f681"}.icon-page-break:before{content:"\\f682"}.icon-page-caret-down:before{content:"\\f683"}.icon-page-caret-up:before{content:"\\f684"}.icon-page:before{content:"\\f685"}.icon-pager:before{content:"\\f686"}.icon-paint-brush-alt:before{content:"\\f687"}.icon-paint-brush:before{content:"\\f688"}.icon-paint-roller:before{content:"\\f689"}.icon-paintbrush-fine:before{content:"\\f68a"}.icon-paintbrush-pencil:before{content:"\\f68b"}.icon-paintbrush:before{content:"\\f68c"}.icon-palette:before{content:"\\f68d"}.icon-pallet-alt:before{content:"\\f68e"}.icon-pallet-box:before{content:"\\f68f"}.icon-pallet-boxes:before{content:"\\f690"}.icon-pallet:before{content:"\\f691"}.icon-panel-ews:before{content:"\\f692"}.icon-panel-fire:before{content:"\\f693"}.icon-panorama:before{content:"\\f694"}.icon-paper-plane-top:before{content:"\\f695"}.icon-paper-plane:before{content:"\\f696"}.icon-paperclip-vertical:before{content:"\\f697"}.icon-paperclip:before{content:"\\f698"}.icon-paragraph-left:before{content:"\\f699"}.icon-paragraph-rtl:before{content:"\\f69a"}.icon-paragraph:before{content:"\\f69b"}.icon-paste:before{content:"\\f69c"}.icon-pause-circle:before{content:"\\f69d"}.icon-pause:before{content:"\\f69e"}.icon-pedestal:before{content:"\\f69f"}.icon-pen-alt:before{content:"\\f6a0"}.icon-pen-circle:before{content:"\\f6a1"}.icon-pen-clip-slash:before{content:"\\f6a2"}.icon-pen-clip:before{content:"\\f6a3"}.icon-pen-fancy-slash:before{content:"\\f6a4"}.icon-pen-fancy:before{content:"\\f6a5"}.icon-pen-field:before{content:"\\f6a6"}.icon-pen-line:before{content:"\\f6a7"}.icon-pen-nib-slash:before{content:"\\f6a8"}.icon-pen-nib:before{content:"\\f6a9"}.icon-pen-paintbrush:before{content:"\\f6aa"}.icon-pen-ruler:before{content:"\\f6ab"}.icon-pen-slash:before{content:"\\f6ac"}.icon-pen-square:before{content:"\\f6ad"}.icon-pen-swirl:before{content:"\\f6ae"}.icon-pen-to-square:before{content:"\\f6af"}.icon-pen:before{content:"\\f6b0"}.icon-pencil-alt:before{content:"\\f6b1"}.icon-pencil-paintbrush:before{content:"\\f6b2"}.icon-pencil-ruler:before{content:"\\f6b3"}.icon-pencil-slash:before{content:"\\f6b4"}.icon-pencil:before{content:"\\f6b5"}.icon-pennant:before{content:"\\f6b6"}.icon-people-arrows-left-right:before{content:"\\f6b7"}.icon-people-arrows:before{content:"\\f6b8"}.icon-people-carry-box:before{content:"\\f6b9"}.icon-people-carry:before{content:"\\f6ba"}.icon-people-dress-simple:before{content:"\\f6bb"}.icon-people-dress:before{content:"\\f6bc"}.icon-people-group:before{content:"\\f6bd"}.icon-people-line:before{content:"\\f6be"}.icon-people-pants-simple:before{content:"\\f6bf"}.icon-people-pants:before{content:"\\f6c0"}.icon-people-pulling:before{content:"\\f6c1"}.icon-people-robbery:before{content:"\\f6c2"}.icon-people-roof:before{content:"\\f6c3"}.icon-people-simple:before{content:"\\f6c4"}.icon-people:before{content:"\\f6c5"}.icon-percent:before{content:"\\f6c6"}.icon-percentage:before{content:"\\f6c7"}.icon-period:before{content:"\\f6c8"}.icon-person-arrow-down-to-line:before{content:"\\f6c9"}.icon-person-arrow-up-from-line:before{content:"\\f6ca"}.icon-person-biking-mountain:before{content:"\\f6cb"}.icon-person-biking:before{content:"\\f6cc"}.icon-person-booth:before{content:"\\f6cd"}.icon-person-breastfeeding:before{content:"\\f6ce"}.icon-person-burst:before{content:"\\f6cf"}.icon-person-carry-box:before{content:"\\f6d0"}.icon-person-carry:before{content:"\\f6d1"}.icon-person-chalkboard:before{content:"\\f6d2"}.icon-person-circle-check:before{content:"\\f6d3"}.icon-person-circle-exclamation:before{content:"\\f6d4"}.icon-person-circle-minus:before{content:"\\f6d5"}.icon-person-circle-plus:before{content:"\\f6d6"}.icon-person-circle-question:before{content:"\\f6d7"}.icon-person-circle-xmark:before{content:"\\f6d8"}.icon-person-digging:before{content:"\\f6d9"}.icon-person-dolly-empty:before{content:"\\f6da"}.icon-person-dolly:before{content:"\\f6db"}.icon-person-dots-from-line:before{content:"\\f6dc"}.icon-person-dress-simple:before{content:"\\f6dd"}.icon-person-dress:before{content:"\\f6de"}.icon-person-half-dress:before{content:"\\f6df"}.icon-person-harassing:before{content:"\\f6e0"}.icon-person-hiking:before{content:"\\f6e1"}.icon-person-military-pointing:before{content:"\\f6e2"}.icon-person-military-rifle:before{content:"\\f6e3"}.icon-person-military-to-person:before{content:"\\f6e4"}.icon-person-rays:before{content:"\\f6e5"}.icon-person-running:before{content:"\\f6e6"}.icon-person-shelter:before{content:"\\f6e7"}.icon-person-sign:before{content:"\\f6e8"}.icon-person-simple:before{content:"\\f6e9"}.icon-person-to-door:before{content:"\\f6ea"}.icon-person-walking-arrow-loop-left:before{content:"\\f6eb"}.icon-person-walking-arrow-right:before{content:"\\f6ec"}.icon-person-walking-dashed-line-arrow-right:before{content:"\\f6ed"}.icon-person-walking-luggage:before{content:"\\f6ee"}.icon-person-walking-with-cane:before{content:"\\f6ef"}.icon-person-walking:before{content:"\\f6f0"}.icon-person:before{content:"\\f6f1"}.icon-peseta-sign:before{content:"\\f6f2"}.icon-peso-sign:before{content:"\\f6f3"}.icon-phone-alt:before{content:"\\f6f4"}.icon-phone-arrow-down-left:before{content:"\\f6f5"}.icon-phone-arrow-up-right:before{content:"\\f6f6"}.icon-phone-flip:before{content:"\\f6f7"}.icon-phone-hangup:before{content:"\\f6f8"}.icon-phone-intercom:before{content:"\\f6f9"}.icon-phone-laptop:before{content:"\\f6fa"}.icon-phone-missed:before{content:"\\f6fb"}.icon-phone-office:before{content:"\\f6fc"}.icon-phone-plus:before{content:"\\f6fd"}.icon-phone-rotary:before{content:"\\f6fe"}.icon-phone-slash:before{content:"\\f6ff"}.icon-phone-square-alt:before{content:"\\f700"}.icon-phone-square:before{content:"\\f701"}.icon-phone-volume:before{content:"\\f702"}.icon-phone-xmark:before{content:"\\f703"}.icon-phone:before{content:"\\f704"}.icon-photo-film-music:before{content:"\\f705"}.icon-photo-film:before{content:"\\f706"}.icon-photo-video:before{content:"\\f707"}.icon-pi:before{content:"\\f708"}.icon-pipe-circle-check:before{content:"\\f709"}.icon-pipe-collar:before{content:"\\f70a"}.icon-pipe-section:before{content:"\\f70b"}.icon-pipe-valve:before{content:"\\f70c"}.icon-pipe:before{content:"\\f70d"}.icon-planet-moon:before{content:"\\f70e"}.icon-planet-ringed:before{content:"\\f70f"}.icon-play-circle:before{content:"\\f710"}.icon-play-pause:before{content:"\\f711"}.icon-play:before{content:"\\f712"}.icon-plug-circle-bolt:before{content:"\\f713"}.icon-plug-circle-check:before{content:"\\f714"}.icon-plug-circle-exclamation:before{content:"\\f715"}.icon-plug-circle-minus:before{content:"\\f716"}.icon-plug-circle-plus:before{content:"\\f717"}.icon-plug-circle-xmark:before{content:"\\f718"}.icon-plug:before{content:"\\f719"}.icon-plus-circle:before{content:"\\f71a"}.icon-plus-hexagon:before{content:"\\f71b"}.icon-plus-large:before{content:"\\f71c"}.icon-plus-minus:before{content:"\\f71d"}.icon-plus-octagon:before{content:"\\f71e"}.icon-plus-square:before{content:"\\f71f"}.icon-plus:before{content:"\\f720"}.icon-podium-star:before{content:"\\f721"}.icon-podium:before{content:"\\f722"}.icon-poll-h:before{content:"\\f723"}.icon-poll-people:before{content:"\\f724"}.icon-poll:before{content:"\\f725"}.icon-pompebled:before{content:"\\f726"}.icon-poo-storm:before{content:"\\f727"}.icon-portrait:before{content:"\\f728"}.icon-power-off:before{content:"\\f729"}.icon-presentation-screen:before{content:"\\f72a"}.icon-presentation:before{content:"\\f72b"}.icon-preview:before{content:"\\f72c"}.icon-print-magnifying-glass:before{content:"\\f72d"}.icon-print-search:before{content:"\\f72e"}.icon-print-slash:before{content:"\\f72f"}.icon-print:before{content:"\\f730"}.icon-products:before{content:"\\f731"}.icon-project-diagram:before{content:"\\f732"}.icon-project:before{content:"\\f733"}.icon-puzzle-piece-simple:before{content:"\\f734"}.icon-puzzle-piece:before{content:"\\f735"}.icon-puzzle:before{content:"\\f736"}.icon-q:before{content:"\\f737"}.icon-qrcode:before{content:"\\f738"}.icon-question-circle:before{content:"\\f739"}.icon-question-square:before{content:"\\f73a"}.icon-question:before{content:"\\f73b"}.icon-quote-left:before{content:"\\f73c"}.icon-quote-right:before{content:"\\f73d"}.icon-quotes:before{content:"\\f73e"}.icon-random:before{content:"\\f73f"}.icon-ranking-star:before{content:"\\f740"}.icon-receipt:before{content:"\\f741"}.icon-record-vinyl:before{content:"\\f742"}.icon-rectangle-ad:before{content:"\\f743"}.icon-rectangle-barcode:before{content:"\\f744"}.icon-rectangle-code:before{content:"\\f745"}.icon-rectangle-history-circle-plus:before{content:"\\f746"}.icon-rectangle-history-circle-user:before{content:"\\f747"}.icon-rectangle-history:before{content:"\\f748"}.icon-rectangle-landscape:before{content:"\\f749"}.icon-rectangle-list:before{content:"\\f74a"}.icon-rectangle-portrait:before{content:"\\f74b"}.icon-rectangle-pro:before{content:"\\f74c"}.icon-rectangle-terminal:before{content:"\\f74d"}.icon-rectangle-vertical-history:before{content:"\\f74e"}.icon-rectangle-vertical:before{content:"\\f74f"}.icon-rectangle-wide:before{content:"\\f750"}.icon-rectangle-xmark:before{content:"\\f751"}.icon-rectangle:before{content:"\\f752"}.icon-rectangles-mixed:before{content:"\\f753"}.icon-recycle:before{content:"\\f754"}.icon-redo-alt:before{content:"\\f755"}.icon-redo:before{content:"\\f756"}.icon-reel:before{content:"\\f757"}.icon-refrigerator:before{content:"\\f758"}.icon-registered:before{content:"\\f759"}.icon-remove-format:before{content:"\\f75a"}.icon-repeat-1-alt:before{content:"\\f75b"}.icon-repeat-1:before{content:"\\f75c"}.icon-repeat-alt:before{content:"\\f75d"}.icon-repeat:before{content:"\\f75e"}.icon-reply-all:before{content:"\\f75f"}.icon-reply-clock:before{content:"\\f760"}.icon-reply:before{content:"\\f761"}.icon-restroom-simple:before{content:"\\f762"}.icon-restroom:before{content:"\\f763"}.icon-retweet-alt:before{content:"\\f764"}.icon-retweet:before{content:"\\f765"}.icon-rhombus:before{content:"\\f766"}.icon-right-from-bracket:before{content:"\\f767"}.icon-right-from-line:before{content:"\\f768"}.icon-right-left:before{content:"\\f769"}.icon-right-long-to-line:before{content:"\\f76a"}.icon-right-long:before{content:"\\f76b"}.icon-right-to-bracket:before{content:"\\f76c"}.icon-right-to-line:before{content:"\\f76d"}.icon-right:before{content:"\\f76e"}.icon-ring:before{content:"\\f76f"}.icon-road-barrier:before{content:"\\f770"}.icon-road-bridge:before{content:"\\f771"}.icon-road-circle-check:before{content:"\\f772"}.icon-road-circle-exclamation:before{content:"\\f773"}.icon-road-circle-xmark:before{content:"\\f774"}.icon-road-lock:before{content:"\\f775"}.icon-road-spikes:before{content:"\\f776"}.icon-road:before{content:"\\f777"}.icon-robot:before{content:"\\f778"}.icon-rocket-launch:before{content:"\\f779"}.icon-rocket:before{content:"\\f77a"}.icon-rotate-exclamation:before{content:"\\f77b"}.icon-rotate-left:before{content:"\\f77c"}.icon-rotate-right:before{content:"\\f77d"}.icon-rotate:before{content:"\\f77e"}.icon-route-highway:before{content:"\\f77f"}.icon-route-interstate:before{content:"\\f780"}.icon-route:before{content:"\\f781"}.icon-router:before{content:"\\f782"}.icon-rss-square:before{content:"\\f783"}.icon-rss:before{content:"\\f784"}.icon-rug:before{content:"\\f785"}.icon-ruler-combined:before{content:"\\f786"}.icon-ruler-horizontal:before{content:"\\f787"}.icon-ruler-triangle:before{content:"\\f788"}.icon-ruler-vertical:before{content:"\\f789"}.icon-ruler:before{content:"\\f78a"}.icon-running:before{content:"\\f78b"}.icon-sack-dollar:before{content:"\\f78c"}.icon-sack-xmark:before{content:"\\f78d"}.icon-sack:before{content:"\\f78e"}.icon-satellite-dish:before{content:"\\f78f"}.icon-satellite:before{content:"\\f790"}.icon-save:before{content:"\\f791"}.icon-scanner-image:before{content:"\\f792"}.icon-scanner-keyboard:before{content:"\\f793"}.icon-scanner-touchscreen:before{content:"\\f794"}.icon-scanner:before{content:"\\f795"}.icon-school-circle-check:before{content:"\\f796"}.icon-school-circle-exclamation:before{content:"\\f797"}.icon-school-circle-xmark:before{content:"\\f798"}.icon-school-flag:before{content:"\\f799"}.icon-school-lock:before{content:"\\f79a"}.icon-school:before{content:"\\f79b"}.icon-scissors:before{content:"\\f79c"}.icon-screen-users:before{content:"\\f79d"}.icon-screencast:before{content:"\\f79e"}.icon-screwdriver-wrench:before{content:"\\f79f"}.icon-screwdriver:before{content:"\\f7a0"}.icon-scribble:before{content:"\\f7a1"}.icon-scroll-old:before{content:"\\f7a2"}.icon-scroll:before{content:"\\f7a3"}.icon-scrubber:before{content:"\\f7a4"}.icon-sd-card:before{content:"\\f7a5"}.icon-sd-cards:before{content:"\\f7a6"}.icon-seal-exclamation:before{content:"\\f7a7"}.icon-seal-question:before{content:"\\f7a8"}.icon-seal:before{content:"\\f7a9"}.icon-search-dollar:before{content:"\\f7aa"}.icon-search-location:before{content:"\\f7ab"}.icon-search-minus:before{content:"\\f7ac"}.icon-search-plus:before{content:"\\f7ad"}.icon-search:before{content:"\\f7ae"}.icon-section:before{content:"\\f7af"}.icon-semicolon:before{content:"\\f7b0"}.icon-send-back:before{content:"\\f7b1"}.icon-send-backward:before{content:"\\f7b2"}.icon-sensor-cloud:before{content:"\\f7b3"}.icon-sensor-fire:before{content:"\\f7b4"}.icon-sensor-on:before{content:"\\f7b5"}.icon-sensor-triangle-exclamation:before{content:"\\f7b6"}.icon-sensor:before{content:"\\f7b7"}.icon-server:before{content:"\\f7b8"}.icon-shapes:before{content:"\\f7b9"}.icon-share-all:before{content:"\\f7ba"}.icon-share-alt-square:before{content:"\\f7bb"}.icon-share-alt:before{content:"\\f7bc"}.icon-share-from-square:before{content:"\\f7bd"}.icon-share-nodes:before{content:"\\f7be"}.icon-share-square:before{content:"\\f7bf"}.icon-share:before{content:"\\f7c0"}.icon-sheet-plastic:before{content:"\\f7c1"}.icon-shelves-empty:before{content:"\\f7c2"}.icon-shelves:before{content:"\\f7c3"}.icon-shield-alt:before{content:"\\f7c4"}.icon-shield-cat:before{content:"\\f7c5"}.icon-shield-check:before{content:"\\f7c6"}.icon-shield-cross:before{content:"\\f7c7"}.icon-shield-dog:before{content:"\\f7c8"}.icon-shield-exclamation:before{content:"\\f7c9"}.icon-shield-halved:before{content:"\\f7ca"}.icon-shield-heart:before{content:"\\f7cb"}.icon-shield-keyhole:before{content:"\\f7cc"}.icon-shield-minus:before{content:"\\f7cd"}.icon-shield-plus:before{content:"\\f7ce"}.icon-shield-quartered:before{content:"\\f7cf"}.icon-shield-slash:before{content:"\\f7d0"}.icon-shield-xmark:before{content:"\\f7d1"}.icon-shield:before{content:"\\f7d2"}.icon-ship:before{content:"\\f7d3"}.icon-shipping-fast:before{content:"\\f7d4"}.icon-shipping-timed:before{content:"\\f7d5"}.icon-shop-lock:before{content:"\\f7d6"}.icon-shop-slash:before{content:"\\f7d7"}.icon-shop:before{content:"\\f7d8"}.icon-shopping-bag:before{content:"\\f7d9"}.icon-shopping-basket:before{content:"\\f7da"}.icon-shopping-cart:before{content:"\\f7db"}.icon-shredder:before{content:"\\f7dc"}.icon-shuffle:before{content:"\\f7dd"}.icon-shutters:before{content:"\\f7de"}.icon-sidebar-flip:before{content:"\\f7df"}.icon-sidebar:before{content:"\\f7e0"}.icon-sign-hanging:before{content:"\\f7e1"}.icon-sign-in-alt:before{content:"\\f7e2"}.icon-sign-in:before{content:"\\f7e3"}.icon-sign-language:before{content:"\\f7e4"}.icon-sign-out-alt:before{content:"\\f7e5"}.icon-sign-out:before{content:"\\f7e6"}.icon-sign:before{content:"\\f7e7"}.icon-signal-1:before{content:"\\f7e8"}.icon-signal-2:before{content:"\\f7e9"}.icon-signal-3:before{content:"\\f7ea"}.icon-signal-4:before{content:"\\f7eb"}.icon-signal-alt-1:before{content:"\\f7ec"}.icon-signal-alt-2:before{content:"\\f7ed"}.icon-signal-alt-3:before{content:"\\f7ee"}.icon-signal-alt-slash:before{content:"\\f7ef"}.icon-signal-alt:before{content:"\\f7f0"}.icon-signal-bars-fair:before{content:"\\f7f1"}.icon-signal-bars-good:before{content:"\\f7f2"}.icon-signal-bars-slash:before{content:"\\f7f3"}.icon-signal-bars-weak:before{content:"\\f7f4"}.icon-signal-bars:before{content:"\\f7f5"}.icon-signal-fair:before{content:"\\f7f6"}.icon-signal-good:before{content:"\\f7f7"}.icon-signal-slash:before{content:"\\f7f8"}.icon-signal-stream-slash:before{content:"\\f7f9"}.icon-signal-stream:before{content:"\\f7fa"}.icon-signal-strong:before{content:"\\f7fb"}.icon-signal-weak:before{content:"\\f7fc"}.icon-signal:before{content:"\\f7fd"}.icon-signature-lock:before{content:"\\f7fe"}.icon-signature-slash:before{content:"\\f7ff"}.icon-signature:before{content:"\\f800"}.icon-signs-post:before{content:"\\f801"}.icon-sim-card:before{content:"\\f802"}.icon-sim-cards:before{content:"\\f803"}.icon-sink:before{content:"\\f804"}.icon-siren-on:before{content:"\\f805"}.icon-siren:before{content:"\\f806"}.icon-sitemap:before{content:"\\f807"}.icon-slash-back:before{content:"\\f808"}.icon-slash-forward:before{content:"\\f809"}.icon-slash:before{content:"\\f80a"}.icon-slider:before{content:"\\f80b"}.icon-sliders-h-square:before{content:"\\f80c"}.icon-sliders-h:before{content:"\\f80d"}.icon-sliders-simple:before{content:"\\f80e"}.icon-sliders-up:before{content:"\\f80f"}.icon-sliders-v-square:before{content:"\\f810"}.icon-sliders-v:before{content:"\\f811"}.icon-sliders:before{content:"\\f812"}.icon-smog:before{content:"\\f813"}.icon-smoke:before{content:"\\f814"}.icon-sms:before{content:"\\f815"}.icon-snooze:before{content:"\\f816"}.icon-sort-alpha-down-alt:before{content:"\\f817"}.icon-sort-alpha-down:before{content:"\\f818"}.icon-sort-alpha-up-alt:before{content:"\\f819"}.icon-sort-alpha-up:before{content:"\\f81a"}.icon-sort-alt:before{content:"\\f81b"}.icon-sort-amount-down-alt:before{content:"\\f81c"}.icon-sort-amount-down:before{content:"\\f81d"}.icon-sort-amount-up-alt:before{content:"\\f81e"}.icon-sort-amount-up:before{content:"\\f81f"}.icon-sort-down:before{content:"\\f820"}.icon-sort-numeric-down-alt:before{content:"\\f821"}.icon-sort-numeric-down:before{content:"\\f822"}.icon-sort-numeric-up-alt:before{content:"\\f823"}.icon-sort-numeric-up:before{content:"\\f824"}.icon-sort-shapes-down-alt:before{content:"\\f825"}.icon-sort-shapes-down:before{content:"\\f826"}.icon-sort-shapes-up-alt:before{content:"\\f827"}.icon-sort-shapes-up:before{content:"\\f828"}.icon-sort-size-down-alt:before{content:"\\f829"}.icon-sort-size-down:before{content:"\\f82a"}.icon-sort-size-up-alt:before{content:"\\f82b"}.icon-sort-size-up:before{content:"\\f82c"}.icon-sort-up:before{content:"\\f82d"}.icon-sort:before{content:"\\f82e"}.icon-spell-check:before{content:"\\f82f"}.icon-spinner-third:before{content:"\\f830"}.icon-spinner:before{content:"\\f831"}.icon-split:before{content:"\\f832"}.icon-splotch:before{content:"\\f833"}.icon-square-a-lock:before{content:"\\f834"}.icon-square-ampersand:before{content:"\\f835"}.icon-square-arrow-down-left:before{content:"\\f836"}.icon-square-arrow-down-right:before{content:"\\f837"}.icon-square-arrow-down:before{content:"\\f838"}.icon-square-arrow-left:before{content:"\\f839"}.icon-square-arrow-right:before{content:"\\f83a"}.icon-square-arrow-up-left:before{content:"\\f83b"}.icon-square-arrow-up-right:before{content:"\\f83c"}.icon-square-arrow-up:before{content:"\\f83d"}.icon-square-bolt:before{content:"\\f83e"}.icon-square-caret-down:before{content:"\\f83f"}.icon-square-caret-left:before{content:"\\f840"}.icon-square-caret-right:before{content:"\\f841"}.icon-square-caret-up:before{content:"\\f842"}.icon-square-check:before{content:"\\f843"}.icon-square-chevron-down:before{content:"\\f844"}.icon-square-chevron-left:before{content:"\\f845"}.icon-square-chevron-right:before{content:"\\f846"}.icon-square-chevron-up:before{content:"\\f847"}.icon-square-code:before{content:"\\f848"}.icon-square-dashed:before{content:"\\f849"}.icon-square-divide:before{content:"\\f84a"}.icon-square-dollar:before{content:"\\f84b"}.icon-square-down-left:before{content:"\\f84c"}.icon-square-down-right:before{content:"\\f84d"}.icon-square-down:before{content:"\\f84e"}.icon-square-ellipsis-vertical:before{content:"\\f84f"}.icon-square-ellipsis:before{content:"\\f850"}.icon-square-envelope:before{content:"\\f851"}.icon-square-exclamation:before{content:"\\f852"}.icon-square-fragile:before{content:"\\f853"}.icon-square-full:before{content:"\\f854"}.icon-square-info:before{content:"\\f855"}.icon-square-kanban:before{content:"\\f856"}.icon-square-left:before{content:"\\f857"}.icon-square-list:before{content:"\\f858"}.icon-square-minus:before{content:"\\f859"}.icon-square-nfi:before{content:"\\f85a"}.icon-square-parking-slash:before{content:"\\f85b"}.icon-square-parking:before{content:"\\f85c"}.icon-square-pen:before{content:"\\f85d"}.icon-square-person-confined:before{content:"\\f85e"}.icon-square-phone-flip:before{content:"\\f85f"}.icon-square-phone-hangup:before{content:"\\f860"}.icon-square-phone:before{content:"\\f861"}.icon-square-plus:before{content:"\\f862"}.icon-square-poll-horizontal:before{content:"\\f863"}.icon-square-poll-vertical:before{content:"\\f864"}.icon-square-quarters:before{content:"\\f865"}.icon-square-question:before{content:"\\f866"}.icon-square-quote:before{content:"\\f867"}.icon-square-right:before{content:"\\f868"}.icon-square-ring:before{content:"\\f869"}.icon-square-root-alt:before{content:"\\f86a"}.icon-square-root-variable:before{content:"\\f86b"}.icon-square-root:before{content:"\\f86c"}.icon-square-rss:before{content:"\\f86d"}.icon-square-share-nodes:before{content:"\\f86e"}.icon-square-sliders-vertical:before{content:"\\f86f"}.icon-square-sliders:before{content:"\\f870"}.icon-square-small:before{content:"\\f871"}.icon-square-star:before{content:"\\f872"}.icon-square-t:before{content:"\\f873"}.icon-square-terminal:before{content:"\\f874"}.icon-square-this-way-up:before{content:"\\f875"}.icon-square-up-left:before{content:"\\f876"}.icon-square-up-right:before{content:"\\f877"}.icon-square-up:before{content:"\\f878"}.icon-square-user:before{content:"\\f879"}.icon-square-virus:before{content:"\\f87a"}.icon-square-xmark:before{content:"\\f87b"}.icon-square:before{content:"\\f87c"}.icon-stairs:before{content:"\\f87d"}.icon-stamp:before{content:"\\f87e"}.icon-standard-definition:before{content:"\\f87f"}.icon-star-exclamation:before{content:"\\f880"}.icon-star-half-alt:before{content:"\\f881"}.icon-star-half-stroke:before{content:"\\f882"}.icon-star-half:before{content:"\\f883"}.icon-star-sharp-half-stroke:before{content:"\\f884"}.icon-star-sharp-half:before{content:"\\f885"}.icon-star-sharp:before{content:"\\f886"}.icon-star-shooting:before{content:"\\f887"}.icon-star:before{content:"\\f888"}.icon-stars:before{content:"\\f889"}.icon-step-backward:before{content:"\\f88a"}.icon-step-forward:before{content:"\\f88b"}.icon-stethoscope:before{content:"\\f88c"}.icon-sticky-note:before{content:"\\f88d"}.icon-stop-circle:before{content:"\\f88e"}.icon-stop:before{content:"\\f88f"}.icon-stopwatch-20:before{content:"\\f890"}.icon-stopwatch:before{content:"\\f891"}.icon-store-alt:before{content:"\\f892"}.icon-store-lock:before{content:"\\f893"}.icon-store-slash:before{content:"\\f894"}.icon-store:before{content:"\\f895"}.icon-stream:before{content:"\\f896"}.icon-street-view:before{content:"\\f897"}.icon-stretcher:before{content:"\\f898"}.icon-strikethrough:before{content:"\\f899"}.icon-subscript:before{content:"\\f89a"}.icon-sun-bright:before{content:"\\f89b"}.icon-superscript:before{content:"\\f89c"}.icon-surprise:before{content:"\\f89d"}.icon-swatchbook:before{content:"\\f89e"}.icon-swords:before{content:"\\f89f"}.icon-symbols:before{content:"\\f8a0"}.icon-sync-alt:before{content:"\\f8a1"}.icon-sync:before{content:"\\f8a2"}.icon-table-cells-large:before{content:"\\f8a3"}.icon-table-cells:before{content:"\\f8a4"}.icon-table-columns:before{content:"\\f8a5"}.icon-table-layout:before{content:"\\f8a6"}.icon-table-list:before{content:"\\f8a7"}.icon-table-picnic:before{content:"\\f8a8"}.icon-table-pivot:before{content:"\\f8a9"}.icon-table-rows:before{content:"\\f8aa"}.icon-table-tree:before{content:"\\f8ab"}.icon-table:before{content:"\\f8ac"}.icon-tablet-alt:before{content:"\\f8ad"}.icon-tablet-android-alt:before{content:"\\f8ae"}.icon-tablet-android:before{content:"\\f8af"}.icon-tablet-button:before{content:"\\f8b0"}.icon-tablet-rugged:before{content:"\\f8b1"}.icon-tablet-screen-button:before{content:"\\f8b2"}.icon-tablet-screen:before{content:"\\f8b3"}.icon-tablet:before{content:"\\f8b4"}.icon-tablets:before{content:"\\f8b5"}.icon-tachograph-digital:before{content:"\\f8b6"}.icon-tachometer-alt-average:before{content:"\\f8b7"}.icon-tachometer-alt-fast:before{content:"\\f8b8"}.icon-tachometer-alt-fastest:before{content:"\\f8b9"}.icon-tachometer-alt-slow:before{content:"\\f8ba"}.icon-tachometer-alt-slowest:before{content:"\\f8bb"}.icon-tachometer-alt:before{content:"\\f8bc"}.icon-tachometer-average:before{content:"\\f8bd"}.icon-tachometer-fast:before{content:"\\f8be"}.icon-tachometer-fastest:before{content:"\\f8bf"}.icon-tachometer-slow:before{content:"\\f8c0"}.icon-tachometer-slowest:before{content:"\\f8c1"}.icon-tachometer:before{content:"\\f8c2"}.icon-tag:before{content:"\\f8c3"}.icon-tags:before{content:"\\f8c4"}.icon-tally-1:before{content:"\\f8c5"}.icon-tally-2:before{content:"\\f8c6"}.icon-tally-3:before{content:"\\f8c7"}.icon-tally-4:before{content:"\\f8c8"}.icon-tally:before{content:"\\f8c9"}.icon-tarp-droplet:before{content:"\\f8ca"}.icon-tarp:before{content:"\\f8cb"}.icon-tasks-alt:before{content:"\\f8cc"}.icon-tasks:before{content:"\\f8cd"}.icon-terminal:before{content:"\\f8ce"}.icon-text-height:before{content:"\\f8cf"}.icon-text-size:before{content:"\\f8d0"}.icon-text-slash:before{content:"\\f8d1"}.icon-text-width:before{content:"\\f8d2"}.icon-text:before{content:"\\f8d3"}.icon-th-large:before{content:"\\f8d4"}.icon-th-list:before{content:"\\f8d5"}.icon-th:before{content:"\\f8d6"}.icon-thermometer-empty:before{content:"\\f8d7"}.icon-thermometer-full:before{content:"\\f8d8"}.icon-thermometer-half:before{content:"\\f8d9"}.icon-thermometer-quarter:before{content:"\\f8da"}.icon-thermometer-three-quarters:before{content:"\\f8db"}.icon-thermometer:before{content:"\\f8dc"}.icon-theta:before{content:"\\f8dd"}.icon-thought-bubble:before{content:"\\f8de"}.icon-thumbs-down:before{content:"\\f8df"}.icon-thumbs-up:before{content:"\\f8e0"}.icon-thumbtack:before{content:"\\f8e1"}.icon-tick:before{content:"\\f8e2"}.icon-ticket-airline:before{content:"\\f8e3"}.icon-ticket-alt:before{content:"\\f8e4"}.icon-ticket-simple:before{content:"\\f8e5"}.icon-ticket:before{content:"\\f8e6"}.icon-tickets-airline:before{content:"\\f8e7"}.icon-tilde:before{content:"\\f8e8"}.icon-timeline-arrow:before{content:"\\f8e9"}.icon-timeline:before{content:"\\f8ea"}.icon-timer:before{content:"\\f8eb"}.icon-times-circle:before{content:"\\f8ec"}.icon-times-hexagon:before{content:"\\f8ed"}.icon-times-octagon:before{content:"\\f8ee"}.icon-times-square:before{content:"\\f8ef"}.icon-times:before{content:"\\f8f0"}.icon-tint-slash:before{content:"\\f8f1"}.icon-tint:before{content:"\\f8f2"}.icon-toggle-off:before{content:"\\f8f3"}.icon-toggle-on:before{content:"\\f8f4"}.icon-toolbox:before{content:"\\f8f5"}.icon-tools:before{content:"\\f8f6"}.icon-tower-broadcast:before{content:"\\f8f7"}.icon-tower-cell:before{content:"\\f8f8"}.icon-tower-control:before{content:"\\f8f9"}.icon-tower-observation:before{content:"\\f8fa"}.icon-trademark:before{content:"\\f8fb"}.icon-traffic-cone:before{content:"\\f8fc"}.icon-traffic-light-go:before{content:"\\f8fd"}.icon-traffic-light-slow:before{content:"\\f8fe"}.icon-traffic-light-stop:before{content:"\\f8ff"}.icon-traffic-light:before{content:"\\f900"}.icon-trailer:before{content:"\\f901"}.icon-train-subway-tunnel:before{content:"\\f902"}.icon-train-subway:before{content:"\\f903"}.icon-train-track:before{content:"\\f904"}.icon-train-tram:before{content:"\\f905"}.icon-train-tunnel:before{content:"\\f906"}.icon-train:before{content:"\\f907"}.icon-tram:before{content:"\\f908"}.icon-transformer-bolt:before{content:"\\f909"}.icon-trash-alt:before{content:"\\f90a"}.icon-trash-arrow-up:before{content:"\\f90b"}.icon-trash-can-arrow-up:before{content:"\\f90c"}.icon-trash-can-check:before{content:"\\f90d"}.icon-trash-can-clock:before{content:"\\f90e"}.icon-trash-can-list:before{content:"\\f90f"}.icon-trash-can-plus:before{content:"\\f910"}.icon-trash-can-slash:before{content:"\\f911"}.icon-trash-can-undo:before{content:"\\f912"}.icon-trash-can-xmark:before{content:"\\f913"}.icon-trash-can:before{content:"\\f914"}.icon-trash-check:before{content:"\\f915"}.icon-trash-clock:before{content:"\\f916"}.icon-trash-list:before{content:"\\f917"}.icon-trash-plus:before{content:"\\f918"}.icon-trash-restore-alt:before{content:"\\f919"}.icon-trash-restore:before{content:"\\f91a"}.icon-trash-slash:before{content:"\\f91b"}.icon-trash-undo-alt:before{content:"\\f91c"}.icon-trash-undo:before{content:"\\f91d"}.icon-trash-xmark:before{content:"\\f91e"}.icon-trash:before{content:"\\f91f"}.icon-treasure-chest:before{content:"\\f920"}.icon-tree-alt:before{content:"\\f921"}.icon-tree-city:before{content:"\\f922"}.icon-triangle-exclamation:before{content:"\\f923"}.icon-triangle-instrument:before{content:"\\f924"}.icon-triangle-music:before{content:"\\f925"}.icon-triangle-person-digging:before{content:"\\f926"}.icon-triangle:before{content:"\\f927"}.icon-trillium:before{content:"\\f928"}.icon-trophy-alt:before{content:"\\f929"}.icon-trophy-star:before{content:"\\f92a"}.icon-trophy:before{content:"\\f92b"}.icon-trowel-bricks:before{content:"\\f92c"}.icon-trowel:before{content:"\\f92d"}.icon-truck-arrow-right:before{content:"\\f92e"}.icon-truck-bolt:before{content:"\\f92f"}.icon-truck-clock:before{content:"\\f930"}.icon-truck-container-empty:before{content:"\\f931"}.icon-truck-container:before{content:"\\f932"}.icon-truck-couch:before{content:"\\f933"}.icon-truck-droplet:before{content:"\\f934"}.icon-truck-fast:before{content:"\\f935"}.icon-truck-field-un:before{content:"\\f936"}.icon-truck-field:before{content:"\\f937"}.icon-truck-flatbed:before{content:"\\f938"}.icon-truck-front:before{content:"\\f939"}.icon-truck-loading:before{content:"\\f93a"}.icon-truck-medical:before{content:"\\f93b"}.icon-truck-monster:before{content:"\\f93c"}.icon-truck-moving:before{content:"\\f93d"}.icon-truck-pickup:before{content:"\\f93e"}.icon-truck-plane:before{content:"\\f93f"}.icon-truck-plow:before{content:"\\f940"}.icon-truck-ramp-box:before{content:"\\f941"}.icon-truck-ramp-couch:before{content:"\\f942"}.icon-truck-ramp:before{content:"\\f943"}.icon-truck-tow:before{content:"\\f944"}.icon-truck:before{content:"\\f945"}.icon-tty-answer:before{content:"\\f946"}.icon-tty:before{content:"\\f947"}.icon-turn-down-left:before{content:"\\f948"}.icon-turn-down-right:before{content:"\\f949"}.icon-turn-down:before{content:"\\f94a"}.icon-turn-up:before{content:"\\f94b"}.icon-turntable:before{content:"\\f94c"}.icon-tv-alt:before{content:"\\f94d"}.icon-tv-music:before{content:"\\f94e"}.icon-tv-retro:before{content:"\\f94f"}.icon-tv:before{content:"\\f950"}.icon-typewriter:before{content:"\\f951"}.icon-underline:before{content:"\\f952"}.icon-undo-alt:before{content:"\\f953"}.icon-undo:before{content:"\\f954"}.icon-universal-access:before{content:"\\f955"}.icon-university:before{content:"\\f956"}.icon-unlink:before{content:"\\f957"}.icon-unlock-alt:before{content:"\\f958"}.icon-unlock-keyhole:before{content:"\\f959"}.icon-unlock:before{content:"\\f95a"}.icon-up-down-left-right:before{content:"\\f95b"}.icon-up-down:before{content:"\\f95c"}.icon-up-from-bracket:before{content:"\\f95d"}.icon-up-from-dotted-line:before{content:"\\f95e"}.icon-up-from-line:before{content:"\\f95f"}.icon-up-left:before{content:"\\f960"}.icon-up-long:before{content:"\\f961"}.icon-up-right-and-down-left-from-center:before{content:"\\f962"}.icon-up-right-from-square:before{content:"\\f963"}.icon-up-right:before{content:"\\f964"}.icon-up-to-dotted-line:before{content:"\\f965"}.icon-up-to-line:before{content:"\\f966"}.icon-up:before{content:"\\f967"}.icon-upload:before{content:"\\f968"}.icon-usb-drive:before{content:"\\f969"}.icon-usd-circle:before{content:"\\f96a"}.icon-usd-square:before{content:"\\f96b"}.icon-user-alien:before{content:"\\f96c"}.icon-user-alt-slash:before{content:"\\f96d"}.icon-user-alt:before{content:"\\f96e"}.icon-user-astronaut:before{content:"\\f96f"}.icon-user-bounty-hunter:before{content:"\\f970"}.icon-user-chart:before{content:"\\f971"}.icon-user-check:before{content:"\\f972"}.icon-user-chef:before{content:"\\f973"}.icon-user-circle:before{content:"\\f974"}.icon-user-clock:before{content:"\\f975"}.icon-user-cog:before{content:"\\f976"}.icon-user-cowboy:before{content:"\\f977"}.icon-user-crown:before{content:"\\f978"}.icon-user-doctor-hair-long:before{content:"\\f979"}.icon-user-doctor-hair:before{content:"\\f97a"}.icon-user-doctor-message:before{content:"\\f97b"}.icon-user-doctor:before{content:"\\f97c"}.icon-user-edit:before{content:"\\f97d"}.icon-user-friends:before{content:"\\f97e"}.icon-user-gear:before{content:"\\f97f"}.icon-user-graduate:before{content:"\\f980"}.icon-user-group-crown:before{content:"\\f981"}.icon-user-group:before{content:"\\f982"}.icon-user-hair-buns:before{content:"\\f983"}.icon-user-hair-long:before{content:"\\f984"}.icon-user-hair-mullet:before{content:"\\f985"}.icon-user-hair:before{content:"\\f986"}.icon-user-hard-hat:before{content:"\\f987"}.icon-user-headset:before{content:"\\f988"}.icon-user-helmet-safety:before{content:"\\f989"}.icon-user-injured:before{content:"\\f98a"}.icon-user-large-slash:before{content:"\\f98b"}.icon-user-large:before{content:"\\f98c"}.icon-user-lock:before{content:"\\f98d"}.icon-user-md-chat:before{content:"\\f98e"}.icon-user-md:before{content:"\\f98f"}.icon-user-minus:before{content:"\\f990"}.icon-user-music:before{content:"\\f991"}.icon-user-ninja:before{content:"\\f992"}.icon-user-nurse-hair-long:before{content:"\\f993"}.icon-user-nurse-hair:before{content:"\\f994"}.icon-user-nurse:before{content:"\\f995"}.icon-user-pen:before{content:"\\f996"}.icon-user-pilot-tie:before{content:"\\f997"}.icon-user-pilot:before{content:"\\f998"}.icon-user-plus:before{content:"\\f999"}.icon-user-police-tie:before{content:"\\f99a"}.icon-user-police:before{content:"\\f99b"}.icon-user-robot-xmarks:before{content:"\\f99c"}.icon-user-robot:before{content:"\\f99d"}.icon-user-secret:before{content:"\\f99e"}.icon-user-shakespeare:before{content:"\\f99f"}.icon-user-shield:before{content:"\\f9a0"}.icon-user-slash:before{content:"\\f9a1"}.icon-user-tag:before{content:"\\f9a2"}.icon-user-tie-hair-long:before{content:"\\f9a3"}.icon-user-tie-hair:before{content:"\\f9a4"}.icon-user-tie:before{content:"\\f9a5"}.icon-user-times:before{content:"\\f9a6"}.icon-user-unlock:before{content:"\\f9a7"}.icon-user-visor:before{content:"\\f9a8"}.icon-user-vneck-hair-long:before{content:"\\f9a9"}.icon-user-vneck-hair:before{content:"\\f9aa"}.icon-user-vneck:before{content:"\\f9ab"}.icon-user-xmark:before{content:"\\f9ac"}.icon-user:before{content:"\\f9ad"}.icon-users-between-lines:before{content:"\\f9ae"}.icon-users-class:before{content:"\\f9af"}.icon-users-cog:before{content:"\\f9b0"}.icon-users-crown:before{content:"\\f9b1"}.icon-users-gear:before{content:"\\f9b2"}.icon-users-line:before{content:"\\f9b3"}.icon-users-medical:before{content:"\\f9b4"}.icon-users-rays:before{content:"\\f9b5"}.icon-users-rectangle:before{content:"\\f9b6"}.icon-users-slash:before{content:"\\f9b7"}.icon-users-viewfinder:before{content:"\\f9b8"}.icon-users:before{content:"\\f9b9"}.icon-v:before{content:"\\f9ba"}.icon-vacuum-robot:before{content:"\\f9bb"}.icon-value-absolute:before{content:"\\f9bc"}.icon-van-shuttle:before{content:"\\f9bd"}.icon-vault:before{content:"\\f9be"}.icon-vector-circle:before{content:"\\f9bf"}.icon-vector-polygon:before{content:"\\f9c0"}.icon-vector-square:before{content:"\\f9c1"}.icon-vent-damper:before{content:"\\f9c2"}.icon-vest-patches:before{content:"\\f9c3"}.icon-vest:before{content:"\\f9c4"}.icon-vhs:before{content:"\\f9c5"}.icon-vial-circle-check:before{content:"\\f9c6"}.icon-vial-virus:before{content:"\\f9c7"}.icon-vial:before{content:"\\f9c8"}.icon-vials:before{content:"\\f9c9"}.icon-video-arrow-down-left:before{content:"\\f9ca"}.icon-video-arrow-up-right:before{content:"\\f9cb"}.icon-video-plus:before{content:"\\f9cc"}.icon-video-slash:before{content:"\\f9cd"}.icon-video:before{content:"\\f9ce"}.icon-volume-down:before{content:"\\f9cf"}.icon-volume-high:before{content:"\\f9d0"}.icon-volume-low:before{content:"\\f9d1"}.icon-volume-mute:before{content:"\\f9d2"}.icon-volume-off:before{content:"\\f9d3"}.icon-volume-slash:before{content:"\\f9d4"}.icon-volume-up:before{content:"\\f9d5"}.icon-volume-xmark:before{content:"\\f9d6"}.icon-volume:before{content:"\\f9d7"}.icon-vote-nay:before{content:"\\f9d8"}.icon-vote-yea:before{content:"\\f9d9"}.icon-vr-cardboard:before{content:"\\f9da"}.icon-walking:before{content:"\\f9db"}.icon-wallet:before{content:"\\f9dc"}.icon-wand-magic-sparkles:before{content:"\\f9dd"}.icon-wand-magic:before{content:"\\f9de"}.icon-wand-sparkles:before{content:"\\f9df"}.icon-warehouse-alt:before{content:"\\f9e0"}.icon-warehouse-full:before{content:"\\f9e1"}.icon-warehouse:before{content:"\\f9e2"}.icon-watch-apple:before{content:"\\f9e3"}.icon-watch-calculator:before{content:"\\f9e4"}.icon-watch-fitness:before{content:"\\f9e5"}.icon-watch-smart:before{content:"\\f9e6"}.icon-watch:before{content:"\\f9e7"}.icon-water-arrow-down:before{content:"\\f9e8"}.icon-water-arrow-up:before{content:"\\f9e9"}.icon-water-ladder:before{content:"\\f9ea"}.icon-water-lower:before{content:"\\f9eb"}.icon-water-rise:before{content:"\\f9ec"}.icon-water:before{content:"\\f9ed"}.icon-wave-pulse:before{content:"\\f9ee"}.icon-wave-sine:before{content:"\\f9ef"}.icon-wave-square:before{content:"\\f9f0"}.icon-wave-triangle:before{content:"\\f9f1"}.icon-waveform-lines:before{content:"\\f9f2"}.icon-waveform-path:before{content:"\\f9f3"}.icon-waveform:before{content:"\\f9f4"}.icon-webcam-slash:before{content:"\\f9f5"}.icon-webcam:before{content:"\\f9f6"}.icon-weight-hanging:before{content:"\\f9f7"}.icon-weight-scale:before{content:"\\f9f8"}.icon-weight:before{content:"\\f9f9"}.icon-wheelchair:before{content:"\\f9fa"}.icon-widgets:before{content:"\\f9fb"}.icon-wifi-1:before{content:"\\f9fc"}.icon-wifi-2:before{content:"\\f9fd"}.icon-wifi-exclamation:before{content:"\\f9fe"}.icon-wifi-fair:before{content:"\\f9ff"}.icon-wifi-slash:before{content:"\\fa00"}.icon-wifi-weak:before{content:"\\fa01"}.icon-wifi:before{content:"\\fa02"}.icon-wind-warning:before{content:"\\fa03"}.icon-wind:before{content:"\\fa04"}.icon-window-alt:before{content:"\\fa05"}.icon-window-close:before{content:"\\fa06"}.icon-window-flip:before{content:"\\fa07"}.icon-window-frame-open:before{content:"\\fa08"}.icon-window-frame:before{content:"\\fa09"}.icon-window-maximize:before{content:"\\fa0a"}.icon-window-minimize:before{content:"\\fa0b"}.icon-window-restore:before{content:"\\fa0c"}.icon-window:before{content:"\\fa0d"}.icon-wreath:before{content:"\\fa0e"}.icon-wrench-simple:before{content:"\\fa0f"}.icon-wrench:before{content:"\\fa10"}.icon-x:before{content:"\\fa11"}.icon-xmark-large:before{content:"\\fa12"}.icon-xmark-to-slot:before{content:"\\fa13"}.icon-xmark:before{content:"\\fa14"}.icon-xmarks-lines:before{content:"\\fa15"}@font-face{font-family:'ME Icons Brands';src:url('/me-icons-brands.eot?v=3.5.8');src:url('/me-icons-brands.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-brands.woff?v=3.5.8') format('woff'),url('/me-icons-brands.woff2?v=3.5.8') format('woff2'),url('/me-icons-brands.ttf?v=3.5.8') format('truetype'),url('/me-icons-brands.svg?v=3.5.8#me-icons-brands') format('svg');font-weight:400;font-style:normal}.me-icon-b{font-family:'ME Icons Brands'}.icon-42-group:before{content:"\\f101"}.icon-500px:before{content:"\\f102"}.icon-accessible-icon:before{content:"\\f103"}.icon-accusoft:before{content:"\\f104"}.icon-acquisitions-incorporated:before{content:"\\f105"}.icon-adn:before{content:"\\f106"}.icon-adobe:before{content:"\\f107"}.icon-adversal:before{content:"\\f108"}.icon-affiliatetheme:before{content:"\\f109"}.icon-airbnb:before{content:"\\f10a"}.icon-algolia:before{content:"\\f10b"}.icon-alipay:before{content:"\\f10c"}.icon-amazon-pay:before{content:"\\f10d"}.icon-amazon:before{content:"\\f10e"}.icon-amilia:before{content:"\\f10f"}.icon-android:before{content:"\\f110"}.icon-angellist:before{content:"\\f111"}.icon-angrycreative:before{content:"\\f112"}.icon-angular:before{content:"\\f113"}.icon-app-store-ios:before{content:"\\f114"}.icon-app-store:before{content:"\\f115"}.icon-apper:before{content:"\\f116"}.icon-apple-pay:before{content:"\\f117"}.icon-apple:before{content:"\\f118"}.icon-artstation:before{content:"\\f119"}.icon-asymmetrik:before{content:"\\f11a"}.icon-atlassian:before{content:"\\f11b"}.icon-audible:before{content:"\\f11c"}.icon-autoprefixer:before{content:"\\f11d"}.icon-avianex:before{content:"\\f11e"}.icon-aviato:before{content:"\\f11f"}.icon-aws:before{content:"\\f120"}.icon-bandcamp:before{content:"\\f121"}.icon-battle-net:before{content:"\\f122"}.icon-behance-square:before{content:"\\f123"}.icon-behance:before{content:"\\f124"}.icon-bilibili:before{content:"\\f125"}.icon-bimobject:before{content:"\\f126"}.icon-bitbucket:before{content:"\\f127"}.icon-bitcoin:before{content:"\\f128"}.icon-bity:before{content:"\\f129"}.icon-black-tie:before{content:"\\f12a"}.icon-blackberry:before{content:"\\f12b"}.icon-blogger-b:before{content:"\\f12c"}.icon-blogger:before{content:"\\f12d"}.icon-bluetooth-b:before{content:"\\f12e"}.icon-bluetooth:before{content:"\\f12f"}.icon-bootstrap:before{content:"\\f130"}.icon-bots:before{content:"\\f131"}.icon-bridgestone:before{content:"\\f132"}.icon-btc:before{content:"\\f133"}.icon-buffer:before{content:"\\f134"}.icon-buromobelexperte:before{content:"\\f135"}.icon-buy-n-large:before{content:"\\f136"}.icon-buysellads:before{content:"\\f137"}.icon-canadian-maple-leaf:before{content:"\\f138"}.icon-cc-amazon-pay:before{content:"\\f139"}.icon-cc-amex:before{content:"\\f13a"}.icon-cc-apple-pay:before{content:"\\f13b"}.icon-cc-diners-club:before{content:"\\f13c"}.icon-cc-discover:before{content:"\\f13d"}.icon-cc-jcb:before{content:"\\f13e"}.icon-cc-mastercard:before{content:"\\f13f"}.icon-cc-paypal:before{content:"\\f140"}.icon-cc-stripe:before{content:"\\f141"}.icon-cc-visa:before{content:"\\f142"}.icon-centercode:before{content:"\\f143"}.icon-centos:before{content:"\\f144"}.icon-chrome:before{content:"\\f145"}.icon-chromecast:before{content:"\\f146"}.icon-cloudflare:before{content:"\\f147"}.icon-cloudscale:before{content:"\\f148"}.icon-cloudsmith:before{content:"\\f149"}.icon-cloudversify:before{content:"\\f14a"}.icon-cmplid:before{content:"\\f14b"}.icon-codepen:before{content:"\\f14c"}.icon-codiepie:before{content:"\\f14d"}.icon-confluence:before{content:"\\f14e"}.icon-connectdevelop:before{content:"\\f14f"}.icon-contao:before{content:"\\f150"}.icon-cotton-bureau:before{content:"\\f151"}.icon-cpanel:before{content:"\\f152"}.icon-creative-commons-by:before{content:"\\f153"}.icon-creative-commons-nc-eu:before{content:"\\f154"}.icon-creative-commons-nc-jp:before{content:"\\f155"}.icon-creative-commons-nc:before{content:"\\f156"}.icon-creative-commons-nd:before{content:"\\f157"}.icon-creative-commons-pd-alt:before{content:"\\f158"}.icon-creative-commons-pd:before{content:"\\f159"}.icon-creative-commons-remix:before{content:"\\f15a"}.icon-creative-commons-sa:before{content:"\\f15b"}.icon-creative-commons-sampling-plus:before{content:"\\f15c"}.icon-creative-commons-sampling:before{content:"\\f15d"}.icon-creative-commons-share:before{content:"\\f15e"}.icon-creative-commons-zero:before{content:"\\f15f"}.icon-creative-commons:before{content:"\\f160"}.icon-critical-role:before{content:"\\f161"}.icon-css3-alt:before{content:"\\f162"}.icon-css3:before{content:"\\f163"}.icon-cuttlefish:before{content:"\\f164"}.icon-d-and-d-beyond:before{content:"\\f165"}.icon-d-and-d:before{content:"\\f166"}.icon-dailymotion:before{content:"\\f167"}.icon-dashcube:before{content:"\\f168"}.icon-deezer:before{content:"\\f169"}.icon-delicious:before{content:"\\f16a"}.icon-deploydog:before{content:"\\f16b"}.icon-deskpro:before{content:"\\f16c"}.icon-dev:before{content:"\\f16d"}.icon-deviantart:before{content:"\\f16e"}.icon-dhl:before{content:"\\f16f"}.icon-diaspora:before{content:"\\f170"}.icon-digg:before{content:"\\f171"}.icon-digital-ocean:before{content:"\\f172"}.icon-discord:before{content:"\\f173"}.icon-discourse:before{content:"\\f174"}.icon-dochub:before{content:"\\f175"}.icon-docker:before{content:"\\f176"}.icon-draft2digital:before{content:"\\f177"}.icon-dribbble-square:before{content:"\\f178"}.icon-dribbble:before{content:"\\f179"}.icon-dropbox:before{content:"\\f17a"}.icon-drupal:before{content:"\\f17b"}.icon-dyalog:before{content:"\\f17c"}.icon-earlybirds:before{content:"\\f17d"}.icon-ebay:before{content:"\\f17e"}.icon-edge-legacy:before{content:"\\f17f"}.icon-edge:before{content:"\\f180"}.icon-elementor:before{content:"\\f181"}.icon-ello:before{content:"\\f182"}.icon-ember:before{content:"\\f183"}.icon-empire:before{content:"\\f184"}.icon-envira:before{content:"\\f185"}.icon-erlang:before{content:"\\f186"}.icon-ethereum:before{content:"\\f187"}.icon-etsy:before{content:"\\f188"}.icon-evernote:before{content:"\\f189"}.icon-expeditedssl:before{content:"\\f18a"}.icon-facebook-f:before{content:"\\f18b"}.icon-facebook-messenger:before{content:"\\f18c"}.icon-facebook-square:before{content:"\\f18d"}.icon-facebook:before{content:"\\f18e"}.icon-fantasy-flight-games:before{content:"\\f18f"}.icon-fedex:before{content:"\\f190"}.icon-fedora:before{content:"\\f191"}.icon-figma:before{content:"\\f192"}.icon-firefox-browser:before{content:"\\f193"}.icon-firefox:before{content:"\\f194"}.icon-first-order-alt:before{content:"\\f195"}.icon-first-order:before{content:"\\f196"}.icon-firstdraft:before{content:"\\f197"}.icon-flickr:before{content:"\\f198"}.icon-flipboard:before{content:"\\f199"}.icon-fly:before{content:"\\f19a"}.icon-font-awesome-alt:before{content:"\\f19b"}.icon-font-awesome-flag:before{content:"\\f19c"}.icon-font-awesome-logo-full:before{content:"\\f19d"}.icon-font-awesome:before{content:"\\f19e"}.icon-fonticons-fi:before{content:"\\f19f"}.icon-fonticons:before{content:"\\f1a0"}.icon-fort-awesome-alt:before{content:"\\f1a1"}.icon-fort-awesome:before{content:"\\f1a2"}.icon-forumbee:before{content:"\\f1a3"}.icon-foursquare:before{content:"\\f1a4"}.icon-free-code-camp:before{content:"\\f1a5"}.icon-freebsd:before{content:"\\f1a6"}.icon-fulcrum:before{content:"\\f1a7"}.icon-galactic-republic:before{content:"\\f1a8"}.icon-galactic-senate:before{content:"\\f1a9"}.icon-get-pocket:before{content:"\\f1aa"}.icon-gg-circle:before{content:"\\f1ab"}.icon-gg:before{content:"\\f1ac"}.icon-git-alt:before{content:"\\f1ad"}.icon-git-square:before{content:"\\f1ae"}.icon-git:before{content:"\\f1af"}.icon-github-alt:before{content:"\\f1b0"}.icon-github-square:before{content:"\\f1b1"}.icon-github:before{content:"\\f1b2"}.icon-gitkraken:before{content:"\\f1b3"}.icon-gitlab:before{content:"\\f1b4"}.icon-gitter:before{content:"\\f1b5"}.icon-glide-g:before{content:"\\f1b6"}.icon-glide:before{content:"\\f1b7"}.icon-gofore:before{content:"\\f1b8"}.icon-golang:before{content:"\\f1b9"}.icon-goodreads-g:before{content:"\\f1ba"}.icon-goodreads:before{content:"\\f1bb"}.icon-google-drive:before{content:"\\f1bc"}.icon-google-pay:before{content:"\\f1bd"}.icon-google-play:before{content:"\\f1be"}.icon-google-plus-g:before{content:"\\f1bf"}.icon-google-plus-square:before{content:"\\f1c0"}.icon-google-plus:before{content:"\\f1c1"}.icon-google-wallet:before{content:"\\f1c2"}.icon-google:before{content:"\\f1c3"}.icon-gratipay:before{content:"\\f1c4"}.icon-grav:before{content:"\\f1c5"}.icon-gripfire:before{content:"\\f1c6"}.icon-grunt:before{content:"\\f1c7"}.icon-guilded:before{content:"\\f1c8"}.icon-gulp:before{content:"\\f1c9"}.icon-hacker-news-square:before{content:"\\f1ca"}.icon-hacker-news:before{content:"\\f1cb"}.icon-hackerrank:before{content:"\\f1cc"}.icon-hashnode:before{content:"\\f1cd"}.icon-hips:before{content:"\\f1ce"}.icon-hire-a-helper:before{content:"\\f1cf"}.icon-hive:before{content:"\\f1d0"}.icon-hooli:before{content:"\\f1d1"}.icon-hornbill:before{content:"\\f1d2"}.icon-hotjar:before{content:"\\f1d3"}.icon-houzz:before{content:"\\f1d4"}.icon-html5:before{content:"\\f1d5"}.icon-hubspot:before{content:"\\f1d6"}.icon-ideal:before{content:"\\f1d7"}.icon-imdb:before{content:"\\f1d8"}.icon-instagram-square:before{content:"\\f1d9"}.icon-instagram:before{content:"\\f1da"}.icon-instalod:before{content:"\\f1db"}.icon-intercom:before{content:"\\f1dc"}.icon-internet-explorer:before{content:"\\f1dd"}.icon-invision:before{content:"\\f1de"}.icon-ioxhost:before{content:"\\f1df"}.icon-itch-io:before{content:"\\f1e0"}.icon-itunes-note:before{content:"\\f1e1"}.icon-itunes:before{content:"\\f1e2"}.icon-java:before{content:"\\f1e3"}.icon-jedi-order:before{content:"\\f1e4"}.icon-jenkins:before{content:"\\f1e5"}.icon-jira:before{content:"\\f1e6"}.icon-joget:before{content:"\\f1e7"}.icon-joomla:before{content:"\\f1e8"}.icon-js-square:before{content:"\\f1e9"}.icon-js:before{content:"\\f1ea"}.icon-jsfiddle:before{content:"\\f1eb"}.icon-kaggle:before{content:"\\f1ec"}.icon-keybase:before{content:"\\f1ed"}.icon-keycdn:before{content:"\\f1ee"}.icon-kickstarter-k:before{content:"\\f1ef"}.icon-kickstarter:before{content:"\\f1f0"}.icon-korvue:before{content:"\\f1f1"}.icon-laravel:before{content:"\\f1f2"}.icon-lastfm-square:before{content:"\\f1f3"}.icon-lastfm:before{content:"\\f1f4"}.icon-leanpub:before{content:"\\f1f5"}.icon-less:before{content:"\\f1f6"}.icon-line:before{content:"\\f1f7"}.icon-linkedin-in:before{content:"\\f1f8"}.icon-linkedin:before{content:"\\f1f9"}.icon-linode:before{content:"\\f1fa"}.icon-linux:before{content:"\\f1fb"}.icon-lyft:before{content:"\\f1fc"}.icon-magento:before{content:"\\f1fd"}.icon-mailchimp:before{content:"\\f1fe"}.icon-mandalorian:before{content:"\\f1ff"}.icon-markdown:before{content:"\\f200"}.icon-mastodon:before{content:"\\f201"}.icon-maxcdn:before{content:"\\f202"}.icon-mdb:before{content:"\\f203"}.icon-me-pulse:before{content:"\\f204"}.icon-me:before{content:"\\f205"}.icon-medapps:before{content:"\\f206"}.icon-medium-m:before{content:"\\f207"}.icon-medium:before{content:"\\f208"}.icon-medrt:before{content:"\\f209"}.icon-meetup:before{content:"\\f20a"}.icon-megaport:before{content:"\\f20b"}.icon-mendeley:before{content:"\\f20c"}.icon-meta:before{content:"\\f20d"}.icon-microblog:before{content:"\\f20e"}.icon-microsoft:before{content:"\\f20f"}.icon-misy:before{content:"\\f210"}.icon-mix:before{content:"\\f211"}.icon-mixcloud:before{content:"\\f212"}.icon-mixer:before{content:"\\f213"}.icon-mizuni:before{content:"\\f214"}.icon-modx:before{content:"\\f215"}.icon-monero:before{content:"\\f216"}.icon-napster:before{content:"\\f217"}.icon-neos:before{content:"\\f218"}.icon-nfc-directional:before{content:"\\f219"}.icon-nfc-symbol:before{content:"\\f21a"}.icon-nimblr:before{content:"\\f21b"}.icon-node-js:before{content:"\\f21c"}.icon-node:before{content:"\\f21d"}.icon-npm:before{content:"\\f21e"}.icon-ns8:before{content:"\\f21f"}.icon-nutritionix:before{content:"\\f220"}.icon-octopus-deploy:before{content:"\\f221"}.icon-odnoklassniki-square:before{content:"\\f222"}.icon-odnoklassniki:before{content:"\\f223"}.icon-office365:before{content:"\\f224"}.icon-old-republic:before{content:"\\f225"}.icon-opencart:before{content:"\\f226"}.icon-openid:before{content:"\\f227"}.icon-opera:before{content:"\\f228"}.icon-optin-monster:before{content:"\\f229"}.icon-orcid:before{content:"\\f22a"}.icon-osi:before{content:"\\f22b"}.icon-padlet:before{content:"\\f22c"}.icon-page4:before{content:"\\f22d"}.icon-pagelines:before{content:"\\f22e"}.icon-palfed:before{content:"\\f22f"}.icon-patreon:before{content:"\\f230"}.icon-paypal:before{content:"\\f231"}.icon-penny-arcade:before{content:"\\f232"}.icon-perbyte:before{content:"\\f233"}.icon-periscope:before{content:"\\f234"}.icon-phabricator:before{content:"\\f235"}.icon-phoenix-framework:before{content:"\\f236"}.icon-phoenix-squadron:before{content:"\\f237"}.icon-php:before{content:"\\f238"}.icon-pied-piper-alt:before{content:"\\f239"}.icon-pied-piper-hat:before{content:"\\f23a"}.icon-pied-piper-pp:before{content:"\\f23b"}.icon-pied-piper-square:before{content:"\\f23c"}.icon-pied-piper:before{content:"\\f23d"}.icon-pinterest-p:before{content:"\\f23e"}.icon-pinterest-square:before{content:"\\f23f"}.icon-pinterest:before{content:"\\f240"}.icon-pix:before{content:"\\f241"}.icon-playstation:before{content:"\\f242"}.icon-product-hunt:before{content:"\\f243"}.icon-pushed:before{content:"\\f244"}.icon-python:before{content:"\\f245"}.icon-qq:before{content:"\\f246"}.icon-quinscape:before{content:"\\f247"}.icon-quora:before{content:"\\f248"}.icon-r-project:before{content:"\\f249"}.icon-raspberry-pi:before{content:"\\f24a"}.icon-ravelry:before{content:"\\f24b"}.icon-react:before{content:"\\f24c"}.icon-reacteurope:before{content:"\\f24d"}.icon-readme:before{content:"\\f24e"}.icon-rebel:before{content:"\\f24f"}.icon-receita:before{content:"\\f250"}.icon-red-river:before{content:"\\f251"}.icon-reddit-alien:before{content:"\\f252"}.icon-reddit-square:before{content:"\\f253"}.icon-reddit:before{content:"\\f254"}.icon-redhat:before{content:"\\f255"}.icon-renren:before{content:"\\f256"}.icon-replyd:before{content:"\\f257"}.icon-researchgate:before{content:"\\f258"}.icon-resolving:before{content:"\\f259"}.icon-rev:before{content:"\\f25a"}.icon-rocketchat:before{content:"\\f25b"}.icon-rockrms:before{content:"\\f25c"}.icon-rust:before{content:"\\f25d"}.icon-safari:before{content:"\\f25e"}.icon-salesforce:before{content:"\\f25f"}.icon-sass:before{content:"\\f260"}.icon-schlix:before{content:"\\f261"}.icon-screenpal:before{content:"\\f262"}.icon-scribd:before{content:"\\f263"}.icon-searchengin:before{content:"\\f264"}.icon-sellcast:before{content:"\\f265"}.icon-sellsy:before{content:"\\f266"}.icon-servicestack:before{content:"\\f267"}.icon-shirtsinbulk:before{content:"\\f268"}.icon-shopify:before{content:"\\f269"}.icon-shopware:before{content:"\\f26a"}.icon-simplybuilt:before{content:"\\f26b"}.icon-sintegra:before{content:"\\f26c"}.icon-sistrix:before{content:"\\f26d"}.icon-sith:before{content:"\\f26e"}.icon-sitrox:before{content:"\\f26f"}.icon-sketch:before{content:"\\f270"}.icon-skyatlas:before{content:"\\f271"}.icon-skype:before{content:"\\f272"}.icon-slack-hash:before{content:"\\f273"}.icon-slack:before{content:"\\f274"}.icon-slideshare:before{content:"\\f275"}.icon-snapchat-ghost:before{content:"\\f276"}.icon-snapchat-square:before{content:"\\f277"}.icon-snapchat:before{content:"\\f278"}.icon-soundcloud:before{content:"\\f279"}.icon-sourcetree:before{content:"\\f27a"}.icon-speakap:before{content:"\\f27b"}.icon-speaker-deck:before{content:"\\f27c"}.icon-spotify:before{content:"\\f27d"}.icon-square-font-awesome-stroke:before{content:"\\f27e"}.icon-square-font-awesome:before{content:"\\f27f"}.icon-squarespace:before{content:"\\f280"}.icon-stack-exchange:before{content:"\\f281"}.icon-stack-overflow:before{content:"\\f282"}.icon-stackpath:before{content:"\\f283"}.icon-staylinked:before{content:"\\f284"}.icon-steam-square:before{content:"\\f285"}.icon-steam-symbol:before{content:"\\f286"}.icon-steam:before{content:"\\f287"}.icon-sticker-mule:before{content:"\\f288"}.icon-strava:before{content:"\\f289"}.icon-stripe-s:before{content:"\\f28a"}.icon-stripe:before{content:"\\f28b"}.icon-studiovinari:before{content:"\\f28c"}.icon-stumbleupon-circle:before{content:"\\f28d"}.icon-stumbleupon:before{content:"\\f28e"}.icon-superpowers:before{content:"\\f28f"}.icon-supple:before{content:"\\f290"}.icon-suse:before{content:"\\f291"}.icon-swift:before{content:"\\f292"}.icon-symfony:before{content:"\\f293"}.icon-teamspeak:before{content:"\\f294"}.icon-telegram-plane:before{content:"\\f295"}.icon-telegram:before{content:"\\f296"}.icon-tencent-weibo:before{content:"\\f297"}.icon-the-red-yeti:before{content:"\\f298"}.icon-themeco:before{content:"\\f299"}.icon-themeisle:before{content:"\\f29a"}.icon-think-peaks:before{content:"\\f29b"}.icon-tiktok:before{content:"\\f29c"}.icon-trade-federation:before{content:"\\f29d"}.icon-trello:before{content:"\\f29e"}.icon-tripadvisor:before{content:"\\f29f"}.icon-tumblr-square:before{content:"\\f2a0"}.icon-tumblr:before{content:"\\f2a1"}.icon-twitch:before{content:"\\f2a2"}.icon-twitter-square:before{content:"\\f2a3"}.icon-twitter:before{content:"\\f2a4"}.icon-typo3:before{content:"\\f2a5"}.icon-uber:before{content:"\\f2a6"}.icon-ubuntu:before{content:"\\f2a7"}.icon-uikit:before{content:"\\f2a8"}.icon-umbraco:before{content:"\\f2a9"}.icon-uncharted:before{content:"\\f2aa"}.icon-uniregistry:before{content:"\\f2ab"}.icon-unity:before{content:"\\f2ac"}.icon-unsplash:before{content:"\\f2ad"}.icon-untappd:before{content:"\\f2ae"}.icon-ups:before{content:"\\f2af"}.icon-usb:before{content:"\\f2b0"}.icon-usps:before{content:"\\f2b1"}.icon-ussunnah:before{content:"\\f2b2"}.icon-vaadin:before{content:"\\f2b3"}.icon-vale:before{content:"\\f2b4"}.icon-viacoin:before{content:"\\f2b5"}.icon-viadeo-square:before{content:"\\f2b6"}.icon-viadeo:before{content:"\\f2b7"}.icon-viber:before{content:"\\f2b8"}.icon-vimeo-square:before{content:"\\f2b9"}.icon-vimeo-v:before{content:"\\f2ba"}.icon-vimeo:before{content:"\\f2bb"}.icon-vine:before{content:"\\f2bc"}.icon-vk:before{content:"\\f2bd"}.icon-vnv:before{content:"\\f2be"}.icon-vuejs:before{content:"\\f2bf"}.icon-watchman-monitoring:before{content:"\\f2c0"}.icon-waze:before{content:"\\f2c1"}.icon-weebly:before{content:"\\f2c2"}.icon-weibo:before{content:"\\f2c3"}.icon-weixin:before{content:"\\f2c4"}.icon-whatsapp-square:before{content:"\\f2c5"}.icon-whatsapp:before{content:"\\f2c6"}.icon-whmcs:before{content:"\\f2c7"}.icon-wikipedia-w:before{content:"\\f2c8"}.icon-windows:before{content:"\\f2c9"}.icon-wirsindhandwerk:before{content:"\\f2ca"}.icon-wix:before{content:"\\f2cb"}.icon-wizards-of-the-coast:before{content:"\\f2cc"}.icon-wodu:before{content:"\\f2cd"}.icon-wolf-pack-battalion:before{content:"\\f2ce"}.icon-wordpress-simple:before{content:"\\f2cf"}.icon-wordpress:before{content:"\\f2d0"}.icon-wpbeginner:before{content:"\\f2d1"}.icon-wpexplorer:before{content:"\\f2d2"}.icon-wpforms:before{content:"\\f2d3"}.icon-wpressr:before{content:"\\f2d4"}.icon-xbox:before{content:"\\f2d5"}.icon-xing-square:before{content:"\\f2d6"}.icon-xing:before{content:"\\f2d7"}.icon-y-combinator:before{content:"\\f2d8"}.icon-yahoo:before{content:"\\f2d9"}.icon-yammer:before{content:"\\f2da"}.icon-yandex-international:before{content:"\\f2db"}.icon-yandex:before{content:"\\f2dc"}.icon-yarn:before{content:"\\f2dd"}.icon-yelp:before{content:"\\f2de"}.icon-yoast:before{content:"\\f2df"}.icon-youtube-square:before{content:"\\f2e0"}.icon-youtube:before{content:"\\f2e1"}.icon-zhihu:before{content:"\\f2e2"}@font-face{font-family:'ME Icons Solid';src:url('/me-icons-solid.eot?v=3.5.8');src:url('/me-icons-solid.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-solid.woff?v=3.5.8') format('woff'),url('/me-icons-solid.woff2?v=3.5.8') format('woff2'),url('/me-icons-solid.ttf?v=3.5.8') format('truetype'),url('/me-icons-solid.svg?v=3.5.8#me-icons-solid') format('svg');font-weight:400;font-style:normal}.me-icon-s{font-family:'ME Icons Solid'}@font-face{font-family:'ME Icons';src:url('/me-icons-regular.eot?v=3.5.8');src:url('/me-icons-regular.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-regular.woff?v=3.5.8') format('woff'),url('/me-icons-regular.woff2?v=3.5.8') format('woff2'),url('/me-icons-regular.ttf?v=3.5.8') format('truetype'),url('/me-icons-regular.svg?v=3.5.8#me-icons-regular') format('svg');font-weight:400;font-style:normal}.me-icon{font-family:'ME Icons'}@font-face{font-family:'ME Icons Light';src:url('/me-icons-light.eot?v=3.5.8');src:url('/me-icons-light.eot?v=3.5.8#iefix') format('embedded-opentype'),url('/me-icons-light.woff?v=3.5.8') format('woff'),url('/me-icons-light.woff2?v=3.5.8') format('woff2'),url('/me-icons-light.ttf?v=3.5.8') format('truetype'),url('/me-icons-light.svg?v=3.5.8#me-icons-light') format('svg');font-weight:400;font-style:normal}.me-icon-l{font-family:'ME Icons Light'}.me-icon-2xs{font-size:.625rem}.me-icon-xs{font-size:.75rem}.me-icon-sm{font-size:.875rem}.me-icon-md{font-size:1rem}.me-icon-lg{font-size:1.25rem}.me-icon-xl{font-size:1.5rem}.me-icon-2xl{font-size:2rem}.me-icon-spin{-webkit-animation:me-icon-spin 2s infinite linear;animation:me-icon-spin 2s infinite linear}.me-icon-pulse{-webkit-animation:me-icon-spin 1s infinite steps(8);animation:me-icon-spin 1s infinite steps(8)}@-webkit-keyframes me-icon-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes me-icon-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}`;
const TheHeaderElement = /* @__PURE__ */ defineCustomElement(_sfc_main, {
  shadowRoot: true,
  styles: [meIconStyles, tailwindStyles]
});
if (!customElements.get("the-header")) {
  customElements.define("the-header", TheHeaderElement);
}
export {
  useState as $,
  createElementBlock as A,
  createVNode as B,
  withModifiers as C,
  isClient$1 as D,
  getActiveElement as E,
  Fragment as F,
  normalizeProps as G,
  guardReactiveProps as H,
  Presence as I,
  context as J,
  focusFirst$1 as K,
  unrefElement$1 as L,
  normalizeStyle as M,
  getTabbableCandidates as N,
  useTimeoutFn as O,
  Primitive as P,
  serialize as Q,
  isRef as R,
  get as S,
  Teleport as T,
  defu as U,
  createSharedComposable as V,
  toRef$2 as W,
  inject as X,
  reactive as Y,
  h as Z,
  _sfc_main$O as _,
  useForwardExpose as a,
  reactivePick as a0,
  isEqual as a1,
  useForwardProps as a2,
  reactiveOmit as a3,
  tv as a4,
  useAppConfig as a5,
  useSlots as a6,
  useButtonGroup as a7,
  formLoadingInjectionKey as a8,
  useComponentIcons as a9,
  mergeClasses as aa,
  _sfc_main$l as ab,
  normalizeClass as ac,
  _sfc_main$j as ad,
  omit as ae,
  useForwardPropsEmits as af,
  renderList as ag,
  createBaseVNode as ah,
  resolveDynamicComponent as ai,
  usePortal as aj,
  shallowReactive as ak,
  markRaw as al,
  useId$1 as am,
  _sfc_main$Z as an,
  provide as ao,
  portalTargetInjectionKey as ap,
  createApp as aq,
  useVModel$1 as b,
  createBlock as c,
  defineComponent as d,
  watch as e,
  computed as f,
  createContext as g,
  useCollection as h,
  isNullish as i,
  ref as j,
  useTimeout as k,
  useRafFn as l,
  mergeProps as m,
  nextTick as n,
  openBlock as o,
  createCommentVNode as p,
  createTextVNode as q,
  renderSlot as r,
  toDisplayString as s,
  toRefs as t,
  unref as u,
  watchEffect as v,
  withCtx as w,
  onKeyStroke as x,
  onMounted as y,
  onUnmounted as z
};
